[{"title":"zookeeper-数据初始化分析","url":"/2019/06/25/zookeeper-数据初始化分析/","content":"\n## 概述\n\n```java\npublic class Demo {\n\n}\n```\n\n## 加载快照文件\n\n```xml\n<html>\n\t<body>hhh</body>\n</html>\n```\n\n## 加载事务日志文件\n\n","tags":["zookeeper"],"categories":["zookeeper"]},{"title":"zookeeper-数据同步源码分析","url":"/2019/05/09/zookeeper-数据同步源码分析/","content":"\n在上一篇对 **zookeeper** 选举实现分析之后，我们知道 **zookeeper** 集群在选举结束之后，**leader** 节点将进入 **LEADING** 状态，**follower** 节点将进入 **FOLLOWING** 状态；此时集群中节点将进行数据同步操作，以保证数据一致。 只有数据同步完成之后 **zookeeper** 集群才具备对外提供服务的能力。\n\n<!-- more -->\n\n## LEADING\n\n当节点在选举后角色确认为 **leader** 后将会进入 **LEADING** 状态，源码如下：\n\n```java\n\npublic void run() {\n    try {\n        /*\n         * Main loop\n         */\n        while (running) {\n            switch (getPeerState()) {\n            case LEADING:\n                LOG.info(\"LEADING\");\n                try {\n                    setLeader(makeLeader(logFactory));\n                    leader.lead();\n                    setLeader(null);\n                } catch (Exception e) {\n                    LOG.warn(\"Unexpected exception\",e);\n                } finally {\n                    if (leader != null) {\n                        leader.shutdown(\"Forcing shutdown\");\n                        setLeader(null);\n                    }\n                    setPeerState(ServerState.LOOKING);\n                }\n                break;\n            }\n        }\n    } finally {\n        \n    }\n}\n\n```\n\n**QuorumPeer** 在节点状态变更为 **LEADING** 之后会创建 **leader** 实例，并触发 **lead** 过程。\n\n```java\nvoid lead() throws IOException, InterruptedException {\n    try {\n\t\t// 省略\n\n        /**\n         * 开启线程用于接收 follower 的连接请求\n         */\n        cnxAcceptor = new LearnerCnxAcceptor();\n        cnxAcceptor.start();\n        \n        readyToStart = true;\n\n        /**\n         * 阻塞等待计算新的 epoch 值，并设置 zxid\n         */\n        long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());          \n        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n        \n        \n        /**\n         * 阻塞等待接收过半的 follower 节点发送的 ACKEPOCH 信息； 此时说明已经确定了本轮选举后 epoch 值\n         */\n        waitForEpochAck(self.getId(), leaderStateSummary);\n        self.setCurrentEpoch(epoch);\n\n        try {\n            /**\n             * 阻塞等待 超过半数的节点 follower 发送了 NEWLEADER ACK 信息；此时说明过半的 follower 节点已经完成数据同步\n             */\n            waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);\n        } catch (InterruptedException e) {\n            // 省略\n        }\n\n        /**\n         * 启动 zk server，此时集群可以对外正式提供服务\n         */\n        startZkServer();\n\n        // 省略\n}\n```\n\n从 **lead** 方法的实现可得知，**leader** 与 **follower** 在数据同步过程中会执行如下过程：\n\n* 接收 follower 连接\n* 计算新的 epoch 值\n* 通知统一 epoch 值\n* 数据同步\n* 启动 zk server 对外提供服务\n\n## FOLLOWING\n\n下面在看下 **follower** 节点进入 **FOLLOWING** 状态后的操作：\n\n```java\npublic void run() {\n    try {\n        /*\n         * Main loop\n         */\n        while (running) {\n            switch (getPeerState()) {\n            case LOOKING:\n                // 省略\n            case OBSERVING:\n                // 省略\n            case FOLLOWING:\n                try {\n                    LOG.info(\"FOLLOWING\");\n                    setFollower(makeFollower(logFactory));\n                    follower.followLeader();\n                } catch (Exception e) {\n                    LOG.warn(\"Unexpected exception\",e);\n                } finally {\n                    follower.shutdown();\n                    setFollower(null);\n                    setPeerState(ServerState.LOOKING);\n                }\n                break;\n            }\n        }\n    } finally {\n        \n    }\n}\n```\n\n**QuorumPeer** 在节点状态变更为 **FOLLOWING** 之后会创建 **follower** 实例，并触发 **followLeader** 过程。\n\n```java\nvoid followLeader() throws InterruptedException {\n    // 省略\n    try {\n        QuorumServer leaderServer = findLeader();            \n        try {\n            /**\n             * follower 与 leader 建立连接\n             */\n            connectToLeader(leaderServer.addr, leaderServer.hostname);\n\n            /**\n             * follower 向 leader 提交节点信息用于计算新的 epoch 值\n             */\n            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n\n            \n            /**\n             * follower 与 leader 数据同步\n             */\n            syncWithLeader(newEpochZxid);                \n            \n             // 省略\n\n        } catch (Exception e) {\n             // 省略\n        }\n    } finally {\n        // 省略\n    }\n}\n```\n从 **followLeader** 方法的实现可得知，**follower** 与 **leader** 在数据同步过程中会执行如下过程：\n\n* 请求连接 leader\n* 提交节点信息计算新的 epoch 值\n* 数据同步\n\n下面我们看下在各个环节的实现细节；\n\n### Leader Follower 建立通信\n\n##### follower 请求连接\n\n```java\nprotected QuorumServer findLeader() {\n    QuorumServer leaderServer = null;\n    // Find the leader by id\n    Vote current = self.getCurrentVote();\n    for (QuorumServer s : self.getView().values()) {\n        if (s.id == current.getId()) {\n            // Ensure we have the leader's correct IP address before\n            // attempting to connect.\n            s.recreateSocketAddresses();\n            leaderServer = s;\n            break;\n        }\n    }\n    if (leaderServer == null) {\n        LOG.warn(\"Couldn't find the leader with id = \"\n                + current.getId());\n    }\n    return leaderServer;\n}           \n```\n\n```java\nprotected void connectToLeader(InetSocketAddress addr, String hostname)\n            throws IOException, ConnectException, InterruptedException {\n    sock = new Socket();        \n    sock.setSoTimeout(self.tickTime * self.initLimit);\n    for (int tries = 0; tries < 5; tries++) {\n        try {\n            sock.connect(addr, self.tickTime * self.syncLimit);\n            sock.setTcpNoDelay(nodelay);\n            break;\n        } catch (IOException e) {\n            if (tries == 4) {\n                LOG.error(\"Unexpected exception\",e);\n                throw e;\n            } else {\n                LOG.warn(\"Unexpected exception, tries=\"+tries+\n                        \", connecting to \" + addr,e);\n                sock = new Socket();\n                sock.setSoTimeout(self.tickTime * self.initLimit);\n            }\n        }\n        Thread.sleep(1000);\n    }\n\n    self.authLearner.authenticate(sock, hostname);\n\n    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n            sock.getInputStream()));\n    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n}\n```\n\n**follower** 会通过选举后的投票信息确认 **leader** 节点地址，并发起连接（总共有 5 次尝试连接的机会，若连接不通则重新进入选举过程）\n\n##### leader 接收连接\n\n```java\nclass LearnerCnxAcceptor extends ZooKeeperThread{\n    private volatile boolean stop = false;\n\n    public LearnerCnxAcceptor() {\n        super(\"LearnerCnxAcceptor-\" + ss.getLocalSocketAddress());\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!stop) {\n                try{\n                \t/**\n                \t * 接收 follower 的连接，并开启 LearnerHandler 线程用于处理二者之间的通信\n                \t */\n                    Socket s = ss.accept();\n                    s.setSoTimeout(self.tickTime * self.initLimit);\n                    s.setTcpNoDelay(nodelay);\n\n                    BufferedInputStream is = new BufferedInputStream(\n                            s.getInputStream());\n                    LearnerHandler fh = new LearnerHandler(s, is, Leader.this);\n                    fh.start();\n                } catch (SocketException e) {\n                    // 省略\n                } catch (SaslException e){\n                    LOG.error(\"Exception while connecting to quorum learner\", e);\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Exception while accepting follower\", e);\n        }\n    }\n}\n```\n\n从 **LearnerCnxAcceptor** 实现可以看出 **leader** 节点在为每个 **follower** 节点连接建立之后都会为之分配一个 **LearnerHandler** 线程用于处理二者之间的通信。\n\n### 计算新的 epoch 值\n\n> **follower** 在与 **leader** 建立连接之后，会发出 **FOLLOWERINFO** 信息\n\n```java\n\nlong newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n\n```\n\n```java\nprotected long registerWithLeader(int pktType) throws IOException{\n    /**\n     * 发送 follower info 信息，包括 last zxid 和 sid\n     */\n\tlong lastLoggedZxid = self.getLastLoggedZxid();\n    QuorumPacket qp = new QuorumPacket();                \n    qp.setType(pktType);\n    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));\n    \n    /*\n     * Add sid to payload\n     */\n    LearnerInfo li = new LearnerInfo(self.getId(), 0x10000);\n    ByteArrayOutputStream bsid = new ByteArrayOutputStream();\n    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);\n    boa.writeRecord(li, \"LearnerInfo\");\n    qp.setData(bsid.toByteArray());\n    \n    /**\n\t * follower 向 leader 发送 FOLLOWERINFO 信息，包括 zxid，sid，protocol version\n\t */\n    writePacket(qp, true);\n    \n    // 省略\n} \n```\n\n接下来我们看下 **leader** 在接收到 **FOLLOWERINFO** 信息之后做什么(参考 **LearnerHandler**)\n\n```java\npublic void run() {\n\ttry {\n\t    // 省略\n\t    /**\n\t     * leader 接收 follower 发送的 FOLLOWERINFO 信息，包括 follower 节点的 zxid，sid，protocol version\n\t     * @see Learner.registerWithleader()\n\t     */\n\t    QuorumPacket qp = new QuorumPacket();\n\t    ia.readRecord(qp, \"packet\");\n\n\t    byte learnerInfoData[] = qp.getData();\n\t    if (learnerInfoData != null) {\n\t    \tif (learnerInfoData.length == 8) {\n\t    \t\t// 省略\n\t    \t} else {\n\t            /**\n\t             * 高版本的 learnerInfoData 包括 long 类型的 sid, int 类型的 protocol version 占用 12 字节\n\t             */\n\t    \t\tLearnerInfo li = new LearnerInfo();\n\t    \t\tByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(learnerInfoData), li);\n\t    \t\tthis.sid = li.getServerid();\n\t    \t\tthis.version = li.getProtocolVersion();\n\t    \t}\n\t    }\n\n\t    /**\n\t     * 通过 follower 发送的 zxid，解析出 foloower 节点的 epoch 值\n\t     */\n\t    long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n\t    \n\t    long peerLastZxid;\n\t    StateSummary ss = null;\n\t    long zxid = qp.getZxid();\n\n\t    /**\n\t     * 阻塞等待计算新的 epoch 值\n\t     */\n\t    long newEpoch = leader.getEpochToPropose(this.getSid(), lastAcceptedEpoch);\n\t  \n\t    // 省略\n\t}\n```\n\n从上述代码可知，**leader** 在接收到 **follower** 发送的 **FOLLOWERINFO** 信息之后，会解析出 **follower** 节点的 **acceptedEpoch** 值并参与到新的 **epoch** 值计算中。 （具体计算逻辑参考方法 **getEpochToPropose**）\n\n```java\npublic long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {\n    synchronized(connectingFollowers) {\n        if (!waitingForNewEpoch) {\n            return epoch;\n        }\n        // epoch 用来记录计算后的选举周期值\n        // follower 或 leader 的 acceptedEpoch 值与 epoch 比较；若前者大则将其加一\n        if (lastAcceptedEpoch >= epoch) {\n            epoch = lastAcceptedEpoch+1;\n        }\n        // connectingFollowers 用来记录与 leader 已连接的 follower\n        connectingFollowers.add(sid);\n        QuorumVerifier verifier = self.getQuorumVerifier();\n        // 判断是否已计算出新的 epoch 值的条件是 leader 已经参与了 epoch 值计算，以及超过一半的节点参与了计算\n        if (connectingFollowers.contains(self.getId()) && \n                                        verifier.containsQuorum(connectingFollowers)) {\n            // 将 waitingForNewEpoch 设置为 false 说明不需要等待计算新的 epoch 值了\n            waitingForNewEpoch = false;\n            // 设置 leader 的 acceptedEpoch 值\n            self.setAcceptedEpoch(epoch);\n            // 唤醒 connectingFollowers wait 的线程\n            connectingFollowers.notifyAll();\n        } else {\n            long start = Time.currentElapsedTime();\n            long cur = start;\n            long end = start + self.getInitLimit()*self.getTickTime();\n            while(waitingForNewEpoch && cur < end) {\n                // 若未完成新的 epoch 值计算则阻塞等待\n                connectingFollowers.wait(end - cur);\n                cur = Time.currentElapsedTime();\n            }\n            if (waitingForNewEpoch) {\n                throw new InterruptedException(\"Timeout while waiting for epoch from quorum\");        \n            }\n        }\n        return epoch;\n    }\n}\n```\n\n从方法 **getEpochToPropose** 可知 **leader** 会收集集群中过半的 **follower** **acceptedEpoch** 信息后，选出一个最大值然后加 1 就是 **newEpoch** 值； 在此过程中 **leader** 会进入阻塞状态直到过半的 **follower** 参与到计算才会进入下一阶段。\n\n### 通知新的 epoch 值\n\n**leader** 在计算出新的 **newEpoch** 值后，会进入下一阶段发送 **LEADERINFO** 信息 （同样参考 **LearnerHandler**）\n\n```java\npublic void run() {\n\ttry {\n\t    // 省略\n\n\t    /**\n\t     * 阻塞等待计算新的 epoch 值\n\t     */\n\t    long newEpoch = leader.getEpochToPropose(this.getSid(), lastAcceptedEpoch);\n            \n        if (this.getVersion() < 0x10000) {\n            // we are going to have to extrapolate the epoch information\n            long epoch = ZxidUtils.getEpochFromZxid(zxid);\n            ss = new StateSummary(epoch, zxid);\n            // fake the message\n            leader.waitForEpochAck(this.getSid(), ss);\n        } else {\n            byte ver[] = new byte[4];\n            ByteBuffer.wrap(ver).putInt(0x10000);\n            /**\n             * 计算出新的 epoch 值后，leader 向 follower 发送 LEADERINFO 信息；包括新的 newEpoch\n             */\n            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, ZxidUtils.makeZxid(newEpoch, 0), ver, null);\n            oa.writeRecord(newEpochPacket, \"packet\");\n            bufferedOutput.flush();\n\n           \t// 省略\n        }\n\t}\n\t// 省略\n}\n```\n\n```java\nprotected long registerWithLeader(int pktType) throws IOException{\n\t// 省略\n\n    /**\n     * follower 向 leader 发送 FOLLOWERINFO 信息，包括 zxid，sid，protocol version\n     */\n    writePacket(qp, true);\n\n    /**\n     * follower 接收 leader 发送的 LEADERINFO 信息\n     */\n    readPacket(qp);\n\n    /**\n     * 解析 leader 发送的 new epoch 值\n     */        \n    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());\n\tif (qp.getType() == Leader.LEADERINFO) {\n    \t// we are connected to a 1.0 server so accept the new epoch and read the next packet\n    \tleaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();\n    \tbyte epochBytes[] = new byte[4];\n    \tfinal ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);\n\n    \t/**\n    \t * new epoch > current accepted epoch 则更新 acceptedEpoch 值\n    \t */\n    \tif (newEpoch > self.getAcceptedEpoch()) {\n    \t\twrappedEpochBytes.putInt((int)self.getCurrentEpoch());\n    \t\tself.setAcceptedEpoch(newEpoch);\n    \t} else if (newEpoch == self.getAcceptedEpoch()) {   \t\t\n            wrappedEpochBytes.putInt(-1);\n    \t} else {\n    \t\tthrow new IOException(\"Leaders epoch, \" + newEpoch + \" is less than accepted epoch, \" + self.getAcceptedEpoch());\n    \t}\n\n    \t/**\n    \t * follower 向 leader 发送 ACKEPOCH 信息，包括 last zxid\n    \t */\n    \tQuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);\n    \twritePacket(ackNewEpoch, true);\n        return ZxidUtils.makeZxid(newEpoch, 0);\n    } \n} \n```\n\n从上述代码可以看出在完成 **newEpoch** 值计算后的 **leader** 与 **follower** 的交互过程：\n\n* **leader** 向 **follower** 发送 **LEADERINFO** 信息，告知 **follower** 新的 **epoch** 值\n* **follower** 接收解析 **LEADERINFO** 信息，若 **new epoch** 值大于 **current accepted epoch** 值则更新 **acceptedEpoch** \n* **follower** 向 **leader** 发送 **ACKEPOCH** 信息，反馈 **leader** 已收到新的 **epoch** 值，并附带 **follower** 节点的 **last zxid**\n\n### 数据同步\n\n> LearnerHandler 中 leader 在收到过半的 ACKEPOCH 信息之后将进入数据同步阶段\n\n```java\npublic void run() {\n        try {\n            // 省略\n            // peerLastZxid 为 follower 的 last zxid\n            peerLastZxid = ss.getLastZxid();\n            \n            /* the default to send to the follower */\n            int packetToSend = Leader.SNAP;\n            long zxidToSend = 0;\n            long leaderLastZxid = 0;\n            /** the packets that the follower needs to get updates from **/\n            long updates = peerLastZxid;\n           \n            ReentrantReadWriteLock lock = leader.zk.getZKDatabase().getLogLock();\n            ReadLock rl = lock.readLock();\n            try {\n                rl.lock();        \n                final long maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();\n                final long minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();\n\n                LinkedList<Proposal> proposals = leader.zk.getZKDatabase().getCommittedLog();\n\n                if (peerLastZxid == leader.zk.getZKDatabase().getDataTreeLastProcessedZxid()) {\n                    /**\n                     * follower 与 leader 的 zxid 相同说明 二者数据一致；同步方式为差量同步 DIFF，同步的zxid 为 peerLastZxid， 也就是不需要同步\n                     */\n                    packetToSend = Leader.DIFF;\n                    zxidToSend = peerLastZxid;\n                } else if (proposals.size() != 0) {\n                    // peerLastZxid 介于 minCommittedLog ，maxCommittedLog 中间\n                    if ((maxCommittedLog >= peerLastZxid)\n                            && (minCommittedLog <= peerLastZxid)) {\n                        /**\n                         * 在遍历 proposals 时，用来记录上一个 proposal 的 zxid\n                         */\n                        long prevProposalZxid = minCommittedLog;\n\n                        boolean firstPacket=true;\n                        packetToSend = Leader.DIFF;\n                        zxidToSend = maxCommittedLog;\n\n                        for (Proposal propose: proposals) {\n                            // 跳过 follower 已经存在的提案\n                            if (propose.packet.getZxid() <= peerLastZxid) {\n                                prevProposalZxid = propose.packet.getZxid();\n                                continue;\n                            } else {\n                                if (firstPacket) {\n                                    firstPacket = false;\n                                    if (prevProposalZxid < peerLastZxid) {\n                                        /**\n                                         * 此时说明有部分 proposals 提案在 leader 节点上不存在，则需告诉 follower 丢弃这部分 proposals\n                                         * 也就是告诉 follower 先执行回滚 TRUNC ，需要回滚到 prevProposalZxid 处，也就是 follower 需要丢弃 prevProposalZxid ~ peerLastZxid 范围内的数据\n                                         * 剩余的 proposals 则通过 DIFF 进行同步\n                                         */\n                                        packetToSend = Leader.TRUNC;                                        \n                                        zxidToSend = prevProposalZxid;\n                                        updates = zxidToSend;\n                                    }\n                                }\n\n                                /**\n                                 * 将剩余待 DIFF 同步的提案放入到队列中，等待发送\n                                 */\n                                queuePacket(propose.packet);\n                                /**\n                                 * 每个提案后对应一个 COMMIT 报文\n                                 */\n                                QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),\n                                        null, null);\n                                queuePacket(qcommit);\n                            }\n                        }\n                    } else if (peerLastZxid > maxCommittedLog) {                    \n                        /**\n                         * follower 的 zxid 比 leader 大 ，则告诉 follower 执行 TRUNC 回滚\n                         */\n                        packetToSend = Leader.TRUNC;\n                        zxidToSend = maxCommittedLog;\n                        updates = zxidToSend;\n                    } else {\n                    }\n                } \n\n            } finally {\n                rl.unlock();\n            }\n\n             QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,\n                    ZxidUtils.makeZxid(newEpoch, 0), null, null);\n             if (getVersion() < 0x10000) {\n                oa.writeRecord(newLeaderQP, \"packet\");\n            } else {\n                 // 数据同步完成之后会发送 NEWLEADER 信息\n                queuedPackets.add(newLeaderQP);\n            }\n            bufferedOutput.flush();\n            //Need to set the zxidToSend to the latest zxid\n            if (packetToSend == Leader.SNAP) {\n                zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();\n            }\n            /**\n             * 发送数据同步方式信息，告诉 follower 按什么方式进行数据同步\n             */\n            oa.writeRecord(new QuorumPacket(packetToSend, zxidToSend, null, null), \"packet\");\n            bufferedOutput.flush();\n            \n            /* if we are not truncating or sending a diff just send a snapshot */\n            if (packetToSend == Leader.SNAP) {\n                /**\n                 * 如果是全量同步的话，则将 leader 本地数据序列化写入 follower 的输出流\n                 */\n                leader.zk.getZKDatabase().serializeSnapshot(oa);\n                oa.writeString(\"BenWasHere\", \"signature\");\n            }\n            bufferedOutput.flush();\n            \n            /**\n             * 开启个线程执行 packet 发送\n             */\n            sendPackets();\n            \n            /**\n             * 接收 follower ack 响应\n             */\n            qp = new QuorumPacket();\n            ia.readRecord(qp, \"packet\");\n\n            /**\n             * 阻塞等待过半的 follower ack\n             */\n            leader.waitForNewLeaderAck(getSid(), qp.getZxid(), getLearnerType());\n\n            /**\n             * leader 向 follower 发送 UPTODATE，告知其可对外提供服务\n             */\n            queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));\n\n            // 省略\n        } \n    }\n```\n\n从上述代码可以看出 **leader** 和 **follower** 在进行数据同步时会通过 **peerLastZxid** 与 **maxCommittedLog**， **minCommittedLog** 两个值比较最终决定数据同步方式。\n\n#### DIFF(差异化同步)\n\n* **follower** 的 **peerLastZxid** 等于 **leader** 的 **peerLastZxid**\n\n> 此时说明 **follower** 与 **leader** 数据一致，采用 **DIFF** 方式同步，也即是无需同步\n\n* **follower** 的 **peerLastZxid** 介于 **maxCommittedLog**， **minCommittedLog** 两者之间\n\n> 此时说明 **follower** 与 **leader** 数据存在差异，需对差异的部分进行同步；首先 **leader** 会向 **follower** 发送 **DIFF** 报文告知其同步方式，随后会发送差异的提案及提案提交报文\n\n交互流程如下：\n\n```\n    Leader                 Follower\n\n      |          DIFF         |  \n      | --------------------> |\n      |        PROPOSAL       |  \n      | --------------------> |  \n      |         COMMIT        |  \n      | --------------------> |\n      |        PROPOSAL       |  \n      | --------------------> |  \n      |         COMMIT        |  \n      | --------------------> |\n         \n```\n\n示例： 假设 **leader** 节点的提案缓存队列对应的 **zxid** 依次是：\n\n```\n 0x500000001, 0x500000002, 0x500000003, 0x500000004, 0x500000005\n```\n\n而 **follower** 节点的 **peerLastZxid** 为 **0x500000003**，则需要将 **0x500000004**， **0x500000005** 两个提案进行同步；那么数据包发送过程如下表：\n\n\n| 报文类型 | ZXID |\n|------|------------|\n| DIFF  | 0x500000005          |\n| PROPOSAL  | 0x500000004        |\n| COMMIT  | 0x500000004       |\n| PROPOSAL  | 0x500000005        |\n| COMMIT  | 0x500000005       |\n\n#### TRUNC+DIFF(先回滚再差异化同步)\n\n> 在上文 **DIFF** 差异化同步时会存在一个特殊场景就是 虽然 **follower** 的 **peerLastZxid** 介于 **maxCommittedLog**， **minCommittedLog** 两者之间，但是 **follower** 的 **peerLastZxid** 在 **leader** 节点中不存在； 此时 **leader** 需告知 **follower** 先回滚到 **peerLastZxid** 的前一个 **zxid**, 回滚后再进行差异化同步。\n\n交互流程如下：\n\n```\n    Leader                 Follower\n\n      |         TRUNC         |  \n      | --------------------> |\n      |        PROPOSAL       |  \n      | --------------------> |  \n      |         COMMIT        |  \n      | --------------------> |\n      |        PROPOSAL       |  \n      | --------------------> |  \n      |         COMMIT        |  \n      | --------------------> |\n         \n```\n\n示例： 假设集群中三台节点 A, B, C 某一时刻 A 为 Leader 选举周期为 5, zxid 包括： (0x500000004, 0x500000005, 0x500000006); 假设某一时刻 leader A 节点在处理完事务为 0x500000007 的请求进行广播时 leader A 节点服务器宕机导致 0x500000007 该事物没有被同步出去；在集群进行下一轮选举之后 B 节点成为新的 leader，选举周期为 6 对外提供服务处理了新的事务请求包括 0x600000001， 0x600000002；\n\n| 集群节点 | ZXID 列表|\n|------|------------|\n| A  | 0x500000004, 0x500000005, 0x500000006, 0x500000007  |\n| B  | 0x500000004, 0x500000005, 0x500000006, 0x600000001， 0x600000002  |\n| C  | 0x500000004, 0x500000005, 0x500000006, 0x600000001， 0x600000002  |\n\n此时节点 A 在重启加入集群后，在与 leader B 节点进行数据同步时会发现事务 0x500000007 在 leader 节点中并不存在，此时 leader 告知 A 需先回滚事务到 0x500000006，在差异同步事务 0x600000001，0x600000002；那么数据包发送过程如下表：\n\n| 报文类型 | ZXID |\n|------|------------|\n| TRUNC  | 0x500000006          |\n| PROPOSAL  | 0x600000001        |\n| COMMIT  | 0x600000001       |\n| PROPOSAL  | 0x600000002        |\n| COMMIT  | 0x600000002       |\n\n#### TRUNC(回滚同步)\n\n> 若 **follower** 的 **peerLastZxid** 大于 **leader** 的 **maxCommittedLog**，则告知 **follower** 回滚至 **maxCommittedLog**； 该场景可以认为是 **TRUNC+DIFF** 的简化模式\n\n交互流程如下：\n\n```\n    Leader                 Follower\n\n      |         TRUNC         |  \n      | --------------------> |\n         \n```\n\n#### SNAP(全量同步)\n\n> 若 **follower** 的 **peerLastZxid** 小于 **leader** 的 **minCommittedLog** 或者 **leader** 节点上不存在提案缓存队列时，将采用 **SNAP** 全量同步方式。 该模式下 **leader** 首先会向 **follower** 发送 **SNAP** 报文，随后从内存数据库中获取全量数据序列化传输给 **follower**， **follower** 在接收全量数据后会进行反序列化加载到内存数据库中。\n\n交互流程如下：\n\n```\n    Leader                 Follower\n\n      |         SNAP          |  \n      | --------------------> |\n      |         DATA          |  \n      | --------------------> |\n         \n```\n\n**leader** 在完成数据同步之后，会向 **follower** 发送 **NEWLEADER** 报文，在收到过半的 **follower** 响应的 **ACK** 之后此时说明过半的节点完成了数据同步，接下来 **leader** 会向 **follower** 发送 **UPTODATE** 报文告知 **follower** 节点可以对外提供服务了，此时 **leader** 会启动 zk server 开始对外提供服务。\n\n#### FOLLOWER 数据同步\n\n> 下面我们在看下数据同步阶段 **FOLLOWER** 是如何处理的，参考 **Learner.syncWithLeader**\n\n```java\nprotected void syncWithLeader(long newLeaderZxid) throws IOException, InterruptedException{\n        QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);\n        QuorumPacket qp = new QuorumPacket();\n        long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);\n\n        /**\n         * 接收 leader 发送的数据同步方式报文\n         */\n        readPacket(qp);\n        \n        synchronized (zk) {\n            if (qp.getType() == Leader.DIFF) {\n                \n            }\n            else if (qp.getType() == Leader.SNAP) {\n                // 执行加载全量数据\n            } else if (qp.getType() == Leader.TRUNC) {\n                // 执行回滚\n            }\n            else {\n            \n            }\n            \n            outerLoop:\n            while (self.isRunning()) {\n                readPacket(qp);\n                switch(qp.getType()) {\n                case Leader.PROPOSAL:\n                    // 处理提案\n                    break;\n                case Leader.COMMIT:\n                    // commit proposal\n                    break;\n                case Leader.INFORM:\n                    // 忽略\n                    break;\n                case Leader.UPTODATE:\n                    // 设置 zk server\n                    self.cnxnFactory.setZooKeeperServer(zk);\n                    // 退出循环                \n                    break outerLoop;\n                case Leader.NEWLEADER: // Getting NEWLEADER here instead of in discovery \n                    /**\n                     * follower 响应 NEWLEADER ACK\n                     */\n                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);\n                    break;\n                }\n            }\n        }\n        ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));\n        writePacket(ack, true);\n        // 启动 zk server\n        zk.startup();\n        \n    }\n```\n\n从上述代码中可以看出 **follower** 在数据同步阶段的处理流程如下：\n\n* **follower** 接收 **leader** 发送的数据同步方式（DIFF/TRUNC/SANP）报文并进行相应处理\n\n* 当 **follower** 收到 **leader** 发送的 **NEWLEADER** 报文后，会向 **leader** 响应 **ACK** (**leader** 在收到过半的 **ACK** 消息之后会发送 **UPTODATE**)\n\n* 当 **follower** 收到 **leader** 发送的 **UPTODATE** 报文后，说明此时可以对外提供服务，此时将启动 zk server\n\n\n## 小结\n\n最后用一张图总结下 zk 在完成选举后数据同步的过程如下图所示：\n \n![](https://i.loli.net/2019/06/21/5d0c7dc8de5f431581.png)\n","tags":["zookeeper"]},{"title":"zookeeper-选举源码分析","url":"/2019/04/20/zookeeper-选举源码分析/","content":"\n在 **zookeeper** 集群中发生选举的场景有以下三种：\n\n* 集群启动时\n* Leader 节点重启时\n* Follower 节点重启时\n\n本文主要针对集群启动时发生的选举实现进行分析。\n\n> ZK 集群中节点在启动时会调用**QuorumPeer.start**方法\n\n<!-- more -->\n\n```java\npublic synchronized void start() {\n    /**\n     * 加载数据文件，获取 lastProcessedZxid, currentEpoch，acceptedEpoch\n     */\n    loadDataBase();\n\n    /**\n     * 启动主线程 用于处理客户端连接请求\n     */\n    cnxnFactory.start();\n\n    /**\n     * 开始 leader 选举; 会相继创建选举算法的实现，创建当前节点与集群中其他节点选举通信的网络IO，并启动相应工作线程\n     */\n    startLeaderElection();\n\n    /**\n     * 启动 QuorumPeer 线程，监听当前节点服务状态\n     */\n    super.start();\n}\n```\n\n### 加载数据文件\n\n在 **loadDataBase** 方法中，ZK 会通过加载数据文件获取 **lastProcessedZxid** , 并通过读取 **currentEpoch** , **acceptedEpoch** 文件来获取相对应的值；若上述两文件不存在，则以 **lastProcessedZxid** 的高 32 位作为 **currentEpoch** , **acceptedEpoch** 值并写入对应文件中。\n\n### 初始选举环境\n\n```java\nsynchronized public void startLeaderElection() {\n\ttry {\n\t    // 创建投票\n\t\tcurrentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n\t} catch(IOException e) {\n\t}\n\t// 从集群中节点列表，查找当前节点与其他进行信息同步的地址\n    for (QuorumServer p : getView().values()) {\n        if (p.id == myid) {\n            myQuorumAddr = p.addr;\n            break;\n        }\n    }\n    if (myQuorumAddr == null) {\n        throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n    }\n    \n    // electionType == 3\n    this.electionAlg = createElectionAlgorithm(electionType);\n}\n```\n\n```java\nprotected Election createElectionAlgorithm(int electionAlgorithm){\n    Election le=null;\n            \n    //TODO: use a factory rather than a switch\n    switch (electionAlgorithm) {\n    \t// 忽略其他算法的实现\n    case 3:\n        /**\n         * 创建 QuorumCnxManager 实例，并启动 QuorumCnxManager.Listener 线程用于与集群中其他节点进行选举通信;\n         */\n        qcm = createCnxnManager();\n        QuorumCnxManager.Listener listener = qcm.listener;\n        if(listener != null){\n            listener.start();\n            /**\n             * 创建选举算法 FastLeaderElection 实例\n             */\n            le = new FastLeaderElection(this, qcm);\n        } else {\n            LOG.error(\"Null listener when initializing cnx manager\");\n        }\n        break;\n    default:\n        assert false;\n    }\n    return le;\n}\n```\n\n初始节点的相关实例之后，执行 **super.start()** 方法，因 **QuorumPeer** 类继承 **ZooKeeperThread** 故会启动 QuorumPeer 线程\n\n```java\npublic void run() {\n        // 代码省略\n        try {\n            /*\n             * Main loop\n             */\n            while (running) {\n                switch (getPeerState()) {\n                case LOOKING:\n                    LOG.info(\"LOOKING\");\n\n                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n                        // 只读模式下代码省略\n                    } else {\n                        try {\n                            setBCVote(null);\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        }\n                    }\n                    break;\n                // 忽略其他状态下的处理逻辑\n                }\n            }\n        } finally {\n            \n        }\n    }\n```\n\n### 选举\n\n从上述代码可以看出 **QuorumPeer** 线程在运行过程中轮询监听当前节点的状态并进行相应的逻辑处理，集群启动时节点状态为 **LOOKING** (也就是选举 Leader 过程)，此时会调用 **FastLeaderElection.lookForLeader** 方法 （也是投票选举算法的核心）简化后源码如下：\n\n```java\npublic Vote lookForLeader() throws InterruptedException {\n        // 忽略\n        try {\n            HashMap<Long, Vote> recvset = new HashMap<Long, Vote>();\n\n            HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();\n\n            int notTimeout = finalizeWait;\n\n            synchronized(this){\n                // logicalclock 逻辑时钟加一\n                logicalclock.incrementAndGet();\n                /**\n                 * 更新提案信息，用于后续投票；集群启动节点默认选举自身为 Leader\n                 */\n                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());\n            }\n\n            /**\n             * 发送选举投票提案\n             */\n            sendNotifications();\n\n            /*\n             * Loop in which we exchange notifications until we find a leader\n             */\n\n            while ((self.getPeerState() == ServerState.LOOKING) &&\n                    (!stop)){\n                /*\n                 * Remove next notification from queue, times out after 2 times\n                 * the termination time\n                 */\n            \t/**\n            \t * 从 recvqueue 队列中获取外部节点的选举投票信息\n            \t */\n                Notification n = recvqueue.poll(notTimeout,\n                        TimeUnit.MILLISECONDS);\n\n                /*\n                 * Sends more notifications if haven't received enough.\n                 * Otherwise processes new notification.\n                 */\n                if(n == null){\n                    /**\n                     * 检查上一次发送的选举投票信息是否全部发送；\n                     * 若已发送则重新在发送一遍，反之说明当前节点与集群中其他节点未连接，则执行 connectAll() 建立连接 \n                     */\n                    if(manager.haveDelivered()){\n                        sendNotifications();\n                    } else {\n                        manager.connectAll();\n                    }\n\n                    /*\n                     * Exponential backoff\n                     */\n                    int tmpTimeOut = notTimeout*2;\n                    notTimeout = (tmpTimeOut < maxNotificationInterval?\n                            tmpTimeOut : maxNotificationInterval);\n                    LOG.info(\"Notification time out: \" + notTimeout);\n                }\n                else if(self.getVotingView().containsKey(n.sid)) {\n                    /**\n                     * 只处理同一集群中节点的投票请求\n                     */ \n                    switch (n.state) {\n                    case LOOKING:\n                        // If notification > current, replace and send messages out\n                        if (n.electionEpoch > logicalclock.get()) {\n                            /**\n                             * 外部投票选举周期大于当前节点选举周期\n                             * \n                             * step1 : 更新选举周期值\n                             * step2 : 清空已收到的选举投票数据\n                             * step3 : 选举投票 PK，选举规则参见 totalOrderPredicate 方法\n                             * step4 : 变更选举投票并发送\n                             */\n                            logicalclock.set(n.electionEpoch);\n                            recvset.clear();\n                            if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,\n                                    getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {\n                                updateProposal(n.leader, n.zxid, n.peerEpoch);\n                            } else {\n                                updateProposal(getInitId(),\n                                        getInitLastLoggedZxid(),\n                                        getPeerEpoch());\n                            }\n                            sendNotifications();\n                        } else if (n.electionEpoch < logicalclock.get()) {\n                            // 丢弃小于当前选举周期的投票\n                            break;\n                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,\n                                proposedLeader, proposedZxid, proposedEpoch)) {\n                            /**\n                             * 同一选举周期\n                             *                            \n                             * step1 : 选举投票 PK，选举规则参见 totalOrderPredicate 方法\n                             * step2 : 变更选举投票并发送\n                             */\n                            updateProposal(n.leader, n.zxid, n.peerEpoch);\n                            sendNotifications();\n                        }\n\n                        /**\n                         * 记录外部选举投票信息\n                         */\n                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n\n                        /**\n                         * 统计选举投票结果，判断是否可以结束此轮选举\n                         */\n                        if (termPredicate(recvset,\n                                new Vote(proposedLeader, proposedZxid,\n                                        logicalclock.get(), proposedEpoch))) {\n\n                        \t// ......\n                            \n                            if (n == null) {\n                            \t/**\n                            \t * 选举结束判断当前节点状态; 若提案的 leader == myid 则 state = LEADING, 反之为 FOLLOWING \n                            \t */\n                                self.setPeerState((proposedLeader == self.getId()) ?\n                                        ServerState.LEADING: learningState());\n                                // 变更当前投票信息\n                                Vote endVote = new Vote(proposedLeader,\n                                                        proposedZxid,\n                                                        logicalclock.get(),\n                                                        proposedEpoch);\n                                leaveInstance(endVote);\n                                return endVote;\n                            }\n                        }\n                        break;\n                    case OBSERVING:\n                        LOG.debug(\"Notification from observer: \" + n.sid);\n                        break;\n                    case FOLLOWING:\n                    case LEADING:\n                        // ...... \n                        break;\n                    default:\n                        LOG.warn(\"Notification state unrecognized: {} (n.state), {} (n.sid)\",\n                                n.state, n.sid);\n                        break;\n                    }\n                } else {\n                    LOG.warn(\"Ignoring notification from non-cluster member \" + n.sid);\n                }\n            }\n            return null;\n        } finally {\n        \t// ......\n        }\n    }\n``` \n\n从 **lookForLeader** 方法的实现可以看出，选举流程如下：\n\n* 发送内部投票\n  \n\t> 内部投票发送逻辑参考后续小节  \n\n* 接收外部投票\n\n\t> 接收外部投票逻辑参考后续小节\n\n* 选举投票 PK\n\n\t> 当接收到外部节点投票信息后会与内部投票信息进行 PK 已确定投票优先权；PK 规则参见 **totalOrderPredicate** 方法如下\n\n```java\nprotected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) {\n    if(self.getQuorumVerifier().getWeight(newId) == 0){\n        return false;\n    }\n    \n    /*\n     * We return true if one of the following three cases hold:\n     * 1- New epoch is higher\n     * 2- New epoch is the same as current epoch, but new zxid is higher\n     * 3- New epoch is the same as current epoch, new zxid is the same\n     *  as current zxid, but server id is higher.\n     */\n    return ((newEpoch > curEpoch) || \n            ((newEpoch == curEpoch) &&\n            ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));\n}\n```\n\n从其实现可以看出选举投票 PK 规则如下：\n\n\t* 比较外部投票与内部投票的选举周期值，选举周期大的值优先\n\t* 若选举周期值一致，则比较事务 ID； 事务 ID 最新的优先\n\t* 若选举周期值一致且事务 ID 值相同，则比较投票节点的 server id; server id 最大的优先\n\n* 统计选举投票\n\n\t> 当接收到外部投票之后，都会统计下此轮选举的投票情况并判断是否可结束选举; 参考 **termPredicate** 方法\n\n```java\nprotected boolean termPredicate(\n            HashMap<Long, Vote> votes,\n            Vote vote) {\n\n    HashSet<Long> set = new HashSet<Long>();\n\n    /**\n     * 统计接收的投票中与当前节点所推举 leader 投票一致的个数\n     */\n    for (Map.Entry<Long,Vote> entry : votes.entrySet()) {\n        if (vote.equals(entry.getValue())){\n            set.add(entry.getKey());\n        }\n    }\n\n    /**\n     * 如果超过一半的投票一致 则说明可以终止本次选举\n     */\n    return self.getQuorumVerifier().containsQuorum(set);\n}\n```\n\n* 确认节点角色\n\n\t> 当此轮选举结束之后，通过判断所推举的 leader server id 是否与当前节点 server id 相等； 若相等则说明当前节点为 leader, 反之为 follower。\n\n### 发送接收投票\n\n> 上文中主要聊了下 ZK 选举算法的核心部分，下面接着看下集群节点在选举过程中是如何发送自己的投票和接收外部的投票及相关处理逻辑。\n\n首先通过 **FastLeaderElection.sendNotifications** 方法看下发送投票逻辑：\n\n```java\nprivate void sendNotifications() {\n    for (QuorumServer server : self.getVotingView().values()) {\n        long sid = server.id;\n\n        /**\n         * 发送投票通知信息\n         *\n         * leader : 被推举的服务器 myid\n         * zxid : 被推举的服务器 zxid\n         * electionEpoch : 当前节点选举周期\n         * ServerState state : 当前节点状态\n         * sid : 消息接收方 myid\n         * peerEpoch : 被推举的服务器 epoch\n         */\n        ToSend notmsg = new ToSend(ToSend.mType.notification,\n                proposedLeader,\n                proposedZxid,\n                logicalclock.get(),\n                QuorumPeer.ServerState.LOOKING,\n                sid,\n                proposedEpoch);\n\n        /**\n         * 将消息添加到队列 sendqueue 中;\n         *\n         * @see Messenger.WorkerSender sendqueue 队列会被 WorkerSender 消费\n         */\n        sendqueue.offer(notmsg);\n    }\n}\n```\n\n从实现可以看出节点在启动阶段会将自身信息封装为 **ToSend** 实例（也就是选举自身为 leader）并添加到队列 **FastLeaderElection.sendqueue** 中；那么此时我们会问到 **FastLeaderElection.sendqueue** 队列中的消息被谁消费处理呢 ？ 让我们回过头看下节点在启动初始化选举环境时创建 **QuorumCnxManager**, **FastLeaderElection** 实例的过程。\n\n> PS : FastLeaderElection.sendqueue 队列中消息被谁消费 ？\n\n#### QuorumCnxManager\n\n```java\npublic QuorumCnxManager(final long mySid,\n                            Map<Long,QuorumPeer.QuorumServer> view,\n                            QuorumAuthServer authServer,\n                            QuorumAuthLearner authLearner,\n                            int socketTimeout,\n                            boolean listenOnAllIPs,\n                            int quorumCnxnThreadsSize,\n                            boolean quorumSaslAuthEnabled,\n                            ConcurrentHashMap<Long, SendWorker> senderWorkerMap) {\n    this.senderWorkerMap = senderWorkerMap;\n    this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);\n    this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();\n\n    this.lastMessageSent = new ConcurrentHashMap<Long, ByteBuffer>();\n    String cnxToValue = System.getProperty(\"zookeeper.cnxTimeout\");\n    if(cnxToValue != null){\n        this.cnxTO = Integer.parseInt(cnxToValue);\n    }\n\n    this.mySid = mySid;\n    this.socketTimeout = socketTimeout;\n    this.view = view;\n    this.listenOnAllIPs = listenOnAllIPs;\n\n    initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,\n            quorumSaslAuthEnabled);\n\n    listener = new Listener();\n}\n```\n\n在 **QuorumCnxManager** 实例化后，会启动一个 **QuorumCnxManager.Listener** 线程；同时在 **QuorumCnxManager** 实例中存在三个重要的集合容器变量：\n\n* **senderWorkerMap** : 发送器集合，Map 类型按 server id 分组；为集群中的每个节点分配一个 SendWorker 负责消息的发送\n* **recvQueue** ： 消息接收队列，用于存放从外部节点接收到的投票消息\n* **queueSendMap** ： 消息发送队列，Map 类型按 server id 分组；为集群中的每个节点分配一个阻塞队列存放待发送的消息，从而保证各个节点之间的消息发送互不影响\n\n下面我们再看下 **QuorumCnxManager.Listener** 线程启动后，主要做了什么:\n\n```java\npublic void run() {\n    int numRetries = 0;\n    InetSocketAddress addr;\n    while((!shutdown) && (numRetries < 3)){\n        try {\n            ss = new ServerSocket();\n            ss.setReuseAddress(true);\n\n            /**\n             * 获取当前节点的选举地址并 bind 监听等待外部节点连接\n             */\n            addr = view.get(QuorumCnxManager.this.mySid).electionAddr;\n            ss.bind(addr);\n\n            while (!shutdown) {\n\n            \t/**\n            \t * 接收外部节点连接并处理\n            \t */\n                Socket client = ss.accept();\n                setSockOpts(client);                \n\t\t\t\treceiveConnection(client);\n\n                numRetries = 0;\n            }\n        } catch (IOException e) {\n            LOG.error(\"Exception while listening\", e);\n            numRetries++;\n            ss.close();\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n跟踪代码发现 **receiveConnection** 方法最终会调用方法 **handleConnection** 如下\n\n```java\nprivate void handleConnection(Socket sock, DataInputStream din)\n            throws IOException {\n    /**\n     * 读取外部节点的 server id \n     * ps : 此时的 server id 是什么时候发送的呢 ？\n     */\n    Long sid = din.readLong();\n  \n    if (sid < this.mySid) {\n        /**\n         * 若外部节点的 server id 小于当前节点的 server id，则关闭此连接，改为由当前节点发起连接\n         * ps ： 该限制说明选举过程中，zk 只允许 server id 较大的一方去主动发起连接避免重复连接\n         */\n        SendWorker sw = senderWorkerMap.get(sid);\n        if (sw != null) {\n            sw.finish();\n        }\n\n        closeSocket(sock);\n        connectOne(sid);\n    } else {\n        SendWorker sw = new SendWorker(sock, sid);\n        RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n        sw.setRecv(rw);\n\n        SendWorker vsw = senderWorkerMap.get(sid);\n        \n        if(vsw != null)\n            vsw.finish();\n        \n        /**\n         * 按 server id 分组，为外部节点分配 SendWorker, RecvWorker 和一个消息发送队列\n         */\n        senderWorkerMap.put(sid, sw);\n        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));\n        \n        /**\n         * 启动外部节点对应的 SendWorker， RecvWorker 线程\n         */\n        sw.start();\n        rw.start();\n        \n        return;\n    }\n}\n```\n\n至此会发现 **QuorumCnxManager.Listener** 线程处理逻辑如下：\n\n* 监听当前节点的 election address 等待接收外部节点连接\n* 读取外部节点的 server id 并与当前节点的 server id 比较；若前者小则关闭连接，改由当前节点发起连接\n* 反之为外部节点分配 SendWorker，RecvWorker 线程及消息发送队列\n\n> PS ： 此处我们会有个疑问外部节点的 server id 是什么时候发送过来的呢 ？\n\n下面我们在看下为每个外部节点开启了 **SendWorker**， **RecvWorker** 线程后做了什么：\n\n* SendWorker\n\n```java\npublic void run() {\n    // 省略\n    try {\n        while (running && !shutdown && sock != null) {\n\n            ByteBuffer b = null;\n            try {\n                /**\n                 * 通过 server id 获取待发送给集群中节点的消息队列\n                 */\n                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap\n                        .get(sid);\n                if (bq != null) {\n                    /**\n                     * 从队列中获取待发送的消息\n                     */\n                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);\n                } else {\n                    LOG.error(\"No queue of incoming messages for \" +\n                              \"server \" + sid);\n                    break;\n                }\n\n                if(b != null){\n                    lastMessageSent.put(sid, b);\n                    /**\n                     * 写入 socket 的输出流完成消息的发送\n                     */\n                    send(b);\n                }\n            } catch (InterruptedException e) {               \n            }\n        }\n    } catch (Exception e) {        \n    }\n}\n\nsynchronized void send(ByteBuffer b) throws IOException {\n    byte[] msgBytes = new byte[b.capacity()];\n    try {\n        b.position(0);\n        b.get(msgBytes);\n    } catch (BufferUnderflowException be) {\n        LOG.error(\"BufferUnderflowException \", be);\n        return;\n    }\n    /**\n     * 发送的报文包括：消息体正文长度和消息体正文\n     */\n    dout.writeInt(b.capacity());\n    dout.write(b.array());\n    dout.flush();\n}\n```\n\n通过代码实现我们知道 **SendWorker** 的职责就是从 **queueSendMap** 队列中获取待发送给远程节点的消息并执行发送。\n\n> PS : 此处我们会有个疑问 **QuorumCnxManager.queueSendMap** 中节点对应队列中待发送的消息是谁生产的呢 ？\n\n* RecvWorker\n\n```java\npublic void run() {\n    threadCnt.incrementAndGet();\n    try {\n        while (running && !shutdown && sock != null) {\n            /**\n             * 读取外部节点发送的消息\n             * 由 SendWorker 可知前 4 字节为消息载体有效长度\n             */\n            int length = din.readInt();\n            if (length <= 0 || length > PACKETMAXSIZE) {\n                throw new IOException(\n                        \"Received packet with invalid packet: \"\n                                + length);\n            }\n            /**\n             * 读取消息体正文\n             */\n            byte[] msgArray = new byte[length];\n            din.readFully(msgArray, 0, length);\n            ByteBuffer message = ByteBuffer.wrap(msgArray);\n            /**\n             * 将读取的消息包装为 Message 对象添加到队列 recvQueue 中\n             */\n            addToRecvQueue(new Message(message.duplicate(), sid));\n        }\n    } catch (Exception e) {\n        LOG.warn(\"Connection broken for id \" + sid + \", my id = \"\n                 + QuorumCnxManager.this.mySid + \", error = \" , e);\n    } finally {\n        LOG.warn(\"Interrupting SendWorker\");\n        sw.finish();\n        if (sock != null) {\n            closeSocket(sock);\n        }\n    }\n}\n\npublic void addToRecvQueue(Message msg) {\n    synchronized(recvQLock) {\n        // 省略\n        try {\n            recvQueue.add(msg);\n        } catch (IllegalStateException ie) {\n            // This should never happen\n            LOG.error(\"Unable to insert element in the recvQueue \" + ie);\n        }\n    }\n}\n```\n\n从上面可以看出 **RecvWorker** 线程在运行期间会接收 server id 对应的外部节点发送的消息，并将其放入 **QuorumCnxManager.recvQueue** 队列中。\n到目前为止我们基本完成对 **QuorumCnxManager** 核心功能的分析，发现其功能主要是负责集群中当前节点与外部节点进行选举通讯的网络 IO 操作，譬如接收外部节点选举投票和向外部节点发送内部投票。\n\n#### FastLeaderElection\n\n下面我们在接着回头看下 **FastLeaderElection** 类实例的过程： \n\n```java\npublic FastLeaderElection(QuorumPeer self, QuorumCnxManager manager){\n    this.stop = false;\n    this.manager = manager;\n    starter(self, manager);\n}\n\nprivate void starter(QuorumPeer self, QuorumCnxManager manager) {\n    this.self = self;\n    proposedLeader = -1;\n    proposedZxid = -1;\n\n    sendqueue = new LinkedBlockingQueue<ToSend>();\n    recvqueue = new LinkedBlockingQueue<Notification>();\n    this.messenger = new Messenger(manager);\n}\n```\n```java\nMessenger(QuorumCnxManager manager) {\n\t/**\n\t * 启动 WorkerSender 线程用于发送消息\n\t */\n    this.ws = new WorkerSender(manager);\n\n    Thread t = new Thread(this.ws,\n            \"WorkerSender[myid=\" + self.getId() + \"]\");\n    t.setDaemon(true);\n    t.start();\n\n    /**\n     * 启动 WorkerReceiver 线程用于接收消息\n     */\n    this.wr = new WorkerReceiver(manager);\n\n    t = new Thread(this.wr,\n            \"WorkerReceiver[myid=\" + self.getId() + \"]\");\n    t.setDaemon(true);\n    t.start();\n}\n```\n\n从 **FastLeaderElection** 实例化过程我们知道，其内部分别启动了线程 **WorkerSender**，**WorkerReceiver** ；那么接下来看下这两个线程具体做什么吧。\n\n##### WorkerSender\n\n```java\npublic void run() {\n    while (!stop) {\n        try {\n            /**\n             * 从 sendqueue 队列中获取 ToSend 待发送的消息\n             */ \n            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);\n            if(m == null) continue;\n\n            process(m);\n        } catch (InterruptedException e) {\n            break;\n        }\n    }\n    LOG.info(\"WorkerSender is down\");\n}\n\nvoid process(ToSend m) {\n    // 将 ToSend 转换为 40字节 ByteBuffer\n    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), \n                                            m.leader,\n                                            m.zxid, \n                                            m.electionEpoch, \n                                            m.peerEpoch);\n    // 交由 QuorumCnxManager 执行发送\n    manager.toSend(m.sid, requestBuffer);\n}\n```\n\n看了 **WorkerSender** 的实现是不是明白了什么？ 还记得上文中 **FastLeaderElection.sendNotifications** 方法执行发送通知的时候的疑惑吗 ？ **FastLeaderElection.sendqueue** 队列产生的消息就是被 **WorkerSender** 线程所消费处理, **WorkerSender** 会将消息转发至 **QuorumCnxManager** 处理\n\n```java\npublic void toSend(Long sid, ByteBuffer b) {\n    /*\n     * If sending message to myself, then simply enqueue it (loopback).\n     * 如果是发给自己的投票，则将其添加到接收队列中等待处理\n     */\n    if (this.mySid == sid) {\n         b.position(0);\n         addToRecvQueue(new Message(b.duplicate(), sid));\n        /*\n         * Otherwise send to the corresponding thread to send.\n         */\n    } else {\n         /*\n          * Start a new connection if doesn't have one already.\n          */\n         ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY);\n         ArrayBlockingQueue<ByteBuffer> bqExisting = queueSendMap.putIfAbsent(sid, bq);\n\n         // 将发送的消息放入对应的队列中，若队列满了则将队列头部元素移除\n         if (bqExisting != null) {\n             addToSendQueue(bqExisting, b);\n         } else {\n             addToSendQueue(bq, b);\n         }\n         connectOne(sid);\n            \n    }\n}\n\nprivate void addToSendQueue(ArrayBlockingQueue<ByteBuffer> queue,\n          ByteBuffer buffer) {\n    // 省略\n    try {\n    \t// 将消息插入节点对应的队列中\n        queue.add(buffer);\n    } catch (IllegalStateException ie) {\n    }\n}\n```\n\n**QuorumCnxManager** 在收到 **FastLeaderElection.WorkerSender** 转发的消息时，会判断当前消息是否发给自己的投票，若是则将消息添加到接收队列中，反之会将消息添加到 **queueSendMap** 对应 server id 的队列中；看到这里的时候是不是就明白了在 **QuorumCnxManager.SendWorker** 分析时候的疑惑呢 。 这个时候投票消息未必能够发送出去，因为当前节点与外部节点的通道是否已建立还未知，所以继续执行 **connectOne**\n\n```java\nsynchronized public void connectOne(long sid){\n\t/**\n\t * 判断当前服务节点是否与 sid 外部服务节点建立连接;有可能对方先发起连接\n\t * 若已连接则等待后续处理，反之发起连接\n\t */\n\tif (!connectedToPeer(sid)){\n\t    InetSocketAddress electionAddr;\n\t    if (view.containsKey(sid)) {\n\t        electionAddr = view.get(sid).electionAddr;\n\t    } else {\n\t        LOG.warn(\"Invalid server id: \" + sid);\n\t        return;\n\t    }\n\t    try {\n\n\t        LOG.debug(\"Opening channel to server \" + sid);\n\t        Socket sock = new Socket();\n\t        setSockOpts(sock);\n\t        sock.connect(view.get(sid).electionAddr, cnxTO);\n\t        LOG.debug(\"Connected to server \" + sid);\n\n\t        initiateConnection(sock, sid);\n\n\t    } catch (UnresolvedAddressException e) {\n\t       \n\t    } catch (IOException e) {\n\t       \n\t    }\n\t} else {\n\t    LOG.debug(\"There is a connection already for server \" + sid);\n\t}\n}\n\npublic boolean connectedToPeer(long peerSid) {\n    return senderWorkerMap.get(peerSid) != null;\n}\n```\n```java\nprivate boolean startConnection(Socket sock, Long sid)\n            throws IOException {\n    DataOutputStream dout = null;\n    DataInputStream din = null;\n    try {\n        /**\n         * 发送当前节点的 server id，需告知对方我是哪台节点\n         */\n        dout = new DataOutputStream(sock.getOutputStream());\n        dout.writeLong(this.mySid);\n        dout.flush();\n\n        din = new DataInputStream(\n                new BufferedInputStream(sock.getInputStream()));\n    } catch (IOException e) {\n        LOG.warn(\"Ignoring exception reading or writing challenge: \", e);\n        closeSocket(sock);\n        return false;\n    }\n\n    // 只允许 sid 值大的服务器去主动和其他服务器连接，否则断开连接\n    if (sid > this.mySid) {\n        LOG.info(\"Have smaller server identifier, so dropping the \" +\n                 \"connection: (\" + sid + \", \" + this.mySid + \")\");\n        closeSocket(sock);\n        // Otherwise proceed with the connection\n    } else {\n        SendWorker sw = new SendWorker(sock, sid);\n        RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n        sw.setRecv(rw);\n\n        SendWorker vsw = senderWorkerMap.get(sid);\n        \n        if(vsw != null)\n            vsw.finish();\n        \n        senderWorkerMap.put(sid, sw);\n        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));\n        \n        sw.start();\n        rw.start();\n        \n        return true;    \n        \n    }\n    return false;\n}\n```\n\n从上述代码可以看出节点在与外部节点连接后会先发送 **myid** 报文告知对方我是哪个节点（这也是为什么 **QuorumCnxManager.Listener** 线程在接收到一个连接请求时会先执行 **getLong** 获取 server id 了）；同样在连接建立的时候也遵循一个原则（**只允许 server id 较大的一方发起连接**）。\n\n##### WorkerReceiver\n\n```java\npublic void run() {\n\n    Message response;\n    while (!stop) {\n        // Sleeps on receive\n        try{\n        \t/**\n        \t * 从 QuorumCnxManager.recvQueue 队列中获取接收的外部投票\n        \t */\n            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n            if(response == null) continue;\n          \n            if(!self.getVotingView().containsKey(response.sid)){\n                // 忽略对方是观察者的处理\n            } else {\n                // Instantiate Notification and set its attributes\n                Notification n = new Notification();\n                \n               \t// 将 message 转成 notification 对象\n\n                if(self.getPeerState() == QuorumPeer.ServerState.LOOKING){\n                \t// 当前节点状态为 looking，则将外部节点投票添加到 recvqueue 队列中\n                    recvqueue.offer(n);\n\n                    if((ackstate == QuorumPeer.ServerState.LOOKING)\n                            && (n.electionEpoch < logicalclock.get())){\n                    \t// 若外部节点选举周期小于当前节点选举周期则发送内部投票\n                        Vote v = getVote();\n                        ToSend notmsg = new ToSend(ToSend.mType.notification,\n                                v.getId(),\n                                v.getZxid(),\n                                logicalclock.get(),\n                                self.getPeerState(),\n                                response.sid,\n                                v.getPeerEpoch());\n                        sendqueue.offer(notmsg);\n                    }\n                } else {\n                    // 忽略其他状态时的处理\n                }\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n    LOG.info(\"WorkerReceiver is down\");\n}\n```\n\n此时我们明白 **WorkerReceiver** 线程在运行期间会一直从 **QuorumCnxManager.recvQueue** 的队列中拉取接收到的外部投票信息，若当前节点为 **LOOKING** 状态，则将外部投票信息添加到 **FastLeaderElection.recvqueue** 队列中，等待 **FastLeaderElection.lookForLeader** 选举算法处理投票信息。\n\n> 到此我们基本明白了 **ZK** 集群节点发送和接收投票的处理流程，但是这个时候您是不是又有一种懵的状态呢 笑哭，我们会发现选举过程中依赖了多个线程 **WorkerSender**, **SendWorker**, **WorkerReceiver**, **RecvWorker** ，多个阻塞队列 **sendqueue**, **recvqueue**,**queueSendMap**,**recvQueue** 而且名字起的很类似，更让人懵 ； 不过莫慌，我们来通过下面的图来缕下思路\n\n![](https://i.loli.net/2019/06/21/5d0c7dcbe312329084.png)\n\n## 小结\n\n看了这么长时间的代码，也够累的；最后我们就来个小结吧 ：\n\n* QuorumCnxManager 类主要职能是负责集群中节点与外部节点进行通信及投票信息的中转\n\n* FastLeaderElection 类是选举投票的核心实现\n\n* 选举投票规则\n\n\t* 比较外部投票与内部投票的选举周期值，选举周期大的值优先\n\t* 若选举周期值一致，则比较事务 ID； 事务 ID 最新的优先\n\t* 若选举周期值一致且事务 ID 值相同，则比较投票节点的 server id; server id 最大的优先\n\n* 集群中节点通信时为了避免重复建立连接，遵守一个原则：连接总是由 server id 较大的一方发起\n","tags":["zookeeper"]},{"title":"重拾-Mybatis-Mapper文件解析","url":"/2019/03/15/重拾-Mybatis-Mapper文件解析/","content":"\n## 前言\n\n## 配置示例\n\n* 使用相对于类路径的资源引用\n\n```xml\n<mappers>\n  <mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/>\n  <mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/>\n  <mapper resource=\"org/mybatis/builder/PostMapper.xml\"/>\n</mappers>\n```\n\n* 使用完全限定资源定位符（URL）\n\n```xml\n<mappers>\n  <mapper url=\"file:///var/mappers/AuthorMapper.xml\"/>\n  <mapper url=\"file:///var/mappers/BlogMapper.xml\"/>\n  <mapper url=\"file:///var/mappers/PostMapper.xml\"/>\n</mappers>\n```\n\n* 使用映射器接口实现类的完全限定类名\n\n```xml\n<mappers>\n  <mapper class=\"org.mybatis.builder.AuthorMapper\"/>\n  <mapper class=\"org.mybatis.builder.BlogMapper\"/>\n  <mapper class=\"org.mybatis.builder.PostMapper\"/>\n</mappers>\n```\n\n* 将包内的映射器接口实现全部注册为映射器 \n\n```xml\n<mappers>\n  <package name=\"org.mybatis.builder\"/>\n</mappers>\n```\n\n<!-- more -->\n\n## mapper 文件解析\n\n```java\nprivate void mapperElement(XNode parent) throws Exception {\n    if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n        if (\"package\".equals(child.getName())) {\n        \t// 将包内的映射器接口实现全部注册为映射器 \n          String mapperPackage = child.getStringAttribute(\"name\");\n          configuration.addMappers(mapperPackage);\n        } else {\n          String resource = child.getStringAttribute(\"resource\");\n          String url = child.getStringAttribute(\"url\");\n          String mapperClass = child.getStringAttribute(\"class\");\n          if (resource != null && url == null && mapperClass == null) {\n            ErrorContext.instance().resource(resource);\n            // 使用相对于类路径的资源引用\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url != null && mapperClass == null) {\n            ErrorContext.instance().resource(url);\n            // 使用完全限定资源定位符（URL）\n            InputStream inputStream = Resources.getUrlAsStream(url);\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url == null && mapperClass != null) {\n          \t// 使用映射器接口实现类的完全限定类名\n            Class<?> mapperInterface = Resources.classForName(mapperClass);\n            configuration.addMapper(mapperInterface);\n          } else {\n            throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n          }\n        }\n      }\n    }\n  }\n```\n\n### 按 XML 映射文件解析\n\n`XMLMapperBuilder` 的 `parse` 方法执行 mapper 接口映射文件的解析\n\n```java\npublic void parse() {\n    // 判断 resource 文件是否加载过\n    if (!configuration.isResourceLoaded(resource)) {\n      // 解析 mapper 文件\n      configurationElement(parser.evalNode(\"/mapper\"));\n      // 将 resource 文件标记为已加载\n      configuration.addLoadedResource(resource);\n      bindMapperForNamespace();\n    }\n\n    parsePendingResultMaps();\n    parsePendingCacheRefs();\n    parsePendingStatements();\n  }\n```\n\n```java\nprivate void configurationElement(XNode context) {\n    try {\n      // 获取 mapper 的命名空间\n      String namespace = context.getStringAttribute(\"namespace\");\n      if (namespace == null || namespace.equals(\"\")) {\n        throw new BuilderException(\"Mapper's namespace cannot be empty\");\n      }\n      builderAssistant.setCurrentNamespace(namespace);\n      // 解析 cache-ref\n      // 从 configuration 中通过参照的缓存的命名空间获取缓存并复制到当前 mapper\n      cacheRefElement(context.evalNode(\"cache-ref\"));\n      // 解析 cache\n      // 创建 cache 实例并注册到 configuration 的 caches 容器中\n      cacheElement(context.evalNode(\"cache\"));\n      parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n      // 解析 resultMap 标签\n      resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n      sqlElement(context.evalNodes(\"/mapper/sql\"));\n      // 解析 sql 语句标签\n      buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing Mapper XML. The XML location is '\" + resource + \"'. Cause: \" + e, e);\n    }\n  }\n```\n\n#### cache-ref 解析\n\n> 通过配置 `cache-ref` 引用其他命名空间的缓存配置实例 \n\n```java\nprivate void cacheRefElement(XNode context) {\n    if (context != null) {\n      // 将当前 mapper 命名空间和参照缓存的命名空间进行绑定, 注册到 configuration 的 cacheRefMap\n      configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(\"namespace\"));\n      CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute(\"namespace\"));\n      try {\n        // 获取参照缓存 并绑定到当前 mapper\n        cacheRefResolver.resolveCacheRef();\n      } catch (IncompleteElementException e) {\n        configuration.addIncompleteCacheRef(cacheRefResolver);\n      }\n    }\n  }\n```\n\n`Configuration` 的 `addCacheRef` 方法如下：\n\n```java\npublic void addCacheRef(String namespace, String referencedNamespace) {\n    cacheRefMap.put(namespace, referencedNamespace);\n  }\n```\n\n> 从上述代码发现，解析 `cache-ref` 标签之后会将当前命名空间和缓存参照的命名空间进行绑定注册到 `cacheRefMap` 容器中。 \n\n```java\npublic Cache resolveCacheRef() {\n    // 从参照的命名空间获取 cache 并复制到当前 mapper\n    return assistant.useCacheRef(cacheRefNamespace);\n  }\n```\n\n```java\npublic Cache useCacheRef(String namespace) {\n    if (namespace == null) {\n      throw new BuilderException(\"cache-ref element requires a namespace attribute.\");\n    }\n    try {\n      unresolvedCacheRef = true;\n      // 获取参照的缓存实例\n      Cache cache = configuration.getCache(namespace);\n      if (cache == null) {\n      \t// 若参照的缓存实例不存在则抛出异常\n        throw new IncompleteElementException(\"No cache for namespace '\" + namespace + \"' could be found.\");\n      }\n      // 将参照的缓存复制到当前缓存实例\n      currentCache = cache;\n      unresolvedCacheRef = false;\n      return cache;\n    } catch (IllegalArgumentException e) {\n      throw new IncompleteElementException(\"No cache for namespace '\" + namespace + \"' could be found.\", e);\n    }\n  }\n```\n\n从 `resolveCacheRef` 的操作来看，在解析参照缓存的命名空间之后，会从 `configuration` 的 `caches` 缓存容器中获取参照缓存实例，若存在参照缓存则将其复制到当前命名空间下，反之抛出异常。\n\n#### cache 解析\n\n```java\nprivate void cacheElement(XNode context) {\n    if (context != null) {\n      // 获取缓存的实现类，默认为 PERPETUAL，也就是 PerpetualCache 类\n      String type = context.getStringAttribute(\"type\", \"PERPETUAL\");\n      Class<? extends Cache> typeClass = typeAliasRegistry.resolveAlias(type);\n\n      // 获取缓存的回收策略，默认为 LRU 策略，也就是 LruCache\n      String eviction = context.getStringAttribute(\"eviction\", \"LRU\");\n      Class<? extends Cache> evictionClass = typeAliasRegistry.resolveAlias(eviction);\n      // 获取缓存刷新时间间隔\n      Long flushInterval = context.getLongAttribute(\"flushInterval\");\n      Integer size = context.getIntAttribute(\"size\");\n      boolean readWrite = !context.getBooleanAttribute(\"readOnly\", false);\n      boolean blocking = context.getBooleanAttribute(\"blocking\", false);\n      Properties props = context.getChildrenAsProperties();\n      // 创建缓存对象\n      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);\n    }\n  }\n```\n\n```java\npublic Cache useNewCache(Class<? extends Cache> typeClass,\n      Class<? extends Cache> evictionClass,\n      Long flushInterval,\n      Integer size,\n      boolean readWrite,\n      boolean blocking,\n      Properties props) {\n    // 设置缓存命名空间,也就是 cache 的 id\n    // 设置缓存的实现类, 默认为 PerpetualCache\n    // 设置缓存的回收策略，默认为 LruCache\n    Cache cache = new CacheBuilder(currentNamespace)\n        .implementation(valueOrDefault(typeClass, PerpetualCache.class))\n        .addDecorator(valueOrDefault(evictionClass, LruCache.class))\n        .clearInterval(flushInterval)\n        .size(size)\n        .readWrite(readWrite)\n        .blocking(blocking)\n        .properties(props)\n        .build();\n    // 将 cache 添加到\n    configuration.addCache(cache);\n    currentCache = cache;\n    return cache;\n  }\n```\n\n解析 `cache` 的流程很简单，其过程如下：\n\n* 获取缓存的实现类 `type` 属性，默认为 `PerpetualCache`\n* 获取缓存的回收策略 `eviction` 属性， 默认为 `LRU` 策略\n* 获取缓存刷新时间，size 等熟悉\n* 通过 `builderAssistant` (mapper 构造助手) 创建 cache 实例\n* 将 cache 实例注册到 `configuration` 的 `caches` 容器中\n\n#### resultMap 解析\n\n```java\n  private ResultMap resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType) throws Exception {\n    ErrorContext.instance().activity(\"processing \" + resultMapNode.getValueBasedIdentifier());\n    // 获取映射的类\n    String type = resultMapNode.getStringAttribute(\"type\",\n        resultMapNode.getStringAttribute(\"ofType\",\n            resultMapNode.getStringAttribute(\"resultType\",\n                resultMapNode.getStringAttribute(\"javaType\"))));\n    Class<?> typeClass = resolveClass(type);\n    if (typeClass == null) {\n      typeClass = inheritEnclosingType(resultMapNode, enclosingType);\n    }\n    Discriminator discriminator = null;\n    List<ResultMapping> resultMappings = new ArrayList<>();\n    // 遍历 resultMap 标签下的子标签 常用的为 id, result 标签\n    resultMappings.addAll(additionalResultMappings);\n    List<XNode> resultChildren = resultMapNode.getChildren();\n    for (XNode resultChild : resultChildren) {\n      if (\"constructor\".equals(resultChild.getName())) {\n        processConstructorElement(resultChild, typeClass, resultMappings);\n      } else if (\"discriminator\".equals(resultChild.getName())) {\n        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);\n      } else {\n        List<ResultFlag> flags = new ArrayList<>();\n        if (\"id\".equals(resultChild.getName())) {\n          flags.add(ResultFlag.ID);\n        }\n        // ResultMapping 存储的是 标签 result 的内容 包括java bean 属性与 db 列的映射关系\n        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));\n      }\n    }\n    // 获取 resultMap 的 id\n    String id = resultMapNode.getStringAttribute(\"id\",\n            resultMapNode.getValueBasedIdentifier());\n    String extend = resultMapNode.getStringAttribute(\"extends\");\n    Boolean autoMapping = resultMapNode.getBooleanAttribute(\"autoMapping\");\n\n    // ResultMap 存储的是 标签 resultMap 的内容\n    // 其包括了 ResultMapping 集合，二者一对多的关系\n    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);\n    try {\n      return resultMapResolver.resolve();\n    } catch (IncompleteElementException  e) {\n      configuration.addIncompleteResultMap(resultMapResolver);\n      throw e;\n    }\n  }\n```\n\n\n\n\n### 按 mapper 接口解析\n\n","tags":["Mybatis"]},{"title":"重拾-MyBatis-配置文件解析","url":"/2019/03/14/重拾-Mybatis-配置文件解析/","content":"\n## 前言\n\n我们知道在使用 `Mybatis` 时，我们需要通过 `SqlSessionFactoryBuild` 去创建 `SqlSessionFactory` 实例，譬如：\n\n```java\n// resource 为 mybatis 的配置文件 \nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\n<!-- more -->\n\n那么我们看下 `build` 方法的具体实现\n\n```java\npublic SqlSessionFactory build(Reader reader, String environment, Properties properties) {\n\ttry {\n\t\t// 创建 XMLConfigBuilder 实例并执行解析\n\t  XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);\n\t  return build(parser.parse());\n\t} catch (Exception e) {\n\t  throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n\t} finally {\n\t  ErrorContext.instance().reset();\n\t  try {\n\t    reader.close();\n\t  } catch (IOException e) {\n\n\t  }\n\t}\n}\n\npublic Configuration parse() {\n\tif (parsed) {\n\t  throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n\t}\n\tparsed = true;\n\tparseConfiguration(parser.evalNode(\"/configuration\"));\n\treturn configuration;\n}\n```\n\n`Mybatis` 主要通过 `XMLConfigBuilder` 执行对配置文件的解析，具体实现如下文：\n\n## 配置文件解析\n\n```java\nprivate void parseConfiguration(XNode root) {\n\ttry {\n\t  //issue #117 read properties first\n\t  // 解析 properties 标签\n\t  propertiesElement(root.evalNode(\"properties\"));\n\t  // 解析 settings 标签\n\t  Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n\t  loadCustomVfs(settings);\n\t  loadCustomLogImpl(settings);\n\t  // 解析 typeAliases 别名标签\n\t  typeAliasesElement(root.evalNode(\"typeAliases\"));\n\t  // 解析 plugins 插件标签\n\t  pluginElement(root.evalNode(\"plugins\"));\n\t  objectFactoryElement(root.evalNode(\"objectFactory\"));\n\t  objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n\t  reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n\t  settingsElement(settings);\n\t  // read it after objectFactory and objectWrapperFactory issue #631\n\t  // 解析 environments 标签\n\t  environmentsElement(root.evalNode(\"environments\"));\n\t  databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n\t  // 解析 typeHandlers 标签\n\t  typeHandlerElement(root.evalNode(\"typeHandlers\"));\n\t  // 解析 mappers 标签\n\t  mapperElement(root.evalNode(\"mappers\"));\n\t} catch (Exception e) {\n\t  throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n\t}\n}\n```\n\n从 `XMLConfigBuilder` 的方法 `parseConfiguration` 实现我们知道，`MyBatis` 会依次解析配置文件中的相应标签，本文将针对开发中常用的配置进行分析；主要包括 `properties`, `typeAliases`, `enviroments`, `typeHandlers`, `mappers` 。\n\n### properties 解析\n\n#### 配置示例\n\n```xml\n<configuration>\n\t<!-- 可以指定 resource 属性，也可以指定 url 属性 -->\n    <properties resource=\"org/mybatis/example/config.properties\">\n  \t\t<property name=\"username\" value=\"dev_user\"/>\n  \t\t<property name=\"password\" value=\"F2Fa3!33TYyg\"/>\n\t</properties>\n\n</configuration>\n```\n\n从配置示例可以看出 `properties` 属性变量的来源可以是外部的配置文件，也可以是配置文件中自定义的，也可以是 `SqlSessionFactoryBuilder` 的 `build` 方法传参譬如：\n\n```java\npublic SqlSessionFactory build(InputStream inputStream, Properties properties) {\n    return build(inputStream, null, properties);\n  }\n```\n\n> 那么当存在同名的属性时，将采用哪种方式的属性值呢？ \n\n#### 解析\n\n```java\nprivate void propertiesElement(XNode context) throws Exception {\n    if (context != null) {\n      // 获取 properties 标签下的所有 property 子标签\n      Properties defaults = context.getChildrenAsProperties();\n      // 获取 resource，url 属性\n      String resource = context.getStringAttribute(\"resource\");\n      String url = context.getStringAttribute(\"url\");\n\n      // resource url 两个属性不能同时存在\n      if (resource != null && url != null) {\n        throw new BuilderException(\"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.\");\n      }\n      if (resource != null) {\n        // 加载 resource 指定的配置文件\n        defaults.putAll(Resources.getResourceAsProperties(resource));\n      } else if (url != null) {\n        // 加载 url 指定的配置文件\n        defaults.putAll(Resources.getUrlAsProperties(url));\n      }\n\n      /**\n       * 获取传参的 properties\n       * 构建 sqlSessionFactory 时可以传参 properties\n       *\n       * @see SqlSessionFactoryBuilder.build(InputStream inputStream, Properties properties)\n       */\n      Properties vars = configuration.getVariables();\n      if (vars != null) {\n        defaults.putAll(vars);\n      }\n      parser.setVariables(defaults);\n      // 将 properties 赋值 configuration 中的 variables 变量\n      configuration.setVariables(defaults);\n    }\n  }\n```\n```java\npublic Properties getChildrenAsProperties() {\n    Properties properties = new Properties();\n    // 遍历 properties 标签下的 propertry 子标签\n    for (XNode child : getChildren()) {\n      // 获取 propertry 的 name value 属性\n      String name = child.getStringAttribute(\"name\");\n      String value = child.getStringAttribute(\"value\");\n      if (name != null && value != null) {\n        properties.setProperty(name, value);\n      }\n    }\n    return properties;\n  }\n```\n\n从 `properties` 标签解析的实现来看，`MyBatis` 加载 `properties` 属性的过程如下：\n\n* 首先加载 `properties` 标签内所有子标签的 `property`\n* 其次加载 `properties` 标签属性 `resource` 或 `url` 指定的外部属性配置\n* 最后加载 `SqlSessionFactoryBuilder` 的方法 `build` 传参的属性配置\n\n> 因此，通过方法参数传递的 `properties` 具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 `properties` 标签内的子标签 `property` 指定的属性。\n\n### typeAliases 解析\n\n> 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余\n\n#### 配置示例\n\n```xml\n<typeAliases>\n  <typeAlias alias=\"Author\" type=\"domain.blog.Author\"/>\n  <typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/>\n  <typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/>\n</typeAliases>\n```\n\n也可以指定一个包名，`MyBatis` 会在包名下面搜索需要的 Java Bean，比如:\n\n```xml\n<typeAliases>\n  <package name=\"domain.blog\"/>\n</typeAliases>\n```\n\n#### 解析\n\n```java\nprivate void typeAliasesElement(XNode parent) {\n    if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n        // 如果是 package 标签，对整个包下的 java bean 进行别名处理\n        // 若 java bean 没有配置注解的话，使用 bean 的首字母小写类名作为别名\n        // 若 java bean 配置了注解，使用注解值作为别名\n        if (\"package\".equals(child.getName())) {\n          // 获取指定的包名\n          String typeAliasPackage = child.getStringAttribute(\"name\");\n          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);\n        } else {\n          // 别名\n          String alias = child.getStringAttribute(\"alias\");\n          // 别名对应的类\n          String type = child.getStringAttribute(\"type\");\n          try {\n            Class<?> clazz = Resources.classForName(type);\n            if (alias == null) {\n              // 默认别名为类名，若配置了别名注解则取注解值映射类\n              typeAliasRegistry.registerAlias(clazz);\n            } else {\n              // 通过指定的别名映射类\n              typeAliasRegistry.registerAlias(alias, clazz);\n            }\n          } catch (ClassNotFoundException e) {\n            throw new BuilderException(\"Error registering typeAlias for '\" + alias + \"'. Cause: \" + e, e);\n          }\n        }\n      }\n    }\n  }\n```\n\n`typeAliasesElement` 在对 `typeAliases` 标签解析时，针对采用 `package` 和 `typeAlias` 两种配置方式进行了不同的解析。 下面我们先看下通过包名的配置方式\n\n##### 通过包名解析\n\n```java\npublic void registerAliases(String packageName) {\n    registerAliases(packageName, Object.class);\n  }\n\n  public void registerAliases(String packageName, Class<?> superType) {\n  \t// 获取包下所有的类\n    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();\n    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);\n    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();\n    for (Class<?> type : typeSet) {\n      // Ignore inner classes and interfaces (including package-info.java)\n      // Skip also inner classes. See issue #6\n      // 忽略内部类 接口\n      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {\n        registerAlias(type);\n      }\n    }\n  }\n\n  public void registerAlias(Class<?> type) {\n    // 别名为类名\n    String alias = type.getSimpleName();\n    // 是否配置了别名注解，若配置了则别名取注解值\n    Alias aliasAnnotation = type.getAnnotation(Alias.class);\n    if (aliasAnnotation != null) {\n      alias = aliasAnnotation.value();\n    }\n    registerAlias(alias, type);\n  }\n```\n\n当通过 `package` 指定包名时，`MyBatis` 会扫描包下所有的类（忽略内部类，接口），若类没有采用 `@Alias` 注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名, 比如 `domain.blog.Author` 的别名为 author；若有注解，则别名为其注解值。\n\n```java\npublic void registerAlias(String alias, Class<?> value) {\n    if (alias == null) {\n      throw new TypeException(\"The parameter alias cannot be null\");\n    }\n    // issue #748\n    // 别名小写处理\n    String key = alias.toLowerCase(Locale.ENGLISH);\n    if (typeAliases.containsKey(key) && typeAliases.get(key) != null && !typeAliases.get(key).equals(value)) {\n      throw new TypeException(\"The alias '\" + alias + \"' is already mapped to the value '\" + typeAliases.get(key).getName() + \"'.\");\n    }\n    // 别名与类映射\n    typeAliases.put(key, value);\n  }\n```\n\n在完成别名的解析之后会将其注册到 `typeAliasRegistry` 的变量 `typeAliases` Map 集合中。\n\n### 配置环境 environments 解析\n\n> `environments` 用于事务管理器及数据源相关配置\n\n#### 配置示例\n\n```xml\n<environments default=\"development\">\n  <environment id=\"development\">\n    <transactionManager type=\"JDBC\">\n      <property name=\"...\" value=\"...\"/>\n    </transactionManager>\n    <dataSource type=\"POOLED\">\n      <property name=\"driver\" value=\"${driver}\"/>\n      <property name=\"url\" value=\"${url}\"/>\n      <property name=\"username\" value=\"${username}\"/>\n      <property name=\"password\" value=\"${password}\"/>\n    </dataSource>\n  </environment>\n  <environment id=\"test\">\n    <transactionManager type=\"JDBC\">\n      <property name=\"...\" value=\"...\"/>\n    </transactionManager>\n    <dataSource type=\"POOLED\">\n      <property name=\"driver\" value=\"${driver}\"/>\n      <property name=\"url\" value=\"${url}\"/>\n      <property name=\"username\" value=\"${username}\"/>\n      <property name=\"password\" value=\"${password}\"/>\n    </dataSource>\n  </environment>\n</environments>\n```\n\n> 从 `environments` 的配置来看 `MyBatis` 是支持多数据源的，但每个 `SqlSessionFactory` 实例只能选择其中一个； 若需要连接多个数据库，就得需要创建多个 `SqlSessinFactory` 实例。\n\n#### 解析\n\n```java\nprivate void environmentsElement(XNode context) throws Exception {\n    if (context != null) {\n      if (environment == null) {\n        /**\n         * @see org.apache.ibatis.session.SqlSessionFactoryBuilder.build 时未指定 enviorment, 则取默认的\n         */\n        environment = context.getStringAttribute(\"default\");\n      }\n      for (XNode child : context.getChildren()) {\n        String id = child.getStringAttribute(\"id\");\n        // 查找与 environment 匹配的配置环境\n        if (isSpecifiedEnvironment(id)) {\n          // 解析事务管理\n          TransactionFactory txFactory = transactionManagerElement(child.evalNode(\"transactionManager\"));\n          // 解析数据源\n          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(\"dataSource\"));\n          // 获取数据源实例\n          DataSource dataSource = dsFactory.getDataSource();\n          Environment.Builder environmentBuilder = new Environment.Builder(id)\n              .transactionFactory(txFactory)\n              .dataSource(dataSource);\n          // 设置配置环境\n          configuration.setEnvironment(environmentBuilder.build());\n        }\n      }\n    }\n  }\n```\n\n```java\nprivate boolean isSpecifiedEnvironment(String id) {\n    if (environment == null) {\n    \t// 若 environment 为空说明未指定当前 SqlSessionFactory 实例所需的配置环境；同时 environments 标签未配置 default 属性\n      throw new BuilderException(\"No environment specified.\");\n    } else if (id == null) {\n    \t// environment 标签需要配置 id 属性\n      throw new BuilderException(\"Environment requires an id attribute.\");\n    } else if (environment.equals(id)) {\n    \t// environment == id 说明当前匹配配置环境\n      return true;\n    }\n    return false;\n  }\n```\n\n因 `environments` 支持多数据源的配置，所以在解析时会先查找匹配当前 `SqlSessionFactory` 的 `environment`; 然后在解析当前配置环境所需的事务管理器和数据源。\n\n##### 事务管理器解析\n\n```java\nprivate TransactionFactory transactionManagerElement(XNode context) throws Exception {\n    if (context != null) {\n      // 获取配置事务管理器的类别，也就是别名\n      String type = context.getStringAttribute(\"type\");\n      // 获取事务属性配置 \n      Properties props = context.getChildrenAsProperties();\n      // 通过别名查找对应的事务管理器类并实例化\n      TransactionFactory factory = (TransactionFactory) resolveClass(type).newInstance();\n      factory.setProperties(props);\n      return factory;\n    }\n    throw new BuilderException(\"Environment declaration requires a TransactionFactory.\");\n  }\n```\n\n事务管理器解析时会通过配置中指定的 `type` 别名去查找对应的 `TransactionFactory` 并实例化。\n\n> 那么 `MyBatis` 内部内置了哪些事务管理器呢？\n\n```java\npublic Configuration() {\n    typeAliasRegistry.registerAlias(\"JDBC\", JdbcTransactionFactory.class);\n    typeAliasRegistry.registerAlias(\"MANAGED\", ManagedTransactionFactory.class);\n\n    // 省略\n  }\n```\n\n从 `Configuration` 的构造可以看出，其构造时会通过 `typeAliasRegistry` 注册了别名为 `JDBC`,`MANAGED` 的两种事务管理器。\n\n##### 数据源解析\n\n```java\nprivate DataSourceFactory dataSourceElement(XNode context) throws Exception {\n    if (context != null) {\n    \t// 获取配置数据源的类别，也就是别名\n      String type = context.getStringAttribute(\"type\");\n      // 获取数据源属性配置\n      Properties props = context.getChildrenAsProperties();\n      // 通过别名查找数据源并实例化\n      DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();\n      factory.setProperties(props);\n      return factory;\n    }\n    throw new BuilderException(\"Environment declaration requires a DataSourceFactory.\");\n  }\n```\n\n同事务管理器一样，数据源解析时也会通过指定的别名查找对应的数据源实现类同样其在 `Configuration` 构造时向 `typeAliasRegistry` 注册了三种数据源\n\n```java\npublic Configuration() {\n    \n    // 省略\n\n    typeAliasRegistry.registerAlias(\"JNDI\", JndiDataSourceFactory.class);\n    typeAliasRegistry.registerAlias(\"POOLED\", PooledDataSourceFactory.class);\n    typeAliasRegistry.registerAlias(\"UNPOOLED\", UnpooledDataSourceFactory.class);\n\n    // 省略\n  }\n```\n\n### 类型转换器 typeHandlers 解析\n\n#### 配置示例\n\n```xml\n<typeHandlers>\n  <typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\"/>\n</typeHandlers>\n```\n\n```xml\n<typeHandlers>\n  <package name=\"org.mybatis.example\"/>\n</typeHandlers>\n```\n\n#### 解析\n\n```java\nprivate void typeHandlerElement(XNode parent) {\n    if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n        if (\"package\".equals(child.getName())) {\n          String typeHandlerPackage = child.getStringAttribute(\"name\");\n          typeHandlerRegistry.register(typeHandlerPackage);\n        } else {\n          // 映射 java 对象类型\n          String javaTypeName = child.getStringAttribute(\"javaType\");\n          // 映射 jdbc 类型\n          String jdbcTypeName = child.getStringAttribute(\"jdbcType\");\n          // 类型转换器类名\n          String handlerTypeName = child.getStringAttribute(\"handler\");\n\n          Class<?> javaTypeClass = resolveClass(javaTypeName);\n          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);\n          Class<?> typeHandlerClass = resolveClass(handlerTypeName);\n          if (javaTypeClass != null) {\n            if (jdbcType == null) {\n              // 指定了 java type，未指定 jdbc type\n              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);\n            } else {\n              // 指定了 java type，指定了 jdbc type\n              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);\n            }\n          } else {\n          \t// 未指定 java type 按 typeHandlerClass 注册\n            typeHandlerRegistry.register(typeHandlerClass);\n          }\n        }\n      }\n    }\n  }\n```\n\n##### typeHandler 解析\n\n###### 指定 javaType 和 jdbcType\n\n```java\npublic void register(Class<?> javaTypeClass, JdbcType jdbcType, Class<?> typeHandlerClass) {\n    register(javaTypeClass, jdbcType, getInstance(javaTypeClass, typeHandlerClass));\n  }\n```\n```java\nprivate void register(Type javaType, JdbcType jdbcType, TypeHandler<?> handler) {\n    if (javaType != null) {\n      // 一个 java type 可能会映射多个 jdbc type\n      Map<JdbcType, TypeHandler<?>> map = typeHandlerMap.get(javaType);\n      if (map == null || map == NULL_TYPE_HANDLER_MAP) {\n        map = new HashMap<>();\n        typeHandlerMap.put(javaType, map);\n      }\n      map.put(jdbcType, handler);\n    }\n\n    // 存储 typeHandler\n    allTypeHandlersMap.put(handler.getClass(), handler);\n  }\n```\n\n> 当指定了 `javaType` 和 `jdbcType` 最终会将二者及 `typeHandler` 映射并注册到 `typeHandlerMap` 中，从 `typeHandlerMap` 的数据结构来看，`javaType` 可能会与多个 `jdbcType` 映射。 譬如 `String` -> `CHAR`,`VARCHAR` 。\n\n\n###### 指定 javaType 未指定 jdbcType\n\n```java\npublic void register(Class<?> javaTypeClass, Class<?> typeHandlerClass) {\n    // 将 type handler 实例化\n    register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass));\n  }\n```\n\n```java\nprivate <T> void register(Type javaType, TypeHandler<? extends T> typeHandler) {\n\t// 获取 MappedJdbcTypes 注解\n\t// 该注解用于设置类型转换器匹配的 jdbcType\n    MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);\n    if (mappedJdbcTypes != null) {\n    \t// 遍历匹配的 jdbcType 并注册\n      for (JdbcType handledJdbcType : mappedJdbcTypes.value()) {\n        register(javaType, handledJdbcType, typeHandler);\n      }\n      if (mappedJdbcTypes.includeNullJdbcType()) {\n        register(javaType, null, typeHandler);\n      }\n    } else {\n      // 未指定 jdbcType 时按 null 处理\t\n      register(javaType, null, typeHandler);\n    }\n  }\n```\n\n> 当类型转换器配置了 `javaType` 未配置 `jdbcType` 时，会判断类型转换器是否配置了 `@MappedJdbcTypes` 注解； 若配置了则使用注解值作为 `jdbcType` 并注册，若未配置则按 null 注册。\n\n###### 未指定 javaType 和 jdbcType\n\n```java\npublic void register(Class<?> typeHandlerClass) {\n    boolean mappedTypeFound = false;\n    // 获取 MappedTypes 注解\n    // 该注解用于设置类型转换器匹配的 javaType\n    MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);\n    if (mappedTypes != null) {\n      for (Class<?> javaTypeClass : mappedTypes.value()) {\n      \t// 执行注册\n        register(javaTypeClass, typeHandlerClass);\n        mappedTypeFound = true;\n      }\n    }\n    if (!mappedTypeFound) {\n      register(getInstance(null, typeHandlerClass));\n    }\n  }\n```\n\n> 当 `javaType`,`jdbcType` 均为指定时，会判断类型转换器是否配置了 `@MappedTypes` 注解； 若配置了则使用注解值作为 `javaType` 并注册。\n\n##### package 解析\n\n```java\npublic void register(String packageName) {\n\t// 扫描指定包下的所有类\n    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();\n    resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName);\n    Set<Class<? extends Class<?>>> handlerSet = resolverUtil.getClasses();\n    for (Class<?> type : handlerSet) {\n      //Ignore inner classes and interfaces (including package-info.java) and abstract classes\n    \t// 忽略内部类 接口 抽象类\n      if (!type.isAnonymousClass() && !type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {\n      \t// 执行注册\n        register(type);\n      }\n    }\n  }\n```\n\n> 当按指定包名解析时，会扫描包下的所有类（忽略内部类，接口，抽象类）并执行注册\n\n## 小结\n\n本文我们主要分析了 `Mybatis` 配置文件中标签 `properties`,`typeAliases`,`enviroments`,`typeHandlers` 的解析过程，由于 `mappers` 的解析比较复杂后续在进行分析；通过本文的分析我们了解到 `Configuration` 实例中包括以下内容：\n\n* variables : Properties 类型，存储属性变量\n* typeAliasRegistry : 别名注册中心，通过一个 Map 集合变量 `typeAliases` 存储别名与类的映射关系\n* environment : 配置环境，绑定事务管理器和当前数据源\n* typeHandlerRegistry : 类型转换器注册中心，存储 `javaType` 与 `jdbcType`,`typeHandler` 的映射关系，内置 `jdbcType` 与 `typeHandler` 的映射关系\n\n![](https://i.loli.net/2019/06/21/5d0c7dfe7cca931646.png)\n","tags":["Mybatis"]},{"title":"重拾-Spring Transaction","url":"/2019/03/05/重拾-Spring-Transaction/","content":"\n## 问题\n\n面试中是不是有时经常会被问到 “Spring 事务如何管理的了解吗？” ，“Spring 事务的传播性有哪些，能聊聊它们的使用场景吗？”， “事务回滚的时候是所有异常下都会回滚吗？”； 下面我们就带着这些问题来看看 Spring 事务是如何实现的吧。\n\n<!-- more -->\n\n## 实现分析\n\n首先我们还是先通过一个使用示例，先看下 Spring 事务是如何工作的。\n\n### 使用示例\n\n> 本文我们先采用 `TransactionProxyFactoryBean` 配置的方式来看下， Spring 事务如何实现\n\n```xml\n<beans>\n\t<!-- 配置数据源 -->\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" >\n        <property name=\"driverClassName\">\n            <value>com.mysql.jdbc.Driver</value>\n        </property>\n        <property name=\"url\">\n            <value>url</value>\n        </property>\n        <property name=\"username\">\n            <value>username</value>\n        </property>\n        <property name=\"password\">\n            <value>password</value>\n        </property>\n    </bean>\n\n    <!-- 配置事务管理 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\">\n            <ref bean=\"dataSource\"></ref>\n        </property>\n    </bean>\n\n    <!-- 配置 jdbcTemplate -->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\">\n            <ref bean=\"dataSource\"/>\n        </property>\n    </bean>\n\n    <bean id=\"userServiceTarget\" class=\"org.springframework.transaction.UserServiceImpl\">\n        <property name=\"jdbcTemplate\">\n            <ref bean=\"jdbcTemplate\"></ref>\n        </property>\n    </bean>\n\n    <!--\n        TransactionProxyFactoryBean 实现了接口 InitializingBean，在初始化过程中会调用 afterPropertiesSet\n        1 : 创建事务拦截器\n        2 : 创建事务 advisor （事务的拦截切面）\n        3 : 创建代理\n    -->\n    <bean id=\"userService\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\">\n        <property name=\"transactionManager\">\n            <ref bean=\"transactionManager\" />\n        </property>\n\n        <property name=\"target\">\n            <ref bean=\"userServiceTarget\"></ref>\n        </property>\n\n        <property name=\"proxyInterfaces\">\n            <value>org.springframework.transaction.UserService</value>\n        </property>\n        <!--\n            配置事务属性 传播行为, 事务隔离级别, 是否只读, 回滚规则（哪些异常下执行回滚），key 为配置需要事务管理的方法名；\n            在代理目标执行的时候会通过该属性判断方法是否需要事务管理\n        -->\n        <property name=\"transactionAttributes\">\n            <props>\n                <prop key=\"*\">PROPAGATION_REQUIRED</prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n```\n\n在 `TransactionProxyFactoryBean` 的属性配置中如果您对 `transactionAttributes` 属性不熟悉的话，是不是会感觉一头雾水呢？ 这个玩意怎么配置的？ 配置格式又是什么样的呢？ 配置值有哪些呢 ？； 下面将会通过对 `TransactionProxyFactoryBean` 的源码分析来一一解答。\n\n\n### 源码分析\n\n#### 类结构\n\n![](https://i.loli.net/2019/06/21/5d0c7e0cebc5a77922.png)\n\n从 `TransactionProxyFactoryBean` 类结构我们知道，其实现了接口 `InitializingBean` 和 `FactoryBean`; 那么也就是在 `TransactionProxyFactoryBean` 实例化后会调用方法 `afterPropertiesSet`, 在获取目标对象实例时会调用方法 `getObject`; 下面将主要看下这两个方法的实现。\n\n#### afterPropertiesSet-创建目标代理对象\n\n```java\npublic void afterPropertiesSet() throws AopConfigException {\n\t// 校验 Target 目标对象\n\tif (this.target == null) {\n\t\tthrow new AopConfigException(\"Target must be set\");\n\t}\n\n\t// 校验事务属性定义，从抛出的异常信息可以看出 Spring 在此做了强校验；\n\t// 也就是说如果没有需要 Spring 事务管理的方法，就不要采用 TransactionProxyFactoryBean 了\n\t// 那么 transactionAttributeSource 是怎么来的呢？ 见下文分析\n\tif (this.transactionAttributeSource == null) {\n\t\tthrow new AopConfigException(\"Either 'transactionAttributeSource' or 'transactionAttributes' is required: \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"If there are no transactional methods, don't use a transactional proxy.\");\n\t}\n\n\t// 创建事务拦截器 transactionInterceptor\n\tTransactionInterceptor transactionInterceptor = new TransactionInterceptor();\n\ttransactionInterceptor.setTransactionManager(this.transactionManager);\n\ttransactionInterceptor.setTransactionAttributeSource(this.transactionAttributeSource);\n\ttransactionInterceptor.afterPropertiesSet();\n\n\tProxyFactory proxyFactory = new ProxyFactory();\n\n\t// 是否配置了前置拦截\n\tif (this.preInterceptors != null) {\n\t\tfor (int i = 0; i < this.preInterceptors.length; i++) {\n\t\t\tproxyFactory.addAdvisor(GlobalAdvisorAdapterRegistry.getInstance().wrap(this.preInterceptors[i]));\n\t\t}\n\t}\n\n\tif (this.pointcut != null) {\n\t\t// 如果配置了 pointcut 切入点，则按配置的 pointcut 创建 advisor\n\t\tAdvisor advice = new DefaultPointcutAdvisor(this.pointcut, transactionInterceptor);\n\t\tproxyFactory.addAdvisor(advice);\n\t}\n\telse {\n\t\t// rely on default pointcut\n\t\t// 创建事务拦截切面 advisor\n\t\tproxyFactory.addAdvisor(new TransactionAttributeSourceAdvisor(transactionInterceptor));\n\t\t// could just do the following, but it's usually less efficient because of AOP advice chain caching\n\t\t// proxyFactory.addInterceptor(transactionInterceptor);\n\t}\n\n\t// 是否配置了后置拦截\n\tif (this.postInterceptors != null) {\n\t\tfor (int i = 0; i < this.postInterceptors.length; i++) {\n\t\t\tproxyFactory.addAdvisor(GlobalAdvisorAdapterRegistry.getInstance().wrap(this.postInterceptors[i]));\n\t\t}\n\t}\n\n\tproxyFactory.copyFrom(this);\n\n\tproxyFactory.setTargetSource(createTargetSource(this.target));\n\t// 设置代理的接口\n\tif (this.proxyInterfaces != null) {\n\t\tproxyFactory.setInterfaces(this.proxyInterfaces);\n\t}\n\telse if (!getProxyTargetClass()) {\n\t\t// rely on AOP infrastructure to tell us what interfaces to proxy\n\t\tproxyFactory.setInterfaces(AopUtils.getAllInterfaces(this.target));\n\t}\n\t// 创建目标对象的代理对象\n\tthis.proxy = proxyFactory.getProxy();\n}\n```\n\n从源码中我们知道 `afterPropertiesSet` 主要做以下几件事：\n\n* 参数有效性校验; 校验目标对象，事务属性定义\n* 设置代理的 advisor chain, 包括用户自定义的前置拦截, 内置的事务拦截器，用户自定义的后置拦截\n* 创建目标代理对象\n\n> 在 `afterPropertiesSet` 的实现中有个针对 `transactionAttributeSource` 的非空校验，那么这个变量是何时赋值的呢 ? 还记得使用示例中的关于事务属性的定义 `transactionAttributes` 吗 ?\n\n#### setTransactionAttributes-设置事务属性定义\n\n```java\npublic void setTransactionAttributes(Properties transactionAttributes) {\n\tNameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();\n\ttas.setProperties(transactionAttributes);\n\tthis.transactionAttributeSource = tas;\n}\n\npublic void setProperties(Properties transactionAttributes) {\n\tTransactionAttributeEditor tae = new TransactionAttributeEditor();\n\t// 遍历 properties\n\tfor (Iterator it = transactionAttributes.keySet().iterator(); it.hasNext(); ) {\n\t\t// key 为匹配的方法名\n\t\tString methodName = (String) it.next();\n\t\tString value = transactionAttributes.getProperty(methodName);\n\t\t// 解析 value\n\t\ttae.setAsText(value);\n\t\tTransactionAttribute attr = (TransactionAttribute) tae.getValue();\n\t\t// 将方法名与事务属性定义匹配关联\n\t\taddTransactionalMethod(methodName, attr);\n\t}\n}\n```\n\n下面我们就看下 `setAsText` 方法是如何解析事务属性的配置\n\n```java\n/**\n * Format is PROPAGATION_NAME,ISOLATION_NAME,readOnly,+Exception1,-Exception2.\n * Null or the empty string means that the method is non transactional.\n * @see java.beans.PropertyEditor#setAsText(java.lang.String)\n */\npublic void setAsText(String s) throws IllegalArgumentException {\n\tif (s == null || \"\".equals(s)) {\n\t\tsetValue(null);\n\t}\n\telse {\n\t\t// tokenize it with \",\"\n\t\t// 按 , 分割配置信息\n\t\tString[] tokens = StringUtils.commaDelimitedListToStringArray(s);\n\t\tRuleBasedTransactionAttribute attr = new RuleBasedTransactionAttribute();\n\n\t\tfor (int i = 0; i < tokens.length; i++) {\n\t\t\tString token = tokens[i];\n\t\t\t// 以 PROPAGATION 开头，则配置事务传播性\n\t\t\tif (token.startsWith(TransactionDefinition.PROPAGATION_CONSTANT_PREFIX)) {\n\t\t\t\tattr.setPropagationBehaviorName(tokens[i]);\n\t\t\t}\n\t\t\t// 以 ISOLATION 开头，则配置事务隔离级别\n\t\t\telse if (token.startsWith(TransactionDefinition.ISOLATION_CONSTANT_PREFIX)) {\n\t\t\t\tattr.setIsolationLevelName(tokens[i]);\n\t\t\t}\n\t\t\t// 以 timeout_ 开头，则设置事务超时时间\n\t\t\telse if (token.startsWith(DefaultTransactionAttribute.TIMEOUT_PREFIX)) {\n\t\t\t\tString value = token.substring(DefaultTransactionAttribute.TIMEOUT_PREFIX.length());\n\t\t\t\tattr.setTimeout(Integer.parseInt(value));\n\t\t\t}\n\t\t\t// 若等于 readOnly 则配置事务只读\n\t\t\telse if (token.equals(DefaultTransactionAttribute.READ_ONLY_MARKER)) {\n\t\t\t\tattr.setReadOnly(true);\n\t\t\t}\n\t\t\t// 以 + 开头，则配置哪些异常下不回滚\n\t\t\telse if (token.startsWith(DefaultTransactionAttribute.COMMIT_RULE_PREFIX)) {\n\t\t\t\tattr.getRollbackRules().add(new NoRollbackRuleAttribute(token.substring(1)));\n\t\t\t}\n\t\t\t// 以 - 开头，则配置哪些异常下回滚\n\t\t\telse if (token.startsWith(DefaultTransactionAttribute.ROLLBACK_RULE_PREFIX)) {\n\t\t\t\tattr.getRollbackRules().add(new RollbackRuleAttribute(token.substring(1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Illegal transaction token: \" + token);\n\t\t\t}\n\t\t}\n\n\t\tsetValue(attr);\n\t}\n}\n```\n\n从 `setAsText` 方法的实现我们就可以搞明白在配置文件中 `transactionAttributes` 如何配置了，譬如：\n\n```xml\n<property name=\"transactionAttributes\">\n    <props>\n        <prop key=\"*\">PROPAGATION_REQUIRED, ISOLATION_DEFAULT, readOnly</prop>\n    </props>\n</property>\n```\n\n也可以这样配置：\n\n```xml\n<property name=\"transactionAttributes\">\n    <props>\n        <prop key=\"*\">readOnly, ISOLATION_DEFAULT, PROPAGATION_REQUIRED</prop>\n    </props>\n</property>\n```\n\n也就是说 `transactionAttributes` 的配置只要保证 `token` 格式正确即可，顺序无关；但是从规范来讲建议还是保持 `PROPAGATION_NAME,ISOLATION_NAME,readOnly,+Exception1,-Exception2.` 的格式。\n\n#### getObject-获取代理对象\n\n```java\npublic Object getObject() {\n\t// proxy 对象在 afterPropertiesSet 方法执行时产生\n\treturn this.proxy;\n}\n```\n\n#### 代理执行\n\n##### 是否支持事务\n\n在 `重拾-Spring AOP` 中我们知道，当代理对象在执行的时候会先获取当前方法所匹配的 `advisor` (参见类 `JdkDynamicAopProxy`); 而 `TransactionProxyFactoryBean` 在创建代理对象的时候会将 `TransactionInterceptor` 绑定到 `TransactionAttributeSourceAdvisor` 上，那么我就看下 `TransactionAttributeSourceAdvisor` 是如何匹配方法的。\n\n```java\npublic class TransactionAttributeSourceAdvisor extends StaticMethodMatcherPointcutAdvisor {\n\n\tprivate TransactionAttributeSource transactionAttributeSource;\n\n\tpublic TransactionAttributeSourceAdvisor(TransactionInterceptor ti) {\n\t\tsuper(ti);\n\t\tif (ti.getTransactionAttributeSource() == null) {\n\t\t\tthrow new AopConfigException(\"Cannot construct a TransactionAttributeSourceAdvisor using a \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"TransactionInterceptor that has no TransactionAttributeSource configured\");\n\t\t}\n\t\tthis.transactionAttributeSource = ti.getTransactionAttributeSource();\n\t}\n\n\tpublic boolean matches(Method m, Class targetClass) {\n\t\treturn (this.transactionAttributeSource.getTransactionAttribute(m, targetClass) != null);\n\t}\n}\n```\n\n`TransactionAttributeSourceAdvisor` 判断方法是否匹配时，实际是由 `NameMatchTransactionAttributeSource` 的方法 `getTransactionAttribute` 来处理。\n\n```java\npublic TransactionAttribute getTransactionAttribute(Method method, Class targetClass) {\n\t// 获取目标方法名\n\tString methodName = method.getName();\n\t// 获取目标方法匹配的事务属性定义\n\tTransactionAttribute attr = (TransactionAttribute) this.nameMap.get(methodName);\n\t// 如果 attr 不为空说明当前方法配置了事务属性定义，也就是当前方法需要事务管理\n\tif (attr != null) {\n\t\treturn attr;\n\t}\n\telse {\n\t\t// look up most specific name match\n\t\tString bestNameMatch = null;\n\t\tfor (Iterator it = this.nameMap.keySet().iterator(); it.hasNext();) {\n\t\t\t// 判断当前方法是否匹配通配符的方式\n\t\t\tString mappedName = (String) it.next();\n\t\t\tif (isMatch(methodName, mappedName) &&\n\t\t\t\t\t(bestNameMatch == null || bestNameMatch.length() <= mappedName.length())) {\n\t\t\t\tattr = (TransactionAttribute) this.nameMap.get(mappedName);\n\t\t\t\tbestNameMatch = mappedName;\n\t\t\t}\n\t\t}\n\t\treturn attr;\n\t}\n}\n\nprotected boolean isMatch(String methodName, String mappedName) {\n\treturn (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) ||\n\t\t\t(mappedName.startsWith(\"*\") && methodName.endsWith(mappedName.substring(1, mappedName.length())));\n}\n```\n##### TransactionInterceptor-事务拦截\n\n在完成判断当前方法是否需要事务管理后，如果需要事务管理最终会调用 `TransactionInterceptor` 执行事务拦截的处理。\n\n```java\npublic final Object invoke(MethodInvocation invocation) throws Throwable {\n\tClass targetClass = (invocation.getThis() != null) ? invocation.getThis().getClass() : null;\n\t// if the transaction attribute is null, the method is non-transactional\n\t// 获取当前方法所支持的事务配置属性，若不存在则说明当前方法不需要事务管理\n\tTransactionAttribute transAtt = this.transactionAttributeSource.getTransactionAttribute(invocation.getMethod(), targetClass);\n\tTransactionStatus status = null;\n\tTransactionStatus oldTransactionStatus = null;\n\t\n\t// create transaction if necessary\n\tif (transAtt != null) {\t\t\n\t\t// the transaction manager will flag an error if an incompatible tx already exists\n\t\t// 通过事务管理获取事务，该事务可能是新创建的也可能是当前上下文已存在的事务\n\t\t// 返回事务状态\n\t\tstatus = this.transactionManager.getTransaction(transAtt);\n\t\t\n\t\t// make the TransactionStatus available to callees\n\t\toldTransactionStatus = (TransactionStatus) currentTransactionStatus.get();\n\t\tcurrentTransactionStatus.set(status);\n\t}\n\telse {\n\t\t// it isn't a transactional method\n\t\t\n\t}\n\n\tObject retVal = null;\n\ttry {\n\t\t// 目标方法执行\n\t\tretVal = invocation.proceed();\n\t}\n\tcatch (Throwable ex) {\n\t\t// target invocation exception\n\t\tif (status != null) {\n\t\t\t// 异常处理 可能会执行事务的回滚\n\t\t\tonThrowable(invocation, transAtt, status, ex);\n\t\t}\n\t\tthrow ex;\n\t}\n\tfinally {\n\t\tif (transAtt != null) {\n\t\t\t// use stack to restore old transaction status if one was set\n\t\t\tcurrentTransactionStatus.set(oldTransactionStatus);\n\t\t}\n\t}\n\tif (status != null) {\n\t\t// 通过事务管理执行事务提交\n\t\tthis.transactionManager.commit(status);\n\t}\n\treturn retVal;\n}\n```\n\n```java\nprivate void onThrowable(MethodInvocation invocation, TransactionAttribute txAtt,\n\t                         TransactionStatus status, Throwable ex) {\n\t// 判断异常是否需要回滚\n\tif (txAtt.rollbackOn(ex)) {\n\t\ttry {\n\t\t\t// 通过事务管理执行回滚\n\t\t\tthis.transactionManager.rollback(status);\n\t\t}\n\t\tcatch (TransactionException tex) {\n\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\tthrow tex;\n\t\t}\n\t}\n\telse {\n\t\t// Will still roll back if rollbackOnly is true\n\t\t// 异常不需要回滚的话 则提交事务\n\t\tthis.transactionManager.commit(status);\n\t}\n}\n```\n\n从 `TransactionInterceptor` 的处理逻辑来看，我们知道其主要做以下事情：\n\n* 获取当前方法所定义的事务属性\n* 通过事务管理器 Transaction Manager 来获取事务\n* 目标方法执行\n* 执行异常处理，如异常需要回滚则通过事务管理器执行事务 `rollback`，反之执行事务 `commit`\n* 方法执行成功则执行事务 `commit`\n\n> 也就是说 `TransactionInterceptor` (事务拦截器) 主要是将事务相关的动作委托给 `TransactionManager` （事务管理器）处理\n\n##### TransactionManager-事务管理\n\n> 本文是以 `DataSourceTransactionManager` 为例来分析事务的管理实现\n\n###### getTransaction-获取事务\n\n```java\npublic final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {\n\t// 获取事务\n\tObject transaction = doGetTransaction();\n\tif (definition == null) {\n\t\t// 若 definition == null 则采用默认的事务定义\n\t\tdefinition = new DefaultTransactionDefinition();\n\t}\n\n\t// 判断当前上下文是否开启过事务\n\tif (isExistingTransaction(transaction)) {\n\t\t// 当前上下文开启过事务\n\t\t// 如果当前方法匹配的事务传播性为 PROPAGATION_NEVER 说明不需要事务则抛出异常\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\n\t\t\tthrow new IllegalTransactionStateException(\"Transaction propagation 'never' but existing transaction found\");\n\t\t}\n\n\t\t// 如果当前方法匹配的事务传播性为 PROPAGATION_NOT_SUPPORTED 说明该方法不应该运行在事务中，则将当前事务挂起\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n\t\t\t// 将当前事务挂起\n\t\t\tObject suspendedResources = suspend(transaction);\n\t\t\tboolean newSynchronization = (this.transactionSynchronization == SYNCHRONIZATION_ALWAYS);\n\t\t\t// 返回的事务状态为 不需要事务\n\t\t\treturn newTransactionStatus(null, false, newSynchronization,\n\t\t\t                            definition.isReadOnly(), debugEnabled, suspendedResources);\n\t\t}\n\t\t// 如果当前方法匹配的事务传播性为 PROPAGATION_REQUIRES_NEW 表示当前方法必须运行在它自己的事务中；将已存在的事务挂起，重新开启事务\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Creating new transaction, suspending current one\");\n\t\t\t}\n\t\t\t// 挂起当前事务\n\t\t\tObject suspendedResources = suspend(transaction);\n\t\t\t// 重新开启个事务\n\t\t\tdoBegin(transaction, definition);\n\t\t\tboolean newSynchronization = (this.transactionSynchronization != SYNCHRONIZATION_NEVER);\n\t\t\t// 返回的事务状态为 新建事务\n\t\t\treturn newTransactionStatus(transaction, true, newSynchronization,\n\t\t\t                            definition.isReadOnly(), debugEnabled, suspendedResources);\n\t\t}\n\t\telse {\n\t\t\tboolean newSynchronization = (this.transactionSynchronization != SYNCHRONIZATION_NEVER);\n\t\t\t// 其他的传播行为 表示在已存在的事务中执行\n\t\t\treturn newTransactionStatus(transaction, false, newSynchronization,\n\t\t\t                            definition.isReadOnly(), debugEnabled, null);\n\t\t}\n\t}\n\n\tif (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\tthrow new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout());\n\t}\n\n\t// 如果传播性为 PROPAGATION_MANDATORY 说明必须在事务中执行，若当前没有事务的话则抛出异常\n\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\n\t\tthrow new IllegalTransactionStateException(\"Transaction propagation 'mandatory' but no existing transaction found\");\n\t}\n\n\t// 当前上下文不存在事务\n\t// 若传播性为 PROPAGATION_REQUIRED 或 PROPAGATION_REQUIRES_NEW 则开启新的事务执行\n\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\n\t    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n\t\t// 开启新的 connection 并取消自动提交，将 connection 绑定当前线程\n\t\tdoBegin(transaction, definition);\n\t\tboolean newSynchronization = (this.transactionSynchronization != SYNCHRONIZATION_NEVER);\n\t\treturn newTransactionStatus(transaction, true, newSynchronization,\n\t\t                            definition.isReadOnly(), debugEnabled, null);\n\t}\n\telse {\n\t\t// \"empty\" (-> no) transaction\n\t\tboolean newSynchronization = (this.transactionSynchronization == SYNCHRONIZATION_ALWAYS);\n\t\t// 返回事务状态为 不需要事务\n\t\treturn newTransactionStatus(null, false, newSynchronization,\n\t\t                            definition.isReadOnly(), debugEnabled, null);\n\t}\n}\n\nprotected Object doGetTransaction() {\n\t// 判断当前线程是否开启过事务\n\tif (TransactionSynchronizationManager.hasResource(this.dataSource)) {\n\t\t// 获取当前已存在的 connectoin holder\n\t\tConnectionHolder holder = (ConnectionHolder) TransactionSynchronizationManager.getResource(this.dataSource);\n\t\treturn new DataSourceTransactionObject(holder);\n\t}\n\telse {\n\t\treturn new DataSourceTransactionObject();\n\t}\n}\n```\n\n看到了这里，是不是突然明白 `PROPAGATION` (事务传播性) 是干什么的了；\n\n> 简单来说, `PROPAGATION` 就是为了告诉 Spring 当前方法需不需要事务，是在已存在的事务中执行，还是新开启事务执行；也可以认为是继承上个方法栈的事务，还是拥有自己的事务。\n\n`TransactionManager` 获取事务的过程实际就是通过当前方法定义的 `PROPAGATION` (事务传播性) 和当前上下文是否存在事务来判断是否需要事务，是否需要开启新的事务或者是使用当前已存在的事务。\n\n下面看下如何开启新的事务 `doBegin`\n\n```java\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\n\t// cache to avoid repeated checks\n\tboolean debugEnabled = logger.isDebugEnabled();\n\n\t// 判断 connection holder 是否为空\n\t// 两种场景下可能为空：\n\t// 1. 上下文不存在事务的时候\n\t// 2. 上下文已存在的事务被挂起的时候\n\tif (txObject.getConnectionHolder() == null) {\n\t\tif (debugEnabled) {\n\t\t\tlogger.debug(\"Opening new connection for JDBC transaction\");\n\t\t}\n\t\t// 开启新的 connection\n\t\tConnection con = DataSourceUtils.getConnection(this.dataSource, false);\n\t\ttxObject.setConnectionHolder(new ConnectionHolder(con));\n\t}\n\n\tConnection con = txObject.getConnectionHolder().getConnection();\n\ttry {\n\t\t// apply read-only\n\t\tif (definition.isReadOnly()) {\n\t\t\ttry {\n\t\t\t\t// 如果定义了只读，设置 connection 为只读\n\t\t\t\tcon.setReadOnly(true);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// SQLException or UnsupportedOperationException\n\t\t\t\tlogger.warn(\"Could not set JDBC connection read-only\", ex);\n\t\t\t}\n\t\t}\n\n\t\t// apply isolation level\n\t\t// 设置事务隔离级别\n\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\ttxObject.setPreviousIsolationLevel(new Integer(con.getTransactionIsolation()));\n\t\t\tcon.setTransactionIsolation(definition.getIsolationLevel());\n\t\t}\n\n\t\t// 若 connection 为自动提交则取消\n\t\tif (con.getAutoCommit()) {\n\t\t\ttxObject.setMustRestoreAutoCommit(true);\n\t\t\tcon.setAutoCommit(false);\n\t\t}\n\n\t\t// 设置超时时间\n\t\tif (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\ttxObject.getConnectionHolder().setTimeoutInSeconds(definition.getTimeout());\n\t\t}\n\n\t\t// 将当前 connection holder 绑定到当前上下文\n\t\tTransactionSynchronizationManager.bindResource(this.dataSource, txObject.getConnectionHolder());\n\t}\n\tcatch (SQLException ex) {\n\t\tthrow new CannotCreateTransactionException(\"Could not configure connection\", ex);\n\t}\n}\n```\n\n`doBegin` 执行开启事务的操作，在上下文不存在事务或者上下文事务被挂起的时候会新打开一个 `connection`, 并按照事务定义设置相关属性，譬如是否只读，取消自动提交，设置事务隔离级别，设置超时时间；最后会将 `connection` 绑定到当前上下文，也即当前线程。\n\n###### doSuspend-事务挂起\n\n```java\nprotected Object doSuspend(Object transaction) {\n\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t// 将当前事务的 connection holder 置为空\n\ttxObject.setConnectionHolder(null);\n\t// 并将当前事务与上下文解绑\n\treturn TransactionSynchronizationManager.unbindResource(this.dataSource);\n}\n```\n\n事务挂起既是将当前事务的连接持有者清空并与当前上下文解绑，保证后续能够重新开启事务。\n\n###### 数据库操作\n\n> 针对数据库的操作，本文以 Spring 提供的 `jdbcTemplate` 工具类进行分析。\n\n```java\npublic Object execute(final StatementCallback action) {\n\t// 若当前需要事务管理的话，那么此时获取的 connection 则是 transaction manager bind 的 connection\n\t// 这样就保证数据库操作的时候所获得的的 connection 与 事务管理的一致\n\tConnection con = DataSourceUtils.getConnection(getDataSource());\n\tStatement stmt = null;\n\t// 以下代码省略 此处重点关注如何获取 connection\n}\n```\n\n```java\npublic static Connection getConnection(DataSource ds, boolean allowSynchronization)\n\t    throws CannotGetJdbcConnectionException {\n\t// 从当前上下文获取 connection holder\n\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(ds);\n\tif (conHolder != null) {\n\t\treturn conHolder.getConnection();\n\t}\n\telse {\n\t\ttry {\n\t\t\t// 反之新打开一个 connection\n\t\t\tConnection con = ds.getConnection();\n\t\t\tif (allowSynchronization && TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\tlogger.debug(\"Registering transaction synchronization for JDBC connection\");\n\t\t\t\t// use same Connection for further JDBC actions within the transaction\n\t\t\t\t// thread object will get removed by synchronization at transaction completion\n\t\t\t\tconHolder = new ConnectionHolder(con);\n\t\t\t\tTransactionSynchronizationManager.bindResource(ds, conHolder);\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(new ConnectionSynchronization(conHolder, ds));\n\t\t\t}\n\t\t\treturn con;\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new CannotGetJdbcConnectionException(\"Could not get JDBC connection\", ex);\n\t\t}\n\t}\n}\n```\n\n从上述代码我们可以看到，当通过 `jdbcTemplate` 操作数据库时会先从当前上下文中获取 `connection`; 这样就保证了所获取的事务与事务拦截器的事务为同一个实例，也就是将事务交给了 Spring 来管理。\n\n###### commit-事务提交\n\n```java\npublic final void commit(TransactionStatus status) throws TransactionException {\n\tDefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\n\t// 省略\n\telse {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\ttriggerBeforeCommit(defStatus);\n\t\t\t\ttriggerBeforeCompletion(defStatus);\n\t\t\t\tif (status.isNewTransaction()) {\n\t\t\t\t\tlogger.info(\"Initiating transaction commit\");\n\t\t\t\t\t// 执行事务提交\n\t\t\t\t\tdoCommit(defStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 省略\n\t\t}\n\t\tfinally {\n\t\t\tcleanupAfterCompletion(defStatus);\n\t\t}\n\t}\n}\n```\n\n`doCommit` 执行事务提交\n\n```java\nprotected void doCommit(DefaultTransactionStatus status) {\n\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n\tif (status.isDebug()) {\n\t\tlogger.debug(\"Committing JDBC transaction [\" + txObject.getConnectionHolder().getConnection() + \"]\");\n\t}\n\ttry {\n\t\t// 事务提交\n\t\ttxObject.getConnectionHolder().getConnection().commit();\n\t}\n\tcatch (SQLException ex) {\n\t\tthrow new TransactionSystemException(\"Could not commit\", ex);\n\t}\n}\n```\n\n###### resume-事务恢复\n\n从上文的 `commit` 事务提交操作发现，在完成事务提交之后，还有个后置动作 `cleanupAfterCompletion`, 该方法会对挂起中的事务执行恢复操作。\n\n```java\nprivate void cleanupAfterCompletion(DefaultTransactionStatus status) {\n\tif (status.isNewSynchronization()) {\n\t\tTransactionSynchronizationManager.clearSynchronization();\n\t}\n\tif (status.isNewTransaction()) {\n\t\tdoCleanupAfterCompletion(status.getTransaction());\n\t}\n\t// 当存在挂起的事务时，执行恢复挂起的事务\n\tif (status.getSuspendedResources() != null) {\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Resuming suspended transaction\");\n\t\t}\n\t\tresume(status.getTransaction(), status.getSuspendedResources());\n\t}\n}\n```\n\n```java\nprotected void doResume(Object transaction, Object suspendedResources) {\n\t// 将挂起的事务绑定的 connection 重新绑定到当前上下文\n\tConnectionHolder conHolder = (ConnectionHolder) suspendedResources;\n\tTransactionSynchronizationManager.bindResource(this.dataSource, conHolder);\n}\n```\n\n事务的 `resume` 就是将挂起的事务重新绑定到当前上下文中。 \n\n###### rollback-事务回滚\n\n当 `TransactionInterceptor` 调用目标方法执行出现异常的时候，会进行异常处理执行方法 `onThrowable`\n\n```java\nprivate void onThrowable(MethodInvocation invocation, TransactionAttribute txAtt,\n                         TransactionStatus status, Throwable ex) {\n\tif (txAtt.rollbackOn(ex)) {\n\t\ttry {\n\t\t\t// 异常需要回滚\n\t\t\tthis.transactionManager.rollback(status);\n\t\t}\n\t\tcatch (TransactionException tex) {\n\t\t\tthrow tex;\n\t\t}\n\t}\n\telse {\n\t\t// 异常不需要回滚的话 则提交事务\n\t\tthis.transactionManager.commit(status);\n\t}\n}\n```\n\n`onThrowable` 方法会通过配置判断当前异常是否需要回滚。\n\n```java\npublic final void rollback(TransactionStatus status) throws TransactionException {\n\tDefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\n\ttry {\n\t\ttry {\n\t\t\ttriggerBeforeCompletion(defStatus);\n\t\t\tif (status.isNewTransaction()) {\n\t\t\t\t// 执行事务回滚\n\t\t\t\tlogger.info(\"Initiating transaction rollback\");\n\t\t\t\tdoRollback(defStatus);\n\t\t\t}\n\t\t\telse if (defStatus.getTransaction() != null) {\n\t\t\t\tif (defStatus.isDebug()) {\n\t\t\t\t\tlogger.debug(\"Setting existing transaction rollback-only\");\n\t\t\t\t}\n\t\t\t\tdoSetRollbackOnly(defStatus);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Should roll back transaction but cannot - no transaction available\");\n\t\t\t}\n\t\t}\n\t\tcatch (TransactionException ex) {\n\t\t\ttriggerAfterCompletion(defStatus, TransactionSynchronization.STATUS_UNKNOWN, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\ttriggerAfterCompletion(defStatus, TransactionSynchronization.STATUS_ROLLED_BACK, null);\n\t}\n\tfinally {\n\t\tcleanupAfterCompletion(defStatus);\n\t}\n}\n\nprotected void doRollback(DefaultTransactionStatus status) {\n\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n\ttry {\n\t\t// 执行回滚\n\t\ttxObject.getConnectionHolder().getConnection().rollback();\n\t}\n\tcatch (SQLException ex) {\n\t\tthrow new TransactionSystemException(\"Could not rollback\", ex);\n\t}\n}\n```\n\n### 小结\n\n此时我们基本明白了 Spring Transaction 的实现原理，下面对其实现做个小结：\n\n* Spring Transaction 是基于 Spring AOP 的一种实现\n* Spring Transaction 通过配置创建事务 advisor 并创建目标对象代理类\n* 目标方法执行时将会被 `TransactionInterceptor` 拦截\n* `TransactionInterceptor` 会委派 `TransactionManager` 执行事务的创建，事务提交，事务回滚的动作\n* `TransactionManager` 会根据当前方法配置的事务传播性及当前上下文是否存在事务来判断是否新建事务\n* `TransactionManager` 当新建事务时会将事务绑定到当前上下文，以保证目标方法执行时获取的事务为同一实例\n* `TransactionManager` 执行事务挂起时会将当前事务与当前上下文解除绑定关系\n* `TransactionManager` 执行事务恢复时会将已挂起的事务重新与当前上下文绑定\n\n\n![](https://i.loli.net/2019/06/21/5d0c7e1106fe549574.png)\n","tags":["Spring"]},{"title":"重拾-Spring AOP-自动代理","url":"/2019/03/04/重拾-Spring-AOP-自动代理/","content":"\n## 概述\n\n在上一篇 `重拾-Spring AOP` 中我们会发现 Spring AOP 是通过类 `ProxyFactoryBean` 创建代理对象，其有个缺陷就是只能代理一个目标对象 bean, 当代理目标类过多时，配置文件臃肿不方便管理维护，因此 Spring 提供了能够实现自动创建代理的类 `BeanNameAutoProxyCreator` , `DefaultAdvisorAutoProxyCreator` ；下面我们看下二者是如何实现自动代理的。\n\n<!-- more -->\n\n## BeanNameAutoProxyCreator\n\n> `BeanNameAutoProxyCreator` 是通过判断当前 bean name 是否匹配，只有匹配的 bean 才会创建代理。\n\n### 使用示例\n\n* Spring xml 配置\n\n```xml\n<bean id=\"userService\" class=\"org.springframework.aop.UserServiceImpl\" />\n<bean id=\"demoService\" class=\"org.springframework.aop.DemoServiceImpl\" />\n\n<bean id=\"userBeforeAdvice\" class=\"org.springframework.aop.UserBeforeAdvice\" />\n<bean id=\"userAfterAdvice\" class=\"org.springframework.aop.UserAfterAdvice\" />\n\n<bean id=\"beanNameAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\n\t<!-- 配置要代理的 bean -->\n    <property name=\"beanNames\">\n        <list>\n            <value>userService</value>\n            <value>demoService</value>\n        </list>\n    </property>\n    <!-- 配置 interceptor, advice, advisor -->\n    <property name=\"interceptorNames\">\n        <list>\n            <value>userAfterAdvice</value>\n            <value>userBeforeAdvice</value>\n        </list>\n    </property>\n</bean>\n```\n\n* 测试\n\n```java\nClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/org/springframework/aop/aop.xml\");\n\nUserService userService = (UserService) ctx.getBean(\"userService\");\n\nuserService.say();\n\nDemoService demoService = (DemoService) ctx.getBean(\"demoService\");\n\ndemoService.demo();\n```\n\n* 运行结果\n\n```\ndo before advice ....\ndo say method\ndo after return advice ....\ndo before advice ....\ndo demo.\ndo after return advice ....\n```\n\n### 实现分析\n\n##### 类结构\n\n![](https://i.loli.net/2019/06/21/5d0c7e016fccc50312.png)\n\n如上图 `BeanNameAutoProxyCreator` 类结构可以看出，其实现了接口 `BeanPostProcessor` ; 那么我们可以大概猜测出其自动代理的实现原理与自动注入类似，都是在 bean 实例化后进行特殊的处理，下面就让我们看下源码验证下吧。\n\n##### 分析\n\n```java\npublic Object postProcessAfterInitialization(Object bean, String name) throws BeansException {\n\t// Check for special cases. We don't want to try to autoproxy a part of the autoproxying\n\t// infrastructure, lest we get a stack overflow.\n\tif (isInfrastructureClass(bean, name) || shouldSkip(bean, name)) {\n\t\tlogger.debug(\"Did not attempt to autoproxy infrastructure class '\" + bean.getClass() + \"'\");\n\t\treturn bean;\n\t}\n\t\n\tTargetSource targetSource = getTargetSource(bean, name);\n\t\n\tObject[] specificInterceptors = getInterceptorsAndAdvisorsForBean(bean, name);\n\t\n\t// proxy if we have advice or if a TargetSourceCreator wants to do some\n\t// fancy stuff such as pooling\n\tif (specificInterceptors != DO_NOT_PROXY || !(targetSource instanceof SingletonTargetSource)) {\n\n\t\t// handle prototypes correctly\n\t\t// 获取容器中配置的 advisors \n\t\tAdvisor[] commonInterceptors = resolveInterceptorNames();\n\n\t\tList allInterceptors = new ArrayList();\n\t\tif (specificInterceptors != null) {\n\t\t\tallInterceptors.addAll(Arrays.asList(specificInterceptors));\n\t\t\tif (commonInterceptors != null) {\n\t\t\t\tif (this.applyCommonInterceptorsFirst) {\n\t\t\t\t\tallInterceptors.addAll(0, Arrays.asList(commonInterceptors));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tallInterceptors.addAll(Arrays.asList(commonInterceptors));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tint nrOfCommonInterceptors = commonInterceptors != null ? commonInterceptors.length : 0;\n\t\t\tint nrOfSpecificInterceptors = specificInterceptors != null ? specificInterceptors.length : 0;\n\t\t\tlogger.info(\"Creating implicit proxy for bean '\" +  name + \"' with \" + nrOfCommonInterceptors +\n\t\t\t\t\t\t\t\t\t\" common interceptors and \" + nrOfSpecificInterceptors + \" specific interceptors\");\n\t\t}\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\n\t\t// copy our properties (proxyTargetClass) inherited from ProxyConfig\n\t\tproxyFactory.copyFrom(this);\n\t\t\n\t\tif (!getProxyTargetClass()) {\n\t\t\t// Must allow for introductions; can't just set interfaces to\n\t\t\t// the target's interfaces only.\n\t\t\t// 添加设置代理的接口\n\t\t\tClass[] targetsInterfaces = AopUtils.getAllInterfaces(bean);\n\t\t\tfor (int i = 0; i < targetsInterfaces.length; i++) {\n\t\t\t\tproxyFactory.addInterface(targetsInterfaces[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Iterator it = allInterceptors.iterator(); it.hasNext();) {\n\t\t\tAdvisor advisor = GlobalAdvisorAdapterRegistry.getInstance().wrap(it.next());\n\t\t\t// 添加 advisor\n\t\t\tproxyFactory.addAdvisor(advisor);\n\t\t}\n\t\tproxyFactory.setTargetSource(getTargetSource(bean, name));\n\t\t\n\t\t// 创建代理对象，依旧采用的 jdk 动态代理; 因为上面设置了代理的 interface\n\t\treturn proxyFactory.getProxy();\n\t}\n\telse {\n\t\treturn bean;\n\t}\n}\n```\n```java\nprotected Object[] getInterceptorsAndAdvisorsForBean(Object bean, String beanName) {\n\tif (this.beanNames != null) {\n\t\t// bean name 包含在配置的名称列表中，说明需要代理\n\t\tif (this.beanNames.contains(beanName)) {\n\t\t\treturn PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS;\n\t\t}\n\t\tfor (Iterator it = this.beanNames.iterator(); it.hasNext();) {\n\t\t\tString mappedName = (String) it.next();\n\t\t\t// bean name 匹配通配符，说明需要代理\n\t\t\tif (isMatch(beanName, mappedName)) {\n\t\t\t\treturn PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS;\n\t\t\t}\n\t\t}\n\t}\n\t// 说明 bean 不需要代理\n\treturn DO_NOT_PROXY;\n}\n```\n```java\nprotected boolean isMatch(String beanName, String mappedName) {\n\t// bean name 匹配通配符\n\treturn (mappedName.endsWith(\"*\") && beanName.startsWith(mappedName.substring(0, mappedName.length() - 1))) ||\n\t\t\t(mappedName.startsWith(\"*\") && beanName.endsWith(mappedName.substring(1, mappedName.length())));\n}\n```\n\n从 `BeanNameAutoProxyCreator` 的源码大概总结其自动代理流程：\n\n* 判断当前 bean name 是否匹配配置\n* 加载配置的 advisor, 也就是配置的 interceptorNames\n* 采用 jdk 动态代理创建 bean 的代理对象\n\n## DefaultAdvisorAutoProxyCreator\n\n> `DefaultAdvisorAutoProxyCreator` 会搜索 `BeanFactory` 容器内部所有可用的 `Advisor`; 并为容器中匹配的 bean 创建代理。 在上一篇 `重拾-Spring AOP` 中我们知道 Spring AOP 会默认创建实例为 `DefaultPointcutAdvisor` 的 `Advisor`； 那么在分析 `DefaultAdvisorAutoProxyCreator` 之前，我们看下 Spring AOP 还为我们提供了哪些内置的 `Advisor` 。\n\n#### NameMatchMethodPointcutAdvisor\n\n> `NameMatchMethodPointcutAdvisor` 是按 method name 匹配，只有当目标类执行方法匹配的时候，才会执行 `Advice`\n\n```java\npublic class NameMatchMethodPointcut extends StaticMethodMatcherPointcut {\n\n\t// 配置拦截的 method name\n\tprivate String[] mappedNames = new String[0];\n\n\tpublic boolean matches(Method m, Class targetClass) {\n\t\tfor (int i = 0; i<this.mappedNames.length; i++) {\n\t\t\tString mappedName = this.mappedNames[i];\n\t\t\t// 目标方法是否与配置的 method name 相等；或者匹配通配符\n\t\t\tif (mappedName.equals(m.getName()) || isMatch(m.getName(), mappedName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// 是否以 * 开头或结束并匹配\n\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) ||\n\t\t\t\t(mappedName.startsWith(\"*\") && methodName.endsWith(mappedName.substring(1, mappedName.length())));\n\t}\n\n}\n```\n\n#### RegexpMethodPointcutAdvisor\n\n> `RegexpMethodPointcutAdvisor` 是按照正则表达式匹配方法，能够精确定位到需要拦截的方法。\n\n```java\npublic class RegexpMethodPointcut extends StaticMethodMatcherPointcut implements ClassFilter { \n\n\tpublic boolean matches(Method m, Class targetClass) { \n\t\t// TODO use target class here?\n\t\t// 拼接表达式\n\t\tString patt = m.getDeclaringClass().getName() + \".\" + m.getName();\n\t\tfor (int i = 0; i < this.compiledPatterns.length; i++) {\n\t\t\t// 正则匹配\n\t\t\tboolean matched = this.matcher.matches(patt, this.compiledPatterns[i]);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Candidate is: '\" + patt + \"'; pattern is \" + this.compiledPatterns[i].getPattern() +\n\t\t\t\t             \"; matched=\" + matched);\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matches(Class clazz) {\n\t\t// TODO do with regexp\n\t\treturn true;\n\t}\n\t\n\tpublic ClassFilter getClassFilter() {\n\t\treturn this;\n\t}\n\n}\n```\n\n### 使用示例\n\n* xml 配置\n\n```xml\n<beans>\n\n    <bean id=\"userService\" class=\"org.springframework.aop.UserServiceImpl\" />\n    <bean id=\"demoService\" class=\"org.springframework.aop.DemoServiceImpl\" />\n\n    <bean id=\"userBeforeAdvice\" class=\"org.springframework.aop.UserBeforeAdvice\" />\n    <bean id=\"userAfterAdvice\" class=\"org.springframework.aop.UserAfterAdvice\" />\n\n    <!-- 按方法名称匹配 -->\n    <bean id=\"nameMatchMethodPointcutAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n        <property name=\"mappedNames\">\n            <!-- 匹配 save 开头的方法 -->\n            <value>save*</value>\n        </property>\n        <property name=\"advice\">\n            <ref bean=\"userBeforeAdvice\" />\n        </property>\n    </bean>\n\n    <bean id=\"regexpMethodPointcutAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\n        <property name=\"pattern\">\n            <!-- 匹配以 del 开头的方法 -->\n            <value>org.springframework.aop.*.del*.*</value>\n        </property>\n        <property name=\"advice\">\n            <ref bean=\"userAfterAdvice\" />\n        </property>\n    </bean>\n\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" />\n</beans>\n```\n\n* 测试\n\n```java\nClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/org/springframework/aop/aop.xml\");\n\nUserService userService = (UserService) ctx.getBean(\"userService\");\n\nuserService.saveUser();\n\nuserService.delUser();\n\nDemoService demoService = (DemoService) ctx.getBean(\"demoService\");\n\ndemoService.saveDemo();\n\ndemoService.delDemo();\n```\n\n* 测试结果\n\n```\ndo before advice ....\ndo save user ......\ndo del user ......\ndo after return advice ....\ndo before advice ....\ndo save demo ......\ndo del demo ......\ndo after return advice ....\n```\n\n> 从测试结果可以看出，通过配置不同 `Advisor` 匹配不同的 `Method` 采用相应的 `Advice` 进行处理。\n\n### 实现分析\n\n##### 类结构\n\n![](https://i.loli.net/2019/06/21/5d0c7e0357abb57342.png)\n\n从上图 `DefaultAdvisorAutoProxyCreator ` 类结构，我们知道其实现与 `BeanNameAutoProxyCreator` 类似；都是通过实现接口 `BeanPostProcessor` 在 bean 完成实例化后进行自动代理处理。\n\n##### 分析\n\n因 `DefaultAdvisorAutoProxyCreator` 和 `BeanNameAutoProxyCreator` 都继承了类 `AbstractAutoProxyCreator` ,所以从源码中我们可以发现二者都重写了方法 `getInterceptorsAndAdvisorsForBean` ，也就是在获取当前 bean 所匹配的 `Advisor` 逻辑不一样之外其他处理一致； 那么下面针对 `DefaultAdvisorAutoProxyCreator` 的实现我们主要看下方法 `getInterceptorsAndAdvisorsForBean` 的处理。\n\n```java\nprotected Object[] getInterceptorsAndAdvisorsForBean(Object bean, String name) {\n\t// 查找与当前 bean 匹配的 advisor\n\tList advices = findEligibleAdvisors(bean.getClass());\n\tif (advices.isEmpty()) {\n\t\treturn DO_NOT_PROXY;\n\t}\n\t// 对 advisor 集合排序\n\tadvices = sortAdvisors(advices);\n\treturn advices.toArray();\n}\n```\n\n* 查找匹配的 Advisor\n\n```java\nprotected List findEligibleAdvisors(Class clazz) {\n\t// 查找当前容器中所有定义的 advisor\n\tList candidateAdvice = findCandidateAdvisors();\n\tList eligibleAdvice = new LinkedList();\n\tfor (int i = 0; i < candidateAdvice.size(); i++) {\n\t\t// Sun, give me generics, please!\n\t\tAdvisor candidate = (Advisor) candidateAdvice.get(i);\n\t\t// 判断 bean 是否可以应用 advisor\n\t\tif (AopUtils.canApply(candidate, clazz, null)) {\n\t\t\t// 将 advisor 添加到匹配的集合中\n\t\t\teligibleAdvice.add(candidate);\n\t\t\tlogger.info(\"Candidate Advice [\" + candidate + \"] accepted for class [\" + clazz.getName() + \"]\");\n\t\t}\n\t\telse {\n\t\t\tlogger.info(\"Candidate Advice [\" + candidate + \"] rejected for class [\" + clazz.getName() + \"]\");\n\t\t}\n\t}\n\treturn eligibleAdvice;\n}\n```\n\n* 获取容器中所有的 Advisor\n\n```java\nprotected List findCandidateAdvisors() {\n\tif (!(getBeanFactory() instanceof ListableBeanFactory)) {\n\t\tthrow new IllegalStateException(\"Cannot use DefaultAdvisorAutoProxyCreator without a ListableBeanFactory\");\n\t}\n\tListableBeanFactory owningFactory = (ListableBeanFactory) getBeanFactory();\n\t// 从容器中查找所有 bean 定义 type 为 Advisor 的 bean name\n\tString[] adviceNames = BeanFactoryUtils.beanNamesIncludingAncestors(owningFactory, Advisor.class);\n\tList candidateAdvisors = new LinkedList();\n\tfor (int i = 0; i < adviceNames.length; i++) {\n\t\tString name = adviceNames[i];\n\t\tif (!this.usePrefix || name.startsWith(this.advisorBeanNamePrefix)) {\n\t\t\t// 获取 advisor 实例\n\t\t\tAdvisor advisor = (Advisor) owningFactory.getBean(name);\n\t\t\tcandidateAdvisors.add(advisor);\n\t\t}\n\t}\n\treturn candidateAdvisors;\n}\n```\n\n* 判断 bean 是否匹配 Advisor\n\n```java\npublic static boolean canApply(Advisor advisor, Class targetClass, Class[] proxyInterfaces) {\n\tif (advisor instanceof IntroductionAdvisor) {\n\t\treturn ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n\t}\n\telse if (advisor instanceof PointcutAdvisor) {\n\t\tPointcutAdvisor pca = (PointcutAdvisor) advisor;\n\t\t// 通过 advisor 的 pointcut 判断 bean 是否匹配\n\t\treturn canApply(pca.getPointcut(), targetClass, proxyInterfaces);\n\t}\n\telse {\n\t\t// It doesn't have a pointcut so we assume it applies\n\t\treturn true;\n\t}\n}\n\n\npublic static boolean canApply(Pointcut pc, Class targetClass, Class[] proxyInterfaces) {\n\t// 类是否匹配\n\tif (!pc.getClassFilter().matches(targetClass)) {\n\t\treturn false;\n\t}\n\t\n\t// 判断类中的 method 是否匹配\n\t// 获取类下所有的method\n\tMethod[] methods = targetClass.getMethods();\n\tfor (int i = 0; i < methods.length; i++) {\n\t\tMethod m = methods[i];\n\t\t// If we're looking only at interfaces and this method\n\t\t// isn't on any of them, skip it\n\t\tif (proxyInterfaces != null && !methodIsOnOneOfTheseInterfaces(m, proxyInterfaces)) {\n\t\t\tcontinue;\n\t\t}\n\t\t// 执行 pointcut 的 method match\n\t\tif (pc.getMethodMatcher().matches(m, targetClass))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n从 `DefaultAdvisorAutoProxyCreator` 的源码分析，可知其自动代理流程大概如下：\n\n* 从容器中获取所有 `Advisor` 实例\n* 匹配 bean 所支持的 `Advisor`\n* 采用 jdk 动态代理创建 bean 的代理对象\n\n## 小结\n\n从 `BeanNameAutoProxyCreator `, `DefaultAdvisorAutoProxyCreator` 二者的实现可以看出其相同点\n\n* 都是基于实现接口 `BeanPostProcessor` 的实现\n* 都是先获取当前 bean 所匹配的 `Advisor`，后在创建代理对象\n\n二者的不同点在于:\n\n* 前者是基于 bean name 判断是否判断，后者是通过 `Advisor` 内部的 `Ponitcut` 匹配判断\n* 前者的 `Advisor` 是用户配置的，后者是容器中所有匹配的 `Advisor` \n\n","tags":["Spring"]},{"title":"重拾-Spring-AOP","url":"/2019/03/02/重拾-Spring-AOP/","content":"## AOP 术语\n\n关于 AOP 的概念描述及相关术语可以参考 [彻底征服 Spring AOP 之 理论篇](https://segmentfault.com/a/1190000007469968#articleHeader5) 总结的很好； 本文将着重分析下 AOP 的实现过程。\n\n<!-- more -->\n\n## 使用示例\n\n### 定义接口\n\n```java\npublic interface UserService {\n    void say ();\n}\n```\n\n接口实现类如下：\n\n```java\npublic class UserServiceImpl implements UserService {\n    public void say() {\n        System.out.println(\"do say method\");\n    }\n}\n```\n\n### 定义通知\n\n```java\npublic class UserAdvice implements MethodBeforeAdvice {\n\n    public void before(Method m, Object[] args, Object target) throws Throwable {\n        System.out.println(\"do before advice ....\");\n    }\n}\n```\n\n### 配置 AOP\n\n```xml\n<beans>\n\t<!-- 配置接口实现类 -->\n    <bean id=\"userService\" class=\"org.springframework.aop.UserServiceImpl\" />\n\n    <!-- 配置通知类 -->\n    <bean id=\"userAdvice\" class=\"org.springframework.aop.UserAdvice\" />\n\n    <!--代理类-->\n    <bean id=\"userProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n        <!--要代理的接口 创建代理对象时需要-->\n        <!-- 配置该属性会采用 jdk 动态代理，反之采用 cglib -->\n        <property name=\"proxyInterfaces\">\n            <value>org.springframework.aop.UserService</value>\n        </property>\n        <!--拦截器名字，也就是我们定义的通知类，可配置多个通知类 -->\n        <property name=\"interceptorNames\">\n            <list>\n                <value>userAdvice</value>\n            </list>\n        </property>\n        <!--目标类，就是我们业务的实现类-->\n        <property name=\"target\">\n            <ref bean=\"userService\"/>\n        </property>\n    </bean>\n</beans>\n```\n\n### 测试\n\n```java\nClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/org/springframework/aop/aop.xml\");\n\nUserService userService = (UserService) ctx.getBean(\"userProxy\");\n\nuserService.say();\n```\n\n执行结果如下：\n\n```\ndo before advice ....\ndo say method\n```\n\n从执行结果来看，前置通知对接口方法已经起增强作用。 下面我们将看下 Spring AOP 的具体实现。\n\n## 实现分析\n\n> 从上面的示例可以看出 Spring AOP 的配置主要基于类 `ProxyFactoryBean` ，那么我们就以此为入口去剖析其实现。\n\n### ProxyFactoryBean 类结构\n\n![](https://i.loli.net/2019/06/21/5d0c7e056368858871.png)\n\n### 创建切面链\n\n从 `ProxyFactoryBean` 的类结构，我们发现其实现了接口 `BeanFactoryAware`，也就说明在其实例化过程中会调用方法 `setBeanFactory`; 源码如下：\n\n```java\npublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t// 设置 beanFactory\n\tthis.beanFactory = beanFactory;\n\tlogger.debug(\"Set BeanFactory. Will configure interceptor beans...\");\n\t// 创建 advisor chain\n\tcreateAdvisorChain();\n\tlogger.info(\"ProxyFactoryBean config: \" + this);\n\tif (singleton) {\n\t\t// Eagerly initialize the shared singleton instance\n\t\tgetSingletonInstance();\n\t\t// We must listen to superclass advice change events to recache singleton\n\t\t// instance if necessary\n\t\taddListener(this);\n\t}\n}\n```\n\n在 `setBeanFactory` 方法中除了设置 `beanFactory` , 还有一个重要的动作就是 `createAdvisorChain` 创建 advisor chain (也可以理解为就是切面链)。 那么下面我们将看下具体是怎样创建 advisor chain 的。\n\n\n```java\nprivate void createAdvisorChain() throws AopConfigException, BeansException {\n\t// 检测是否配置了 interceptorNames, 也就是是否配置相关 advice 通知； 若没有配置直接返回\n\tif (this.interceptorNames == null || this.interceptorNames.length == 0) {\n\t\t//throw new AopConfigException(\"Interceptor names are required\");\n\t\treturn;\n\t}\n\t\n\t// Globals can't be last\n\tif (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX)) {\n\t\tthrow new AopConfigException(\"Target required after globals\");\n\t}\n\n\t// Materialize interceptor chain from bean names\n\tfor (int i = 0; i < this.interceptorNames.length; i++) {\n\t\tString name = this.interceptorNames[i];\n\t\tlogger.debug(\"Configuring interceptor '\" + name + \"'\");\n\t\t// 判断 interceptor name 是否以 * 结尾\n\t\tif (name.endsWith(GLOBAL_SUFFIX)) {\n\t\t\tif (!(this.beanFactory instanceof ListableBeanFactory)) {\n\t\t\t\tthrow new AopConfigException(\"Can only use global advisors or interceptors with a ListableBeanFactory\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddGlobalAdvisor((ListableBeanFactory) this.beanFactory,\n\t\t\t\t                 name.substring(0, name.length() - GLOBAL_SUFFIX.length()));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// add a named interceptor\n\t\t\t// 获取 advice bean\n\t\t\tObject advice = this.beanFactory.getBean(this.interceptorNames[i]);\n\t\t\t// 将 advisor 加入到链表中\n\t\t\taddAdvisor(advice, this.interceptorNames[i]);\n\t\t}\n\t}\n}\n```\n\n```java\nprivate void addAdvisor(Object next, String name) {\n\tlogger.debug(\"Adding advisor or TargetSource [\" + next + \"] with name [\" + name + \"]\");\n\t// We need to add a method pointcut so that our source reference matches\n\t// what we find from superclass interceptors.\n\t// 查找 advice 通知匹配的 pointcut, 并创建一个 advisor\n\tObject advisor = namedBeanToAdvisorOrTargetSource(next);\n\tif (advisor instanceof Advisor) {\n\t\t// if it wasn't just updating the TargetSource\n\t\tlogger.debug(\"Adding advisor with name [\" + name + \"]\");\n\t\taddAdvisor((Advisor) advisor);\n\t\tthis.sourceMap.put(advisor, name);\n\t}\n\telse {\n\t\tlogger.debug(\"Adding TargetSource [\" + advisor + \"] with name [\" + name + \"]\");\n\t\tsetTargetSource((TargetSource) advisor);\n\t\t// save target name\n\t\tthis.targetName = name;\n\t}\n}\n```\n\n从 `addAdvisor` 方法可以看到，在添加 advisor 前，需要先创建 advisor , 会调用方法 `namedBeanToAdvisorOrTargetSource`\n\n```java\nprivate Object namedBeanToAdvisorOrTargetSource(Object next) {\n\ttry {\n\t\t// 将 advice 包装成一个 advisor\n\t\tAdvisor adv = GlobalAdvisorAdapterRegistry.getInstance().wrap(next);\n\t\treturn adv;\n\t}\n\tcatch (UnknownAdviceTypeException ex) {\n\t\t\n\t}\n}\n```\n\n`namedBeanToAdvisorOrTargetSource` 方法会调用单例模式的 `GlobalAdvisorAdapterRegistry` 的方法 `wrap` 将 advice 包装成一个 advisor;\n在查看 `wrap` 的实现之前，我们可以先看下 `GlobalAdvisorAdapterRegistry` 是做什么的。\n\n```java\npublic class GlobalAdvisorAdapterRegistry extends DefaultAdvisorAdapterRegistry {\n\t\n\tprivate static GlobalAdvisorAdapterRegistry instance = new GlobalAdvisorAdapterRegistry();\n\t\n\tpublic static GlobalAdvisorAdapterRegistry getInstance() {\n\t\treturn instance;\n\t}\n\n\tprivate GlobalAdvisorAdapterRegistry() {\n\t}\t\n}\n\npublic class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry {\n\t\n\tprivate List adapters = new LinkedList();\n\t\n\tpublic DefaultAdvisorAdapterRegistry() {\n\t\t// register well-known adapters\n\t\tregisterAdvisorAdapter(new BeforeAdviceAdapter());\n\t\tregisterAdvisorAdapter(new AfterReturningAdviceAdapter());\n\t\tregisterAdvisorAdapter(new ThrowsAdviceAdapter());\n\t}\n}\n```\n\n从上面 `GlobalAdvisorAdapterRegistry` 的实现可以看出其采用了单例模式并继承了类 `DefaultAdvisorAdapterRegistry` 在构造的过程中内置了 3 种 advice adapter 用于匹配 advice 。 下面我们在看下它是如何 `wrap` 包装 advice 的。\n\n```java\npublic Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {\n\tif (adviceObject instanceof Advisor) {\n\t\treturn (Advisor) adviceObject;\n\t}\n\t\n\tif (!(adviceObject instanceof Advice)) {\n\t\tthrow new UnknownAdviceTypeException(adviceObject);\n\t}\n\tAdvice advice = (Advice) adviceObject;\n\t\n\tif (advice instanceof Interceptor) {\n\t\t// So well-known it doesn't even need an adapter\n\t\treturn new DefaultPointcutAdvisor(advice);\n\t}\n\n\t// 遍历内置的 advice adapters\n\tfor (int i = 0; i < this.adapters.size(); i++) {\n\t\t// Check that it is supported\n\t\tAdvisorAdapter adapter = (AdvisorAdapter) this.adapters.get(i);\n\t\t// 判断当前 adapter 是否支付当前 advice\n\t\tif (adapter.supportsAdvice(advice)) {\n\t\t\t// 如果支持的话，返回一个 DefaultPointcutAdvisor\n\t\t\treturn new DefaultPointcutAdvisor(advice);\n\t\t}\n\t}\n\tthrow new UnknownAdviceTypeException(advice);\n}\n```\n\n从 `wrap` 的实现可以发现，若 advice 匹配了某个 adapter 将会创建一个 `DefaultPointcutAdvisor` 实例并返回；\n\n```java\npublic class DefaultPointcutAdvisor implements PointcutAdvisor, Ordered {\n\n\tprivate int order = Integer.MAX_VALUE;\n\n\tprivate Pointcut pointcut;\n\t\n\tprivate Advice advice;\n\t\n\tpublic DefaultPointcutAdvisor() {\n\t}\n\t\n\tpublic DefaultPointcutAdvisor(Advice advice) {\n\t\tthis(Pointcut.TRUE, advice);\n\t}\n\t\n\tpublic DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) {\n\t\tthis.pointcut = pointcut;\n\t\tthis.advice = advice;\n\t}\n}\n\n/**\n * Canonical instance that matches everything.\n * 默认匹配所有的类及类下的所有方法\n */\nPointcut TRUE = new Pointcut() {\n\n\tpublic ClassFilter getClassFilter() {\n\t\treturn ClassFilter.TRUE;\n\t}\n\n\tpublic MethodMatcher getMethodMatcher() {\n\t\treturn MethodMatcher.TRUE;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Pointcut.TRUE\";\n\t}\n};\n```\n从 `DefaultPointcutAdvisor` 的实例可以看出创建 advisor (切面) 的过程实际就是将 advice (通知) 和 pointcut (切入点) 绑定的过程；同时在 Spring AOP 默认的 pointcut 是拦截所有类下的所有方法。\n\n> 简单点说也就是当前切面将会拦截哪些类下的哪些方法，拦截过程中会采用哪些增强处理（前置通知，返回通知，异常通知）。\n\n至此 advisor chain 的创建流程结束，其过程大概如下：\n\n* 遍历 interceptor names (也就是 advice 通知)\n* 获取 advice bean\n* 判断 advice 是否匹配内置的 advisorAdapter, 匹配的话则创建 DefaultPointcutAdvisor (默认拦截所有类所有方法) 加入到链表中\n\n### 创建目标代理对象\n\n从 `ProxyFactoryBean` 类的名字及类结构，发现其实现接口 `FactoryBean`, 也就是说当其 `getBean` 的时候会调用方法 `getObject`, 源码如下：\n\n```java\npublic Object getObject() throws BeansException {\n\t// 默认单例\n\treturn (this.singleton) ? getSingletonInstance() : newPrototypeInstance();\n}\n\nprivate Object getSingletonInstance() {\n\tif (this.singletonInstance == null) {\n\t\t// This object can configure the proxy directly if it's\n\t\t// being used as a singleton.\n\t\tthis.singletonInstance = createAopProxy().getProxy();\n\t}\n\treturn this.singletonInstance;\n}\n\nprotected synchronized AopProxy createAopProxy() {\n\tif (!isActive) {\n\t\tactivate();\n\t}\n\t\n\treturn getAopProxyFactory().createAopProxy(this);\n}\n```\n\n```java\npublic AopProxy createAopProxy(AdvisedSupport advisedSupport) throws AopConfigException {\n\t// 是否采用 cglib 代理\n\tboolean useCglib = advisedSupport.getOptimize() || advisedSupport.getProxyTargetClass() || advisedSupport.getProxiedInterfaces().length == 0;\n\tif (useCglib) {\n\t\treturn CglibProxyFactory.createCglibProxy(advisedSupport);\n\t}\n\telse {\n\t\t// Depends on whether we have expose proxy or frozen or static ts\n\t\treturn new JdkDynamicAopProxy(advisedSupport);\n\t}\n}\n```\n\n```java\npublic Object getProxy(ClassLoader cl) {\n\tlogger.debug(\"Creating JDK dynamic proxy\");\n\tClass[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);\n\treturn Proxy.newProxyInstance(cl, proxiedInterfaces, this);\n}\n```\n\n> `ProxyFactoryBean` 通过判断 proxyTargetClass , interfaceNames 的配置去选择采用 cglib 或者 jdk 来创建目标代理对象。\n\n### 目标代理对象执行\n\n上面简单介绍了代理对象的创建，那么在看下当我们调用目标方法的时候，代理是如何执行的，以 jdk 动态代理为例：\n\n```java\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\n\tMethodInvocation invocation = null;\n\tObject oldProxy = null;\n\tboolean setProxyContext = false;\n\n\tTargetSource targetSource = advised.targetSource;\n\tClass targetClass = null;\n\tObject target = null;\t\t\n\t\n\ttry {\n\t\t// Try special rules for equals() method and implementation of the\n\t\t// Advised AOP configuration interface\n\t\t\n\t\t// Short-circuit expensive Method.equals() call, as Object.equals() isn't overloaded\n\t\tif (method.getDeclaringClass() == Object.class && \"equals\".equals(method.getName())) {\n\t\t\t// What if equals throws exception!?\n\n\t\t\t// This class implements the equals() method itself\n\t\t\treturn new Boolean(equals(args[0]));\n\t\t}\n\t\telse if (Advised.class == method.getDeclaringClass()) {\n\t\t\t// Service invocations on ProxyConfig with the proxy config\n\t\t\treturn AopProxyUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n\t\t}\n\t\t\n\t\tObject retVal = null;\n\t\t\n\t\t// May be null. Get as late as possible to minimize the time we \"own\" the target,\n\t\t// in case it comes from a pool.\n\t\t// 目标实现类\n\t\ttarget = targetSource.getTarget();\n\t\tif (target != null) {\n\t\t\ttargetClass = target.getClass();\n\t\t}\n\t\t\n\t\tif (this.advised.exposeProxy) {\n\t\t\t// Make invocation available if necessary\n\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\tsetProxyContext = true;\n\t\t}\n\t\n\t\t// Get the interception chain for this method\n\t\t// 获取目标类，执行方法的 interception chain\n\t\tList chain = this.advised.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\tthis.advised, proxy, method, targetClass);\n\t\t\n\t\t// Check whether we have any advice. If we don't, we can fallback on\n\t\t// direct reflective invocation of the target, and avoid creating a MethodInvocation\n\t\tif (chain.isEmpty()) {\n\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly\n\t\t\t// Note that the final invoker must be an InvokerInterceptor so we know it does\n\t\t\t// nothing but a reflective operation on the target, and no hot swapping or fancy proxying\n\t\t\tretVal = AopProxyUtils.invokeJoinpointUsingReflection(target, method, args);\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tinvocation = new ReflectiveMethodInvocation(proxy, target,\n\t\t\t\t\t\t\t\tmethod, args, targetClass, chain);\n\t\t\t\t\t\t\t\t\t\n\t\t\t// Proceed to the joinpoint through the interceptor chain\n\t\t\t// 方法调用\n\t\t\tretVal = invocation.proceed();\n\t\t}\n\t\t\n\t\t// Massage return value if necessary\n\t\tif (retVal != null && retVal == target) {\n\t\t\tretVal = proxy;\n\t\t}\n\t\treturn retVal;\n\t}\n\tfinally {\n\t}\n}\n\n```\n\n首先我们看下如何获取匹配当前 method 的拦截器, 参考 `calculateInterceptorsAndDynamicInterceptionAdvice` 的实现如下：\n\n```java\npublic static List calculateInterceptorsAndDynamicInterceptionAdvice(Advised config, Object proxy, Method method, Class targetClass) {\n\t// 用于存储拦截器\n\tList interceptors = new ArrayList(config.getAdvisors().length);\n\t// 遍历 advisor (切面)\n\tfor (int i = 0; i < config.getAdvisors().length; i++) {\n\t\tAdvisor advisor = config.getAdvisors()[i];\n\t\tif (advisor instanceof PointcutAdvisor) {\n\t\t\t// Add it conditionally\n\t\t\tPointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;\n\t\t\t// 判断当前 target class 是否当前 pointcut\n\t\t\tif (pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) {\n\t\t\t\t// 获取 advisor 对应的 method interceptor \n\t\t\t\tMethodInterceptor interceptor = (MethodInterceptor) GlobalAdvisorAdapterRegistry.getInstance().getInterceptor(advisor);\n\t\t\t\tMethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n\t\t\t\t// 判断当前 method 是否匹配 pointcut\n\t\t\t\tif (mm.matches(method, targetClass)) {\n\t\t\t\t\tif (mm.isRuntime()) {\n\t\t\t\t\t\t// Creating a new object instance in the getInterceptor() method\n\t\t\t\t\t\t// isn't a problem as we normally cache created chains\n\t\t\t\t\t\tinterceptors.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm) );\n\t\t\t\t\t}\n\t\t\t\t\telse {\t\t\t\t\t\t\t\n\t\t\t\t\t\t// 将拦截器加入链表中\n\t\t\t\t\t\tinterceptors.add(interceptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (advisor instanceof IntroductionAdvisor) {\n\t\t\tIntroductionAdvisor ia = (IntroductionAdvisor) advisor;\n\t\t\tif (ia.getClassFilter().matches(targetClass)) {\n\t\t\t\tMethodInterceptor interceptor = (MethodInterceptor) GlobalAdvisorAdapterRegistry.getInstance().getInterceptor(advisor);\n\t\t\t\tinterceptors.add(interceptor);\n\t\t\t}\n\t\t}\n\t}\t// for\n\treturn interceptors;\n}\t// calculateInterceptorsAndDynamicInterceptionAdvice\n\n```\n\n我们在详细看下如何查找 advisor 匹配的拦截器呢，同样与上文中 `wrap` 类似，如下：\n\n```java\npublic Interceptor getInterceptor(Advisor advisor) throws UnknownAdviceTypeException {\n\tAdvice advice = advisor.getAdvice();\n\tif (advice instanceof Interceptor) {\n\t\treturn (Interceptor) advice;\n\t}\n\n\t// 遍历内置的 advisor adapter\n\tfor (int i = 0; i < this.adapters.size(); i++) {\n\t\tAdvisorAdapter adapter = (AdvisorAdapter) this.adapters.get(i);\n\t\t// 是否匹配当前 advice\n\t\tif (adapter.supportsAdvice(advice)) {\n\t\t\t// 匹配的话返回 interceptor\n\t\t\treturn adapter.getInterceptor(advisor);\n\t\t}\n\t}\n\tthrow new UnknownAdviceTypeException(advisor.getAdvice());\n}\n```\n\n到目前为止，我们多次发现 `AdvisorAdapter` 的身影，下面我们看下其具体的实现, 以 `BeforeAdviceAdapter` 为例：\n\n```java\nclass BeforeAdviceAdapter implements AdvisorAdapter {\n\n\t/**\n\t * @see org.springframework.aop.framework.adapter.AdvisorAdapter#supportsAdvice(java.lang.Object)\n\t */\n\tpublic boolean supportsAdvice(Advice advice) {\n\t\t// 匹配 MethodBeforeAdvice\n\t\treturn advice instanceof MethodBeforeAdvice;\n\t}\n\n\t/**\n\t * @see org.springframework.aop.framework.adapter.AdvisorAdapter#getInterceptor(org.springframework.aop.Advisor)\n\t */\n\tpublic Interceptor getInterceptor(Advisor advisor) {\n\t\tMethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();\n\t\t// 返回 MethodBeforeAdviceInterceptor\n\t\treturn new MethodBeforeAdviceInterceptor(advice) ;\n\t}\n\n}\n```\n\n> 通过 `AdvisorAdapter` 很巧妙的将 Advice 和 Interceptor 结合起来，同时也会发现二者关系是一一对应的\n\n下面在看下方法的真正调用过程, 由 `ReflectiveMethodInvocation` 的方法 `proceed` 实现：\n\n```java\npublic Object proceed() throws Throwable {\n\t//\tWe start with an index of -1 and increment early\n\t// 当执行到最后一个拦截器的时候将会调用目标方法\n\tif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n\t\treturn invokeJoinpoint();\n\t}\n\n\t// 获取下一个拦截器\n\tObject interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n\tif (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n\t\t// Evaluate dynamic method matcher here: static part will already have\n\t\t// been evaluated and found to match\n\t\tInterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n\t\tif (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n\t\t\treturn dm.interceptor.invoke(this);\n\t\t}\n\t\telse {\n\t\t\t// Dynamic matching failed\n\t\t\t// Skip this interceptor and invoke the next in the chain\n\t\t\treturn proceed();\n\t\t}\n\t}\n\telse {\n\t\t// It's an interceptor so we just invoke it: the pointcut will have\n\t\t// been evaluated statically before this object was constructed\n\t\t// 执行拦截器\n\t\treturn ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n\t}\n}\n```\n\n下面具体看下 `MethodInterceptor` 的实现，分别是前置通知，返回通知，异常通知\n\n```java\npublic Object invoke(MethodInvocation mi) throws Throwable {\n\t// 目标方法前执行\n\tadvice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );\n\treturn mi.proceed();\n}\n\npublic Object invoke(MethodInvocation mi) throws Throwable {\n\t// 先执行目标方法\n\tObject retval = mi.proceed();\n\t// 后置处理\n\tadvice.afterReturning(retval, mi.getMethod(), mi.getArguments(), mi.getThis() );\n\treturn retval;\n}\n\npublic Object invoke(MethodInvocation mi) throws Throwable {\n\ttry {\n\t\t// 执行目标方法\n\t\treturn mi.proceed();\n\t}\n\tcatch (Throwable t) {\n\t\t// 异常处理\n\t\tMethod handlerMethod = getExceptionHandler(t);\n\t\tif (handlerMethod != null) {\n\t\t\tinvokeHandlerMethod(mi, t, handlerMethod);\n\t\t}\n\t\tthrow t;\n\t}\n}\n```\n\n至此 Spring AOP 代理对象的执行过程处理结束，其流程可大概总结如下：\n\n* 获取当前目标方法的 interceptor chain\n\t1. 遍历 advisor ，判断当前目标类和目标方法是否匹配 advisor 对应的 ponitcut\n\t2. 通过匹配的 advisor 对应的 advice 匹配对应的 advisorAdapter , 进而获取对应的 methodInterceptor\n* 执行拦截器\n* 执行目标方法\n\n## 小结\n\nSpring AOP 中的对象关系小结下：\n\n* Advisor : 翻译是顾问，简单理解其就是一个 Aspect (切面); 其内部绑定了对应的 Pointcut(切入点) 和 Advice(通知)。\n* Advisor Chain ： 切面链，是一系列的切面的集合。\n* Advice : 通知，是对拦截方法的增强处理；在 1.0 版本中包含 BeforeAdivce, AfterReturningAdvice, ThrowsAdvice; 其面向的是用户。\n* MethodInterceptor : 方法拦截器，是 Advice 的执行者; 与 Advice 是一一对应的。\n* AdvisorAdapter : Advice 的适配器，是 Advice 和 MethodInterceptor 匹配的纽带。\n* AdvisorAdapterRegistry : 是 AdvisorAdapter 的注册中心，内置了 BeforeAdviceAdapter, AfterReturnAdviceAdapter, ThrowsAdviceAdapter； 用来将 Advice wrap 成一个 Advisor 并提供获取 Advice 对应的 MethodInterceptor。\n\n### 坑\n\n当我们自定义 Advice 时，可不可以同时支持多种 Advice 呢 ？ 譬如：\n\n```java\npublic class UserAdvice implements MethodBeforeAdvice, AfterReturningAdvice {\n\n    public void before(Method m, Object[] args, Object target) throws Throwable {\n        System.out.println(\"do before advice ....\");\n    }\n\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\n        System.out.println(\"do after returning ....\");\n    }\n}\n```\n\n那么当测试后，您会发现只有 before 调用了，而 afterReturning 未调用了；这是为什么呢 ? (好好看源码额)\n\n\n\n\n","tags":["Spring"]},{"title":"LeetCode-数组-删除元素","url":"/2019/03/01/LeetCode-数组-删除元素/","content":"\n## 题目描述\n\n给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n<!-- more -->\n\n## 解题思路\n\n> 本题解题思路与上一篇的`删除有序数组重复元素`类似，如下所示：\n\n* 设定左右指针 i, j，变量 count 用于计数\n* 指针 i 从左向右移动，判断元素是否等于 val；当于 val 相等时 count--, 并移动指针 j，当于 val 不等时指针 i 继续向右移动\n* 当指针 j 移动时，判断元素是否等于 val； 当于 val 相等时 count-- 继续移动指针 j, 当不等时互换 i, j 元素并继续移动指针 i\n* 当指针 i，j 交汇时完成退出轮询 \n\n可见如下图示：\n\n![](https://i.loli.net/2019/06/21/5d0c7da49c65597832.gif)\n\n## 实现\n\n```java\npublic int removeElement(int[] nums, int val) {\n    int i = 0, count = nums.length, j = count;\n\n    while (true) {\n        while (i < j) {\n            if (nums[i] == val) {\n                count--;\n                break;\n            } else {\n                if (i + 1 == j) {\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        while (j > i) {\n            j--;\n\n            if (j == i) {\n                break;\n            }\n\n            if (nums[j] == val) {\n                count--;\n            } else {\n                nums[i] = nums[j];\n                i++;\n                break;\n            }\n        }\n\n        if (i >= j) {\n            break;\n        }\n\n    }\n\n    return count;\n}\n```\n","tags":["LeetCode"]},{"title":"重拾-Spring IOC","url":"/2019/02/27/重拾-Spring-IOC/","content":"\n## 为何重拾\n\n使用了 Spring 多年，但是对其底层的一些实现还是一知半解，一些概念比较模糊；故决定重新拾起，加深对 Spring 的认识。\n\n<!-- more -->\n\n## 重拾计划\n\n### spring 版本说明\n\nSpring 在经过多年的演进过程中，其功能越来越丰富，组件越来越多；为了避免在阅读源码的过程中深陷泥潭中，决定采用最原始的版本 1.0； 但又不局限于 1.0 版本。\n\n### spring ioc\n\n### spring aop\n\n### spring 事务管理\n\n### spring orm 集成\n\n\n\n## 实现分析\n\n### Spring 容器启动\n\n> 在本文中，通过常用的构造 `ClassPathXmlApplicationContext` 实例来作为对 Spring 实现分析的入口 \n\n```java\n\tClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n```\n\n通过调用链追踪，Spring 容器启动核心操作由 `AbstractApplicationContext` 类中 `refresh` 方法实现\n\n```java\npublic void refresh() throws BeansException {\n\tthis.startupTime = System.currentTimeMillis();\n\n\t// tell subclass to refresh the internal bean factory\n\t// 完成 xml 配置文件的解析， 解析 bean 标签生成 BeanDefinition 对象，并注册到 BeanFactory\n\trefreshBeanFactory();\n\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\n\t// configure the bean factory with context semantics\n\tbeanFactory.registerCustomEditor(Resource.class, new ContextResourceEditor(this));\n\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\tbeanFactory.ignoreDependencyType(ResourceLoader.class);\n\tbeanFactory.ignoreDependencyType(ApplicationContext.class);\n\tpostProcessBeanFactory(beanFactory);\n\n\t// invoke factory processors registered with the context instance\n\t// 获取内置 BeanFactoryPostProcessor 实例，并遍历调用 postProcessBeanFactory 方法\n\t// 对 BeanFactory 进行后置处理\n\tfor (Iterator it = getBeanFactoryPostProcessors().iterator(); it.hasNext();) {\n\t\tBeanFactoryPostProcessor factoryProcessor = (BeanFactoryPostProcessor) it.next();\n\t\tfactoryProcessor.postProcessBeanFactory(beanFactory);\n\t}\n\n\tif (getBeanDefinitionCount() == 0) {\n\t\tlogger.warn(\"No beans defined in ApplicationContext [\" + getDisplayName() + \"]\");\n\t}\n\telse {\n\t\tlogger.info(getBeanDefinitionCount() + \" beans defined in ApplicationContext [\" + getDisplayName() + \"]\");\n\t}\n\n\t// invoke factory processors registered as beans in the context\n\t// 从 Bean Definition 集合中查找 BeanFactoryPostProcessor 定义并实例化\n\t// 获取 BeanFactoryPostProcessor 实例，并遍历调用 postProcessBeanFactory 方法\n\t// 对 BeanFactory 进行后置处理\n\tinvokeBeanFactoryPostProcessors();\n\n\t// register bean processor that intercept bean creation\n\t// 从 Bean Definition 集合中查找 BeanPostProcessor 类定义实例化并注册到 BeanFactory 中\n\tregisterBeanPostProcessors();\n\n\t// initialize message source for this context\n\tinitMessageSource();\n\n\t// initialize other special beans in specific context subclasses\n\tonRefresh();\n\n\t// check for listener beans and register them\n\trefreshListeners();\n\n\t// instantiate singletons this late to allow them to access the message source\n\t// 对 Bean Definition 中单例且非延迟加载的类型进行实例化\n\t/**\n\t * bean 初始化过程如下:\n\t * 1 : bean 构造初始化\n\t * 2 : bean 属性注入 (通过 bean definition 中的 property , autowire(byType, byName) 实现)\n\t * 3 : bean 若实现 BeanNameAware 接口，调用 setBeanName() 方法\n\t * 4 : bean 若实现 BeanFactoryAware 接口, 调用 setBeanFactory() 方法\n\t * 5 : 遍历调用 BeanFactory 中注册的 BeanPostProcessor 实例的 postProcessorBeforeInitialization() 方法\n\t * 6 : bean 若实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n\t * 7 : bean 实例对应的 bean definition 中若定义了 init-method 属性则调用对应的 init 方法\n\t * 8 : 遍历调用 BeanFactory 中注册的 BeanPostProcessor 实例的 postProcessorAfterInitialization() 方法\n\t */\n\tbeanFactory.preInstantiateSingletons();\n\n\t// last step: publish respective event\n\tpublishEvent(new ContextRefreshedEvent(this));\n}\n```\n\n从源码中可知，Spring 容器在启动过程中，主要完成以下流程 ：\n\n* 通过加载指定的配置文件，完成 Bean Definition 解析并注册到 BeanFactory 实例中\n* 通过内置及应用自定义的 BeanFactoryPostProcessor 对 BeanFactory 实例进行后置处理\n* 实例化应用自定义的 BeanPostProcessor 并注册到 BeanFactory 实例中\n* 实例化 Spring 容器中的 Bean\n\n### Spring 容器关闭\n\n```java\npublic void close() {\n\tlogger.info(\"Closing application context [\" + getDisplayName() + \"]\");\n\n\t// destroy all cached singletons in this context,\n\t// invoking DisposableBean.destroy and/or \"destroy-method\"\n\t// 销毁容器中缓存的单例对象实例\n\t// 执行容器中 DisposableBean 的 destroy 方法\n\tgetBeanFactory().destroySingletons();\n\n\t// publish respective event\n\t// 发送 spring 上下文关闭事件\n\tpublishEvent(new ContextClosedEvent(this));\n}\n```\n\n通过调用链追踪，Spring 会遍历容器中缓存的 bean 实例调用 destroyBean 方法。\n\n```java\nprotected void destroyBean(String beanName, Object bean) {\n\tlogger.debug(\"Retrieving depending beans for bean '\" + beanName + \"'\");\n\t// 先销毁所有依赖当前 bean 的实例\n\tString[] dependingBeans = getDependingBeanNames(beanName);\n\tif (dependingBeans != null) {\n\t\tfor (int i = 0; i < dependingBeans.length; i++) {\n\t\t\tdestroySingleton(dependingBeans[i]);\n\t\t}\n\t}\n\n\tif (bean instanceof DisposableBean) {\n\t\t// 如果 bean 实现了 DisposableBean 接口，将会执行 destroy 方法\n\t\tlogger.debug(\"Calling destroy() on bean with name '\" + beanName + \"'\");\n\t\ttry {\n\t\t\t((DisposableBean) bean).destroy();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"destroy() on bean with name '\" + beanName + \"' threw an exception\", ex);\n\t\t}\n\t}\n\n\ttry {\n\t\tRootBeanDefinition bd = getMergedBeanDefinition(beanName, false);\n\t\tif (bd.getDestroyMethodName() != null) {\n\t\t\t// 如果 bean 定义了 destroy-method 属性，将会调用自定义的销毁方法\n\t\t\tlogger.debug(\"Calling custom destroy method '\" + bd.getDestroyMethodName() +\n\t\t\t\t\t\t\t\t\t \"' on bean with name '\" + beanName + \"'\");\n\t\t\tinvokeCustomDestroyMethod(beanName, bean, bd.getDestroyMethodName());\n\t\t}\n\t}\n\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t// ignore, from manually registered singleton\n\t}\n}\n```\n\n> 下面将针对 Spring Bean 在容器启动过程中的各个环节的实现进行详细说明\n\n### Spring Bean 定义解析\n\n通过对 `refreshBeanFactory` 方法的调用链追踪，可以看到在 `DefaultXmlBeanDefinitonParser` 类的 `registerBeanDefinitions` 方法中实现对 Spring Bean 定义的解析及注册。 \n\n```java\npublic void registerBeanDefinitions(BeanDefinitionRegistry beanFactory, ClassLoader beanClassLoader,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tDocument doc, Resource resource) {\n\tthis.beanFactory = beanFactory;\n\tthis.beanClassLoader = beanClassLoader;\n\tthis.resource = resource;\n\n\tlogger.debug(\"Loading bean definitions\");\n\tElement root = doc.getDocumentElement();\n\n\tthis.defaultLazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);\n\tlogger.debug(\"Default lazy init '\" + this.defaultLazyInit + \"'\");\n\tthis.defaultDependencyCheck = root.getAttribute(DEFAULT_DEPENDENCY_CHECK_ATTRIBUTE);\n\tlogger.debug(\"Default dependency check '\" + this.defaultDependencyCheck + \"'\");\n\tthis.defaultAutowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);\n\tlogger.debug(\"Default autowire '\" + this.defaultAutowire + \"'\");\n\n\tNodeList nl = root.getChildNodes();\n\tint beanDefinitionCounter = 0;\n\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\tNode node = nl.item(i);\n\t\tif (node instanceof Element && BEAN_ELEMENT.equals(node.getNodeName())) {\n\t\t\tbeanDefinitionCounter++;\n\t\t\tloadBeanDefinition((Element) node);\n\t\t}\n\t}\n\tlogger.debug(\"Found \" + beanDefinitionCounter + \" <\" + BEAN_ELEMENT + \"> elements defining beans\");\n}\n```\n\n```java\nprotected void loadBeanDefinition(Element ele) {\n\t// 获取 bean 的 id, name 属性\n\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\tList aliases = new ArrayList();\n\tif (nameAttr != null && !\"\".equals(nameAttr)) {\n\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS, true, true);\n\t\taliases.addAll(Arrays.asList(nameArr));\n\t}\n\n\tif (id == null || \"\".equals(id) && !aliases.isEmpty()) {\n\t\tid = (String) aliases.remove(0);\n\t\tlogger.debug(\"No XML 'id' specified - using '\" + id + \"' as ID and \" + aliases + \" as aliases\");\n\t}\n\n\t// 解析 bean 标签, 获取 bean 配置的属性，构造，是否懒加载 作用域\n\tAbstractBeanDefinition beanDefinition = parseBeanDefinition(ele, id);\n\n\tif (id == null || \"\".equals(id)) {\n\t\tif (beanDefinition instanceof RootBeanDefinition) {\n\t\t\tid = ((RootBeanDefinition) beanDefinition).getBeanClassName();\n\t\t\tlogger.debug(\"Neither XML 'id' nor 'name' specified - using bean class name [\" + id + \"] as ID\");\n\t\t}\n\t\telse {\n\t\t\tthrow new BeanDefinitionStoreException(this.resource, \"\",\"Child bean definition has neither 'id' nor 'name'\");\n\t\t}\n\t}\n\n\tlogger.debug(\"Registering bean definition with id '\" + id + \"'\");\n\t// 将 bean definiton 注册到 beanFactory\n\tthis.beanFactory.registerBeanDefinition(id, beanDefinition);\n\tfor (Iterator it = aliases.iterator(); it.hasNext();) {\n\t\tthis.beanFactory.registerAlias(id, (String) it.next());\n\t}\n}\n```\n\n```java\nprotected AbstractBeanDefinition parseBeanDefinition(Element ele, String beanName) {\n\tString className = null;\n\ttry {\n\t\t// 获取 class 属性\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE);\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\t\tif (className == null && parent == null) {\n\t\t\tthrow new BeanDefinitionStoreException(this.resource, beanName, \"Either 'class' or 'parent' is required\");\n\t\t}\n\n\t\tAbstractBeanDefinition bd = null;\n\t\t// 获取属性\n\t\tMutablePropertyValues pvs = getPropertyValueSubElements(beanName, ele);\n\n\t\tif (className != null) {\n\t\t\t// 获取构造\n\t\t\tConstructorArgumentValues cargs = getConstructorArgSubElements(beanName, ele);\n\t\t\tRootBeanDefinition rbd = null;\n\n\t\t\tif (this.beanClassLoader != null) {\n\t\t\t\tClass clazz = Class.forName(className, true, this.beanClassLoader);\n\t\t\t\trbd = new RootBeanDefinition(clazz, cargs, pvs);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trbd = new RootBeanDefinition(className, cargs, pvs);\n\t\t\t}\n\t\t\t// 设置 bean dependOn\n\t\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\t\trbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, BEAN_NAME_DELIMITERS, true, true));\n\t\t\t}\n\n\t\t\tString dependencyCheck = ele.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE);\n\t\t\tif (DEFAULT_VALUE.equals(dependencyCheck)) {\n\t\t\t\tdependencyCheck = this.defaultDependencyCheck;\n\t\t\t}\n\t\t\trbd.setDependencyCheck(getDependencyCheck(dependencyCheck));\n\n\t\t\t// 设置 bean 自动注册的方式 byType, byName or none\n\t\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\t\tif (DEFAULT_VALUE.equals(autowire)) {\n\t\t\t\tautowire = this.defaultAutowire;\n\t\t\t}\n\t\t\trbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\t\t// 设置 bean 的 init-method\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tif (!initMethodName.equals(\"\")) {\n\t\t\t\trbd.setInitMethodName(initMethodName);\n\t\t\t}\n\n\t\t\t// 设置 bean 的 destroy-method\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tif (!destroyMethodName.equals(\"\")) {\n\t\t\t\trbd.setDestroyMethodName(destroyMethodName);\n\t\t\t}\n\n\t\t\tbd = rbd;\n\t\t}\n\t\telse {\n\t\t\tbd = new ChildBeanDefinition(parent, pvs);\n\t\t}\n\n\t\t// 设置 bean 是否为单例\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\tbd.setSingleton(TRUE_VALUE.equals(ele.getAttribute(SINGLETON_ATTRIBUTE)));\n\t\t}\n\n\t\t// 是否懒加载\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (DEFAULT_VALUE.equals(lazyInit) && bd.isSingleton()) {\n\t\t\t// just apply default to singletons, as lazy-init has no meaning for prototypes\n\t\t\tlazyInit = this.defaultLazyInit;\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tbd.setResourceDescription(this.resource.getDescription());\n\n\t\treturn bd;\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t}\n\tcatch (NoClassDefFoundError err) {}\n}\n```\n\n> Spring 容器在将配置文件加载后，会解析 bean 标签并通过其相应的属性配置构造 BeanDefinition 对象，然后将 BeanDefinition 对象注册添加到 BeanFactory 中。\n\n### Spring Bean 实例化\n\n```java\npublic void preInstantiateSingletons() {\n\tif (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Pre-instantiating singletons in factory [\" + this + \"]\");\n\t}\n\t// 遍历注册的 bean definition\n\tfor (Iterator it = this.beanDefinitionNames.iterator(); it.hasNext();) {\n\t\tString beanName = (String) it.next();\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedBeanDefinition(beanName, false);\n\t\t\t// 如果 bean 定义为单例且非延迟加载的\n\t\t\tif (bd.isSingleton() && !bd.isLazyInit()) {\n\t\t\t\t// 判断 bean 是否为 FactoryBean\n\t\t\t\tif (FactoryBean.class.isAssignableFrom(bd.getBeanClass())) {\n\t\t\t\t\tFactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\t\tif (factory.isSingleton()) {\n\t\t\t\t\t\tgetBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// 若是普通 bean 则调用 getBean\n\t\t\t\t\tgetBean(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n```java\npublic Object getBean(String name) throws BeansException {\n\tString beanName = transformedBeanName(name);\n\t// eagerly check singleton cache for manually registered singletons\n\t// 检查单例缓存池中 是否存在 bean 实例，如果有从缓存中获取 bean 实例\n\tObject sharedInstance = this.singletonCache.get(beanName);\n\tif (sharedInstance != null) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t}\n\t\treturn getObjectForSharedInstance(name, sharedInstance);\n\t}\n\telse {\n\t\t// check if bean definition exists\n\t\tRootBeanDefinition mergedBeanDefinition = null;\n\t\ttry {\n\t\t\tmergedBeanDefinition = getMergedBeanDefinition(beanName, false);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// not found -> check parent\n\t\t\tif (this.parentBeanFactory != null) {\n\t\t\t\treturn this.parentBeanFactory.getBean(name);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\t// create bean instance\n\t\tif (mergedBeanDefinition.isSingleton()) {\n\t\t\tsynchronized (this.singletonCache) {\n\t\t\t\t// re-check singleton cache within synchronized block\n\t\t\t\tsharedInstance = this.singletonCache.get(beanName);\n\t\t\t\tif (sharedInstance == null) {\n\t\t\t\t\tlogger.info(\"Creating shared instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t\tsharedInstance = createBean(beanName, mergedBeanDefinition);\n\t\t\t\t\taddSingleton(beanName, sharedInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getObjectForSharedInstance(name, sharedInstance);\n\t\t}\n\t\telse {\n\t\t\treturn createBean(name, mergedBeanDefinition);\n\t\t}\n\t}\n}\n```\n```java\nprotected Object createBean(String beanName, RootBeanDefinition mergedBeanDefinition) throws BeansException {\n\tif (mergedBeanDefinition.getDependsOn() != null) {\n\t\tfor (int i = 0; i < mergedBeanDefinition.getDependsOn().length; i++) {\n\t\t\t// guarantee initialization of beans that the current one depends on\n\t\t\tgetBean(mergedBeanDefinition.getDependsOn()[i]);\n\t\t}\n\t}\n\n\t// bean 初始化并包装，也就是 new\n\tBeanWrapper instanceWrapper = null;\n\tif (mergedBeanDefinition.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n\t\t\tmergedBeanDefinition.hasConstructorArgumentValues()) {\n\t\tinstanceWrapper = autowireConstructor(beanName, mergedBeanDefinition);\n\t}\n\telse {\n\t\tinstanceWrapper = new BeanWrapperImpl(mergedBeanDefinition.getBeanClass());\n\t\tinitBeanWrapper(instanceWrapper);\n\t}\n\tObject bean = instanceWrapper.getWrappedInstance();\n\n\t// Eagerly cache singletons to be able to resolve circular references\n\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\tif (mergedBeanDefinition.isSingleton()) {\n\t\t// 单例的bean 则添加到缓存中\n\t\taddSingleton(beanName, bean);\n\t}\n\t// bean 属性注入\n\tpopulateBean(beanName, mergedBeanDefinition, instanceWrapper);\n\n\ttry {\n\t\tif (bean instanceof BeanNameAware) {\n\t\t\t// bean 若实现接口 BeanNameAware 则调用 setBeanName 方法\n\t\t\t((BeanNameAware) bean).setBeanName(beanName);\n\t\t}\n\n\t\tif (bean instanceof BeanFactoryAware) {\n\t\t\t// bean 若实现接口 BeanFactoryAware 则调用 setBeanFactory 方法\n\t\t\t((BeanFactoryAware) bean).setBeanFactory(this);\n\t\t}\n\n\t\t// 调用 BeanPostProcessor 执行 postProcessBeforeInitialization 方法\n\t\tbean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);\n\t\t// 若 bean 实现 InitializingBean 接口则执行 afterPropertiesSet 方法\n\t\t// 若 bean 定义中定义了 init-method 属性则执行对应的init 方法\n\t\tinvokeInitMethods(bean, beanName, mergedBeanDefinition);\n\t\t// 调用 BeanPostProcessor 执行 postProcessAfterInitialization 方法\n\t\tbean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n\t}\n\tcatch (InvocationTargetException ex) {\n\t\tthrow new BeanCreationException(mergedBeanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Initialization of bean failed\", ex.getTargetException());\n\t}\n\tcatch (Exception ex) {\n\t\tthrow new BeanCreationException(mergedBeanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Initialization of bean failed\", ex);\n\t}\n\treturn bean;\n}\n```\n\n> 从 bean 的实例化过程中，Spring 容器在启动时只针对单例且非延迟加载的 bean 进行初始化；其他的 bean 只有在显示调用 getBean() 方法时才去实例化；下面将会对实例化过程中的详细过程进行说明。\n\n#### Spring Bean 作用域\n\n##### singleton 单例模式\n\n> Spring IoC 容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。\n\n```xml\n    <bean id=\"test\" singleton=\"true\" />\n\n    <bean scope=\"singleton\" />\n```\n\nSpring 1.0 中通过 bean 定义属性 `singleton='true'` 表示单例； 在 Spring 2.x 之后版本改为定义属性 `scope='singleton'`, 同时兼容 1.0 的配置\n\n##### prototype 原型模式\n\n> 每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态\n\n```xml\n    <bean id=\"test\" singleton=\"false\" />\n\n    <bean scope=\"prototype\" />\n```\n\nSpring 1.0 中通过 bean 定义属性 `singleton='false'` 表示原型模式； 在 Spring 2.x 之后版本改为定义属性 `scope='prototype'`, 同时兼容 1.0 的配置\n\n\n#### Spring Bean 生命周期\n\n![](https://i.loli.net/2019/06/21/5d0c7e09154d028840.png)\n\n##### 示例\n\n```java\npublic class LifecycleBean implements BeanNameAware, InitializingBean, BeanFactoryAware, ResourceLoaderAware, ApplicationContextAware, DisposableBean {\n\n\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tSystem.out.println(\"set bean factory\");\n\t}\n\n\tpublic void setBeanName(String name) {\n\t\tSystem.out.println(\"set bean name\");\n\t}\n\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tSystem.out.println(\"Initializing Bean afterPropertiesSet\");\n\t}\n\n\tpublic void setApplicationContext(ApplicationContext context) throws BeansException {\n\t\tSystem.out.println(\"set application context\");\n\t}\n\n\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tSystem.out.println(\"set resource loader\");\n\t}\n\n\tpublic void init () {\n\t\tSystem.out.println(\"do init method\");\n\t}\n\n\tpublic Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {\n\t\tSystem.out.println(\"post Process Before Initialization\");\n\t\treturn bean;\n\t}\n\n\tpublic Object postProcessAfterInitialization(Object bean, String name) throws BeansException {\n\t\tSystem.out.println(\"post Process After Initialization\");\n\t\treturn bean;\n\t}\n\n\tpublic void destroy() throws Exception {\n\t\tSystem.out.println(\"do destroy \");\n\t}\n\n\tpublic void destroyMethod() throws Exception {\n\t\tSystem.out.println(\"do destroy method\");\n\t}\n}\n\n```\n```java\npublic class PostProcessor implements BeanPostProcessor {\n    public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {\n        if (bean instanceof LifecycleBean) {\n            ((LifecycleBean) bean).postProcessBeforeInitialization(bean, name);\n        }\n        return bean;\n    }\n\n    public Object postProcessAfterInitialization(Object bean, String name) throws BeansException {\n        if (bean instanceof LifecycleBean) {\n            ((LifecycleBean) bean).postProcessAfterInitialization(bean, name);\n        }\n        return bean;\n    }\n}\n```\n\nspring 配置文件如下\n\n```java\n<beans>\n    <bean id=\"lifecycleBean\" class=\"org.springframework.beans.factory.LifecycleBean\" init-method=\"init\" />\n\n    <bean id=\"postProcessor\" class=\"org.springframework.beans.factory.PostProcessor\" />\n</beans>\n```\n\n运行结果如下：\n\n```\n\nset bean name\nset bean factory\nset resource loader\nset application context\npost Process Before Initialization\nInitializing Bean afterPropertiesSet\ndo init method\npost Process After Initialization\ndo destroy \ndo destroy method\n\n```\n\n#### Spring Bean 注入方式\n\n##### 构造注入\n\n```xml\n<bean>\n    <constructor-arg index=\"1\">\n        <value></value>\n    </constructor-arg>\n</bean>\n\n<bean autowire=\"constructor\" />\n```\n\n当 bean 定义配置如以上方式的时候，会触发 `autowireConstructor` (详细实现参考源码吧)\n\n```java\nBeanWrapper instanceWrapper = null;\nif (mergedBeanDefinition.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n\t\tmergedBeanDefinition.hasConstructorArgumentValues()) {\n\n\tinstanceWrapper = autowireConstructor(beanName, mergedBeanDefinition);\n}\n```\n##### byType 注入\n\n```xml\n<bean autowire=\"byType\" />\n```\n\n当 bean 定义配置如以上方式的时候，会触发 `autowireByType` 如下：\n\n```java\nprotected void autowireByType(String beanName, RootBeanDefinition mergedBeanDefinition,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tBeanWrapper bw, MutablePropertyValues pvs) {\n\t// 查找 bean 存在可写方法的非基本数据类型的成员变量\n\tString[] propertyNames = unsatisfiedObjectProperties(mergedBeanDefinition, bw);\n\tfor (int i = 0; i < propertyNames.length; i++) {\n\t\tString propertyName = propertyNames[i];\n\t\t// look for a matching type\n\t\t// 获取成员变量的类型\n\t\tClass requiredType = bw.getPropertyDescriptor(propertyName).getPropertyType();\n\t\t// 查找成员变量对应的 bean 实例\n\t\tMap matchingBeans = findMatchingBeans(requiredType);\n\t\tif (matchingBeans != null && matchingBeans.size() == 1) {\n\t\t\t// 成员变量查找到匹配的bean实例，有且只有一个的时候\n\t\t\t// 将属性名和属性值 添加到 PropertyValues 中\n\t\t\tpvs.addPropertyValue(propertyName, matchingBeans.values().iterator().next());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Autowiring by type from bean name '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" +\n\t\t\t\t\t\t\t\t\t\tmatchingBeans.keySet().iterator().next() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse if (matchingBeans != null && matchingBeans.size() > 1) {\n\t\t\t// 当存在多个同类型的实例时 抛出异常\n\t\t\tthrow new UnsatisfiedDependencyException(beanName, propertyName,\n\t\t\t\t\t\"There are \" + matchingBeans.size() + \" beans of type [\" + requiredType + \"] for autowire by type. \" +\n\t\t\t\t\t\"There should have been 1 to be able to autowire property '\" + propertyName + \"' of bean '\" + beanName + \"'.\");\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\"' by type: no matching bean found\");\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n##### byName 注入\n\n```xml\n<bean autowire=\"byName\" />\n```\n\n当 bean 定义配置如以上方式的时候，会触发 `autowireByName` 如下：\n\n```java\nprotected void autowireByName(String beanName, RootBeanDefinition mergedBeanDefinition,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tBeanWrapper bw, MutablePropertyValues pvs) {\n\t// 查找 bean 存在可写方法的非基本数据类型的成员变量\n\tString[] propertyNames = unsatisfiedObjectProperties(mergedBeanDefinition, bw);\n\tfor (int i = 0; i < propertyNames.length; i++) {\n\t\tString propertyName = propertyNames[i];\n\t\t// 在 Spring 容器中查找是否存在以 propertyName 命名的 bean definition\n\t\tif (containsBean(propertyName)) {\n\t\t\t// 实例化依赖的 bean, 并添加到 MutablePropertyValues 中\n\t\t\tObject bean = getBean(propertyName);\n\t\t\tpvs.addPropertyValue(propertyName, bean);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n##### set 注入\n\n```xml\n<bean>\n    <property name=\"age\">\n        <value>11</value>\n    </property>\n</bean>\n```\n\n当 bean 定义配置如上，或者采用 byName, byType 的注入方式时，都会调用 `applyPropertyValues` 方法完成属性的注入。（详细实现参考源码吧）\n\n#### Spring Bean 注解式注入\n\n> 自 Spring 2.5 版本之后，支持通过注解方式实现 Bean 的自动注入，譬如 `@Autowired`, `@Resource` 等注解\n\n为了引入注解式自动注入, Spring 在 2.x 版本中新增了 `InstantiationAwareBeanPostProcessor` 接口，该接口继承 `BeanPostProcessor` 并新增了方法 `postProcessPropertyValues` ; 该方法主要实现\n\n```\nPost-process the given property values before the factory applies them to the given bean\n```\n\n##### Autowired 注解\n\n> 采用 Autowired 注解实现自动注入，需在配置文件中配置 `AutowiredAnnotationBeanPostProcessor` Bean\n\n```java\npublic AutowiredAnnotationBeanPostProcessor() {\n\tthis.autowiredAnnotationTypes.add(Autowired.class);\n\tthis.autowiredAnnotationTypes.add(Value.class);\n\tClassLoader cl = AutowiredAnnotationBeanPostProcessor.class.getClassLoader();\n\ttry {\n\t\tthis.autowiredAnnotationTypes.add((Class<? extends Annotation>) cl.loadClass(\"javax.inject.Inject\"));\n\t\tlogger.info(\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\");\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t\t// JSR-330 API not available - simply skip.\n\t}\n}\n```\n\n从 `AutowiredAnnotationBeanPostProcessor` 构造可以看出其支持 `@Autowired`,`@Value`,`@Inject` 注解的自动注入。 下面大概看下其如何实现自动注入\n\n```java\npublic PropertyValues postProcessPropertyValues(\n\t\t\tPropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {\n\t// 查找 bean 中需要自动注入的元数据，包括 field， method\n\tInjectionMetadata metadata = findAutowiringMetadata(bean.getClass());\n\ttry {\n\t\t// 实现注入\n\t\tmetadata.inject(bean, beanName, pvs);\n\t}\n\tcatch (Throwable ex) {\n\t\tthrow new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n\t}\n\treturn pvs;\n}\n```\n\n##### Resource 注解\n\n> 采用 Resource 注解实现自动注入，需在配置文件中配置 `CommonAnnotationBeanPostProcessor` Bean\n\n```java\npublic CommonAnnotationBeanPostProcessor() {\n\tsetOrder(Ordered.LOWEST_PRECEDENCE - 3);\n\tsetInitAnnotationType(PostConstruct.class);\n\tsetDestroyAnnotationType(PreDestroy.class);\n\tignoreResourceType(\"javax.xml.ws.WebServiceContext\");\n}\n```\n\n从 `CommonAnnotationBeanPostProcessor` 构造可以看出，该类同时支持对注解 `@PostConstruct`, `@PreDestroy` 生效。\n\n```java\npublic PropertyValues postProcessPropertyValues(\n\t\t\tPropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {\n\t// 查找 bean 中标注有 @Resource 注解的 Field， method\n\tInjectionMetadata metadata = findResourceMetadata(bean.getClass());\n\ttry {\n\t\t// 实现注入\n\t\tmetadata.inject(bean, beanName, pvs);\n\t}\n\tcatch (Throwable ex) {\n\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t}\n\treturn pvs;\n}\n```\n\n```java\n\npublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t// 查找 bean 定义中标注了 PostConstruct 注解的方法\n\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\ttry {\n\t\t// 调用指定 post construct method\n\t\tmetadata.invokeInitMethods(bean, beanName);\n\t}\n\tcatch (InvocationTargetException ex) {\n\t\tthrow new BeanCreationException(beanName, \"Invocation of init method failed\", ex.getTargetException());\n\t}\n\tcatch (Throwable ex) {\n\t\tthrow new BeanCreationException(beanName, \"Couldn't invoke init method\", ex);\n\t}\n\treturn bean;\n}\n\npublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t// 查找 bean 定义中标注了 PreDestroy 注解的方法\n\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\ttry {\n\t\t// 调用指定 destroy method\n\t\tmetadata.invokeDestroyMethods(bean, beanName);\n\t}\n\tcatch (InvocationTargetException ex) {\n\t\tString msg = \"Invocation of destroy method failed on bean with name '\" + beanName + \"'\";\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.warn(msg, ex.getTargetException());\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(msg + \": \" + ex.getTargetException());\n\t\t}\n\t}\n\tcatch (Throwable ex) {\n\t\tlogger.error(\"Couldn't invoke destroy method on bean with name '\" + beanName + \"'\", ex);\n\t}\n}\n```\n\n```java\nprivate LifecycleMetadata buildLifecycleMetadata(Class clazz) {\n\tfinal boolean debug = logger.isDebugEnabled();\n\tLinkedList<LifecycleElement> initMethods = new LinkedList<LifecycleElement>();\n\tLinkedList<LifecycleElement> destroyMethods = new LinkedList<LifecycleElement>();\n\tClass<?> targetClass = clazz;\n\n\tdo {\n\t\tLinkedList<LifecycleElement> currInitMethods = new LinkedList<LifecycleElement>();\n\t\tLinkedList<LifecycleElement> currDestroyMethods = new LinkedList<LifecycleElement>();\n\t\t// 遍历 bean 的所有方法\n\t\tfor (Method method : targetClass.getDeclaredMethods()) {\n\t\t\tif (this.initAnnotationType != null) {\n\t\t\t\t// 判断 method 是否标注了 @PostConstruct 注解\n\t\t\t\tif (method.getAnnotation(this.initAnnotationType) != null) {\n\t\t\t\t\tLifecycleElement element = new LifecycleElement(method);\n\t\t\t\t\tcurrInitMethods.add(element);\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tlogger.debug(\"Found init method on class [\" + clazz.getName() + \"]: \" + method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.destroyAnnotationType != null) {\n\t\t\t\t// 判断 method 是否标注了 @PreDestroy 注解\n\t\t\t\tif (method.getAnnotation(this.destroyAnnotationType) != null) {\n\t\t\t\t\tcurrDestroyMethods.add(new LifecycleElement(method));\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tlogger.debug(\"Found destroy method on class [\" + clazz.getName() + \"]: \" + method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinitMethods.addAll(0, currInitMethods);\n\t\tdestroyMethods.addAll(currDestroyMethods);\n\t\ttargetClass = targetClass.getSuperclass();\n\t}\n\twhile (targetClass != null && targetClass != Object.class);\n\n\treturn new LifecycleMetadata(clazz, initMethods, destroyMethods);\n}\n```\n\n##### &lt;context: annotation-config&gt;\n\n> 为了简化 Spring 配置文件中的 bean 配置，Spring 提供了 &lt;context: annotation-config&gt; 标签自动加载 `AutowiredAnnotationBeanPostProcessor`, `CommonAnnotationBeanPostProcessor` 等 bean。\n\n在 spring-context 包 resources/META-INF 下的 spring.handlers 文件中配置如下：\n\n```json\n\nhttp\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler\n\n```\n\n```java\npublic class ContextNamespaceHandler extends NamespaceHandlerSupport {\n\n\tpublic void init() {\n\t\tregisterBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"mbean-export\", new MBeanExportBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"mbean-server\", new MBeanServerBeanDefinitionParser());\n\t}\n\n}\n``` \n\n```java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, Object source) {\n\n\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<BeanDefinitionHolder>(4);\n\n\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\tdef.setSource(source);\n\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t}\n\n\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t// 加载注册 AutowiredAnnotationBeanPostProcessor\n\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\tdef.setSource(source);\n\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t}\n\n\tif (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t// 加载注册 RequiredAnnotationBeanPostProcessor\n\t\tRootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);\n\t\tdef.setSource(source);\n\t\tbeanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t}\n\n\t// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n\tif (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t// 加载注册 CommonAnnotationBeanPostProcessor\n\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\tdef.setSource(source);\n\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t}\n\n\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\ttry {\n\t\t\tClassLoader cl = AnnotationConfigUtils.class.getClassLoader();\n\t\t\tdef.setBeanClass(cl.loadClass(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME));\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t}\n\t\tdef.setSource(source);\n\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t}\n\n\treturn beanDefs;\n}\n```\n\n可以看出在 Spring 启动时，通过解析 &lt;context: annotation-config&gt; 标签，完成对 `CommonAnnotationBeanPostProcessor`, `AutowiredAnnotationBeanPostProcessor` 的加载注册，进而实现通过注解方式的自动注入。\n\n## 小结\n\n### BeanFactory & ApplicationContext\n\n![](https://i.loli.net/2019/06/21/5d0c7e0b091de71615.png)\n\n### BeanFactoryPostProcessor & BeanPostProcessor\n\n* `BeanFactoryPostProcessor` 是 `ApplicationContext` 在 BeanFactory 完成创建后对其进行后置处理的接口\n* `BeanPostProcessor` 是 `BeanFactory` 在 Bean 完成实例化对其进行的后置处理接口\n\n### BeanFactory & FactoryBean\n\n* BeanFactory 是 Spring 框架底层的核心接口，其提供了创建 bean，获取 bean 等核心功能。\n* FactoryBean 是生产 bean 的一个模式，也就是以工厂模式的方式生产 bean。\n\n\n\n\n\n\n\n\n\n","tags":["Spring"]},{"title":"LeetCode-数组-删除有序数组重复元素","url":"/2019/02/26/LeetCode-数组-删除有序数组重复元素/","content":"\n## 题目描述\n\n给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n```java\n\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n\n```\n\n<!-- more -->\n\n## 解题思路\n\n> 采用双指针方式处理。\n\n1. 初始指针 i, j 位置为 0\n2. 指针 j 先向右移动\n3. 比较指针 i,j 元素是否相同，若指针i，j元素相同则指针 j 继续向右移动；反之将指针 j 元素复制到指针 i + 1 处元素\n4. 当指针 j 移动到数组末尾时则停止\n\n\n其流程如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7da720edc38121.gif)\n\n\n## 实现\n\n```java\npublic static int solution (int[] nums) {\n    int i = 0, j = 0;\n\n    while (true) {\n    \t// 指针 j 向右移动\n        j++;\n\n        // 指针 j 移动到数组末尾则退出，说明数组元素都判断了去重\n        if (j >= nums.length) {\n            break;\n        }\n\n        if (nums[j] == nums[i]) {\n        \t// 指针 i, j 元素相同，说明重复元素；\n        \t// 指针 j 继续向右移动\n            continue;\n        } else {\n        \t// 指针 i, j 元素不相同；则将指针 j 元素复制到 指针 i 后一位，这样就保证指针 i 后元素不重复\n            nums[i + 1] = nums[j];\n            // 指针 i 向右移动，继续处理\n            i++;\n        }\n    }\n\n    return i + 1;\n}\n```\n","tags":["LeetCode"]},{"title":"LeetCode-数组-三数之和","url":"/2019/02/24/LeetCode-数组-三数之和/","content":"\n## 题目描述\n\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。 [习题原文](https://leetcode-cn.com/problems/3sum/)\n\n<!-- more -->\n\n## 解题思路\n\n> 求三数之和为 0, nums[i] + nums[j] + nums[k] = 0 可以转换为求两个数之和，也即是 nums[i] + nums[j] = -nums[k]; 那么就可以通过指针移动去查找满足公式的数字，而为了方便控制指针的移动，前提是一组数字是有序的。\n\n那么大概的解题思路如下:\n\n* 对数组排序\n* 定义三个指针 i, left, right; 指针 i 指向的是求和项，指针 left, right 分别指向数组的头部和尾部\n* 当 -nums[i] = nums[left] + nums[right] 时满足公式，指针 left, right 继续向中部移动\n* 当 -nums[i] > nums[left] + nums[right] 时指针 left 向中部移动\n* 当 -nums[i] < nums[left] + nums[right] 时指针 righr 向中部移动\n* 当指针 left，right 交叉时停止移动，指针 i 向下移动，指针 left, right 重置\n\n其流程如下图所示:\n\n![](https://i.loli.net/2019/06/21/5d0c7da1ecb5b42266.gif)\n\n## 实现\n\n```java\npublic static List<List<Integer>> solution(int[] nums) {\n    // 排序\n    Arrays.sort(nums);\n\n    List<List<Integer>> rs = new ArrayList<>();\n\n    int i = 0, left = 1, right = nums.length - 1;\n\n    while (i < nums.length - 2) {\n        while (true) {\n            // 左右指针交叉退出\n            if (right <= left) {\n                break;\n            }\n\n            if (-nums[i] == nums[left] + nums[right]) {\n                rs.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                // 过滤同一结果内重复的数字\n                // 左右指针继续向中间移动\n                while (true) {\n                    if (left >= nums.length - 1) {\n                        break;\n                    }\n\n                    if (nums[left] != nums[left + 1]) {\n                        left++;\n                        break;\n                    } else {\n                        left++;\n                    }\n                }\n\n                while (true) {\n                    if (right <= 0) {\n                        break;\n                    }\n\n                    if (nums[right] != nums[right - 1]) {\n                        right--;\n                        break;\n                    } else {\n                        right--;\n                    }\n                }\n\n                continue;\n            }\n\n            if (-nums[i] <= nums[left] + nums[right]) {\n                right--;\n                continue;\n            }\n\n            if (-nums[i] > nums[left] + nums[right]) {\n                left++;\n                continue;\n            }\n        }\n\n        // 过滤同一结果值的数字\n        while (true) {\n            if (i >= nums.length - 1) {\n                break;\n            }\n\n            if (nums[i] != nums[i + 1]) {\n                i++;\n                break;\n            } else {\n                i++;\n            }\n        }\n\n        //i++;\n        left = i + 1;\n        right = nums.length - 1;\n    }\n\n    return rs;\n}\n```\n\n\n","tags":["LeetCode"]},{"title":"Thread的中断理解","url":"/2018/12/28/Thread的中断理解/","content":"### Thread 的中断理解\n\n> 首先我们需要明确一个概念 中断并非是终止。 \n\n#### interrupt() \n\n> 线程中断方法, 调用该方法时会将线程的中断标志位标记为 true; (注意你可以理解为只是单纯的改变下标记，并不是使线程停止运行)\n\n#### isInterrupted()\n\n> 获取线程的中断标志位，也就是判断是否被中断过; true 表示被中断过\n\n#### InterruptedException\n\n> 当线程处于阻塞状态时（执行过 wait , sleep 等），此时调用线程的 interrupt() 方法，在抛出 InterruptedException 之前会将中断标志位复位, 也就是说在抛出中断异常之后在调用 isInterrupted 会返回 false 而不是 true \n\n#### interrupted()\n\n> 该方法是 Thread 的静态方法，返回当前线程是否中断过，同时对中断标志进行复位","tags":["多线程"]},{"title":"FutureTask 源码分析","url":"/2018/12/25/FutureTask/","content":"### FutureTask 源码分析\n\n> 基于 JDK 1.7 \n\n#### 成员变量\n\n```java\n\tprivate volatile int state;\n    private static final int NEW          = 0;\n    private static final int COMPLETING   = 1;\n    private static final int NORMAL       = 2;\n    private static final int EXCEPTIONAL  = 3;\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    /** The underlying callable; nulled out after running */\n    private Callable<V> callable;\n    /** The result to return or exception to throw from get() */\n    private Object outcome; // non-volatile, protected by state reads/writes\n    /** The thread running the callable; CASed during run() */\n    private volatile Thread runner;\n    /** Treiber stack of waiting threads */\n    private volatile WaitNode waiters;\n```\n\n<!-- more -->\n\n变量 state 记录当前任务的状态，其可取值范围如下：\n\n- NEW : 任务初始状态\n- COMPLETING : 任务执行中\n- NORMAL : 任务已完成\n- CANCELLED : 任务取消\n- EXCEPTIONAL : 任务执行异常\n- INTERRUPTING : 任务中断\n- INTERRUPTED : 任务已中断\n\n状态的流转可能会有以下几种情形：\n\n* NEW -> COMPLETING -> NORMAL\n* NEW -> COMPLETING -> EXCEPTIONAL\n* NEW -> CANCELLED\n* NEW -> INTERRUPTING -> INTERRUPTED\n\n变量 callable 存储的是可执行的任务，变量 outcome 存储任务的返回值，变量 runner 指向当前执行该任务的线程，变量 waiters 执行等待链表的头节点。\n\n#### 初始化\n\n```java\n\tpublic FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n\n        this.callable = callable;\n        this.state = NEW;\n    }\n```\nFutureTask 在构造时会设置 state 为初始状态 NEW 。\n\n#### 任务的执行 - run()\n\n```java\n\tpublic void run() {\n\t\t// 只有状态 state 为 NEW， runner 为空的情况下才可以执行\n        if (state != NEW ||\n        \t// 将变量 runner 设置为当前线程，\n        \t// 此处应该是为了保证任务只允许被一个线程处理，也即只允许执行一次\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                \t// 执行 callable\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                \t// 成功执行后，设置结果值\n                    set(result);\n            }\n        } finally {        \n            runner = null;\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\n```java\n\tprotected void set(V v) {\n\t\t// 设置 state 为 COMPLETING\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        \t// 设置返回结果\n            outcome = v;\n            // 设置 state 为 NORMAL\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            // 任务完成唤醒挂起的线程\n            finishCompletion();\n        }\n    }\n```\n\n```java\n\tprivate void finishCompletion() {\n        // assert state > COMPLETING;\n        for (WaitNode q; (q = waiters) != null;) {\n        \t// 将 waiters 重置为空\n            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            \t// 采用死循环的方式唤醒挂起的线程\n                for (;;) {\n                \t// 获取等待节点关联的线程\n                    Thread t = q.thread;\n                    if (t != null) {\n                        q.thread = null;\n                        // 唤醒线程\n                        LockSupport.unpark(t);\n                    }\n\n                    // 获取等待链表的下一个节点继续唤醒\n                    WaitNode next = q.next;\n                    if (next == null)\n                    \t// 节点为空的时候 跳出循环\n                        break;\n                    q.next = null; // unlink to help gc\n                    q = next;\n                }\n                break;\n            }\n        }\n\n        done();\n\n        callable = null;        // to reduce footprint\n    }\n```\n从上述源码中可以看出 callable 只会被执行一次，执行过程如下：\n\n* 设置 runner 为当前线程\n* 回调 callable\n* 设置状态 state 为 COMPLETING \n* 设置返回结果 outcome\n* 设置状态 state 为 NORMAL\n* 唤醒等待链表 waiters 里的线程\n\n> 那么 waiters 等待链表什么时候存在等待的节点呢 ？ \n\n#### 获取任务结果 - get()\n\n```java\n\tpublic V get() throws InterruptedException, ExecutionException {\n        int s = state;\n        if (s <= COMPLETING)\n            s = awaitDone(false, 0L);\n        return report(s);\n    }\n```\n\n```java\n\tprivate int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n        // 等待时长\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        WaitNode q = null;\n        boolean queued = false;\n        // 采用死循环的方式\n        for (;;) {\n            if (Thread.interrupted()) {\n                removeWaiter(q);\n                throw new InterruptedException();\n            }\n\n            int s = state;\n            if (s > COMPLETING) {\n            \t// 此时任务已完成，可退出循环\n                if (q != null)\n                    q.thread = null;\n                return s;\n            }\n            else if (s == COMPLETING) // cannot time out yet\n                Thread.yield();\n            else if (q == null)\n            \t// 创建等待节点\n                q = new WaitNode();\n            else if (!queued)\n            \t// 若未加入等待链表时，将 q 的 next 指向 waiters , 然后将 waiters 移动到 q\n                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                     q.next = waiters, q);\n            else if (timed) {\n                nanos = deadline - System.nanoTime();\n                if (nanos <= 0L) {\n                \t// 超过等待时长 将等待节点移除\n                    removeWaiter(q);\n                    return state;\n                }\n                LockSupport.parkNanos(this, nanos);\n            }\n            else\n            \t// 挂起调用者线程\n            \t// 当任务执行完 执行 finishCompletion 是会被唤醒\n                LockSupport.park(this);\n        }\n    }\n```\n\n```java\n\tprivate V report(int s) throws ExecutionException {\n        Object x = outcome;\n        if (s == NORMAL)\n            return (V)x;\n        if (s >= CANCELLED)\n            throw new CancellationException();\n        throw new ExecutionException((Throwable)x);\n    }\n```\n\n从 get() 操作源码可以看出，当调用者线程执行 futureTask.get() 时首先判断当前 state 是否大于 COMPLETING; 若小于等于 COMPLETING 则调用 awaitDone 方法； 在 awaitDone 方法中采用轮询的方式执行以下逻辑：\n\n* 创建 WaitNode\n* 将调用者线程 WaitNode 的 next 指向 waiters， 然后将 waiters 指向调用者线程 WaitNode\n* 若需要超时等待，则将调用者线程按指定时间挂起，反之将调用者线程挂起等待任务完成唤醒\n* state > COMPLETING 任务完成退出循环\n\n结合上述分析可得 FutureTask 执行活动图如下：\n![](https://i.loli.net/2019/06/21/5d0c7d82db64d74902.png)\n\n同时也可以看出，在 FutureTask 中内部维护了一个单向链表 waiters , 在执行 get 的时候会向其中添加节点:\n![](https://i.loli.net/2019/06/21/5d0c7d84e2e0842204.png)\n\n#### 任务取消 - cancel()\n\n```java\n\t/**\n\t * mayInterruptIfRunning 是否中断执行线程\n\t */\n\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n        if (!(state == NEW &&\n              UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        \t// 只有 FutureTask 为初始状态的时候 允许取消\n            return false;\n        try {    // in case call to interrupt throws exception\n            if (mayInterruptIfRunning) {\n                try {\n                    Thread t = runner;\n                    if (t != null)\n                    \t// 中断执行线程\n                        t.interrupt();\n                } finally { // final state\n                \t// 设置状态为 INTERRUPTED\n                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n                }\n            }\n        } finally {\n        \t// 唤醒挂起的线程\n            finishCompletion();\n        }\n        return true;\n    }\n```\n\n#### 小结\n\n从上可以看出 FutureTask 可以用于当一个线程需要等待另外一个线程执行完某个任务后才能继续执行的场景下。\n","tags":["jdk","多线程"]},{"title":"DelayQueue 延迟阻塞队列使用及分析","url":"/2018/12/22/DelayQueue 延迟阻塞队列使用及分析/","content":"### 延迟阻塞队列 DelayQueue\n\n> DelayQueue 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 PriorityQueue 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。\n\n<!-- more -->\n\n### 使用场景\n\n> 因延迟阻塞队列的特性， 我们一般将 DelayQueue 作用于以下场景 ：\n\n* 缓存系统 ： 当能够从 DelayQueue 中获取元素时，说该缓存已过期\n* 定时任务调度 ：\n\n 下面我们以缓存系统的应用，看下 DelayQueue 的使用，代码如下：\n\n```java\npublic class DelayQueueDemo {\n\n    static class Cache implements Runnable {\n\n        private boolean stop = false;\n\n        private Map<String, String> itemMap = new HashMap<>();\n\n        private DelayQueue<CacheItem> delayQueue = new DelayQueue<>();\n\n        public Cache () {\n            // 开启内部线程检测是否过期\n            new Thread(this).start();\n        }\n\n        /**\n         * 添加缓存\n         *\n         * @param key\n         * @param value\n         * @param exprieTime　过期时间,单位秒\n         */\n        public void put (String key, String value, long exprieTime) {\n            CacheItem cacheItem = new CacheItem(key, exprieTime);\n\n            // 此处忽略添加重复 key 的处理\n            delayQueue.add(cacheItem);\n            itemMap.put(key, value);\n        }\n\n        public String get (String key) {\n            return itemMap.get(key);\n        }\n\n        public void shutdown () {\n            stop = true;\n        }\n\n        @Override\n        public void run() {\n            while (!stop) {\n                CacheItem cacheItem = delayQueue.poll();\n                if (cacheItem != null) {\n                    // 元素过期, 从缓存中移除\n                    itemMap.remove(cacheItem.getKey());\n                    System.out.println(\"key : \" + cacheItem.getKey() + \" 过期并移除\");\n                }\n            }\n\n            System.out.println(\"cache stop\");\n        }\n    }\n\n    static class CacheItem implements Delayed {\n\n        private String key;\n\n        /**\n         * 过期时间(单位秒)\n         */\n        private long exprieTime;\n\n        private long currentTime;\n\n        public CacheItem(String key, long exprieTime) {\n            this.key = key;\n            this.exprieTime = exprieTime;\n            this.currentTime = System.currentTimeMillis();\n        }\n\n        @Override\n        public long getDelay(TimeUnit unit) {\n            // 计算剩余的过期时间\n            // 大于 0 说明未过期\n            return exprieTime - TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - currentTime);\n        }\n\n        @Override\n        public int compareTo(Delayed o) {\n            // 过期时间长的放置在队列尾部\n            if (this.getDelay(TimeUnit.MICROSECONDS) > o.getDelay(TimeUnit.MICROSECONDS)) {\n                return 1;\n            }\n            // 过期时间短的放置在队列头\n            if (this.getDelay(TimeUnit.MICROSECONDS) < o.getDelay(TimeUnit.MICROSECONDS)) {\n                return -1;\n            }\n\n            return 0;\n        }\n\n        public String getKey() {\n            return key;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Cache cache = new Cache();\n\n        // 添加缓存元素\n        cache.put(\"a\", \"1\", 5);\n        cache.put(\"b\", \"2\", 4);\n        cache.put(\"c\", \"3\", 3);\n\n        while (true) {\n            String a = cache.get(\"a\");\n            String b = cache.get(\"b\");\n            String c = cache.get(\"c\");\n\n            System.out.println(\"a : \" + a + \", b : \" + b + \", c : \" + c);\n\n            // 元素均过期后退出循环\n            if (StringUtils.isEmpty(a) && StringUtils.isEmpty(b) && StringUtils.isEmpty(c)) {\n                break;\n            }\n\n            TimeUnit.MILLISECONDS.sleep(1000);\n        }\n\n        cache.shutdown();\n    }\n}\n\n```\n\n执行结果如下：\n\n```java\n\na : 1, b : 2, c : 3\na : 1, b : 2, c : 3\na : 1, b : 2, c : 3\nkey : c 过期并移除\na : 1, b : 2, c : null\nkey : b 过期并移除\na : 1, b : null, c : null\nkey : a 过期并移除\na : null, b : null, c : null\ncache stop\n\n```\n\n从执行结果可以看出，因循环内部每次停顿 1 秒，当等待 3 秒后，元素 c 过期并从缓存中清除，等待 4 秒后，元素 b 过期并从缓存中清除，等待 5 秒后，元素 a 过期并从缓存中清除。\n\n### 实现原理\n\n#### 变量\n\n##### 重入锁\n\n```java\nprivate final transient ReentrantLock lock = new ReentrantLock();\n```\n用于保证队列操作的线程安全性\n\n##### 优先队列\n\n```java\nprivate final PriorityQueue<E> q = new PriorityQueue<E>();\n```\n\n存储介质，用于保证延迟低的优先执行\n\n##### leader \n\n> leader 指向的是第一个从队列获取元素阻塞等待的线程，其作用是减少其他线程不必要的等待时间。（这个地方我一直没搞明白 怎么就减少其他线程的等待时间了）\n\n##### condition\n\n```java\nprivate final Condition available = lock.newCondition();\n```\n条件对象，当新元素到达，或新线程可能需要成为leader时被通知\n\n\n下面将主要对队列的入队，出队动作进行分析 ：\n\n##### 入队 - offer\n\n```java\n    public boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            // 入队\n            q.offer(e);\n            if (q.peek() == e) {\n                // 若入队的元素位于队列头部，说明当前元素延迟最小\n                // 将 leader 置空\n                leader = null;\n                // 唤醒阻塞在等待队列的线程\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n##### 出队 - poll\n\n```java\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                E first = q.peek();\n                if (first == null)\n                \t// 等待 add 唤醒\n                    available.await();\n                else {\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0)\n                    \t// 已过期则直接返回队列头节点\n                        return q.poll();\n                    first = null; // don't retain ref while waiting\n                    if (leader != null)\n                    \t// 若 leader 不为空\n                    \t// 说明已经有其他线程调用过 take 操作\n                    \t// 当前调用线程 follower 挂起等待\n                        available.await();\n                    else {\n                    \t// 若 leader 为空\n                    \t// 将 leader 指向当前线程\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        try {\n                        \t// 当前调用线程在指定 delay 时间内挂起等待\n                            available.awaitNanos(delay);\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && q.peek() != null)\n                // leader 处理完之后，唤醒 follower\n                available.signal();\n            lock.unlock();\n        }\n    }\n```\n\n##### Leader-follower 模式\n\n![](https://user-gold-cdn.xitu.io/2017/6/28/9b634edda31c08405212e34840edc61e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n[该图引用自 CSDN 《Leader/Follower多线程网络模型介绍》](https://blog.csdn.net/goldlevi/article/details/7705180)\n\n#### 小结\n\n> 看了 DelayQueue 的实现 我们大概也明白 PriorityQueue 采用小顶堆的原因了。\n","tags":["jdk","多线程"]},{"title":"ThreadPoolExecutor线程池的实现分析","url":"/2018/12/20/ThreadPoolExecutor-线程池的实现分析/","content":"### ThreadPoolExecutor\n\n> 线程池在 JAVA 中是运用场景最多的并发框架，合理的运用线程池能够带来以下好处：\n\n* 降低资源消耗。\n* 提高响应速度。\n* 提高线程的可管理性\n\n<!-- more -->\n\n#### 构造\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n参数说明：\n\n* corePoolSize ：核心线程数\n* maximumPoolSize : 最大线程数\n* keepAliveTime : 空闲线程最大存活时间\n* unit : 空闲线程存活时间单位\n* workQueue : 用于保存等待执行的任务的阻塞队列\n* threadFactory : 用于创建线程的工厂\n* RejectedExecutionHandler : 饱和策略，就是当队列和线程池满了之后，采用何种策略处理提交的新任务\n\n#### 线程池状态\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\n// 计算 线程池运行状态\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\n// 计算 工作线程数\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n// 计算 ctl 值\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n* RUNNING : 运行中，接收新的任务并且处理队列中的任务\n* SHUTDOWN : 关闭，停止接收新的任务，但是可以处理队列中的任务\n* STOP : 停止接收新的任务，也不处理队列中的任务；并中断处理中的任务\n\nThreadPoolExecutor 采用一个原子的整形变量按位存储线程池的状态和线程池的当前工作线程数。\n前 3 位为线程池状态，后 29 位为线程池工作线程数\n\n> 为什么采用高 3 位， 因为目前线程池状态值有 5 种，采用 3 位的话正好可以存储\n\n\n\n#### execute\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    // workerCountOf 获取当前工作线程数\n    // 若当前工作线程数小于核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        // 开启线程执行 command\n        // 成功执行则返回 true 退出\n        if (addWorker(command, true))\n            return;\n        // 执行失败\n        // 失败的原因 ：线程池状态变更为 SHUTDOWN 或 其他任务被提交执行导致工作线程数超过了核心线程数\n        c = ctl.get();\n    }\n    // 判断线程池状态是否为 RUNNING\n    // 将任务添加到 workQueue\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 任务被添加到 workQueue 后，再次检查线程池的运行状态\n        // 若线程池状态非 RUNNING, 则将任务从 workQueue 中移除\n        if (! isRunning(recheck) && remove(command))\n            // 按指定的饱和拒绝策略处理任务\n            reject(command);\n        // 当工作线程数为 0 的时候，则开启新的线程从 workQueue 中获取任务并执行\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 若队列满，任务无法加入队列中，则开启线程执行任务\n    else if (!addWorker(command, false))\n        // 若无法开启线程执行任务，说明当前工作线程数超过最大线程数\n        // 按指定饱和策略处理任务\n        reject(command);\n}\n```\n\n##### 创建 Worker\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 此处的判断说明当线程池状态为 SHUTDOWN 的时候，如果工作队列 workQueue 中还有任务的话，将会继续处理；反之不处理 （firstTask == null 说明不是新提交的任务， 也就是新提交的任务不予处理）\n        // 若状态大于 SHUTDOWN 也就是 STOP 时，无论工作队列中 workQueue 是否有任务都不予处理\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            // 获取工作线程数\n            int wc = workerCountOf(c);\n            // 判断当前工作线程数是否超过线程池最大容量\n            // 判断当前工作线程数是否超过核心线程数或者最大线程数\n            // 若超过则退出，也就是开启线程执行任务失败\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            // 工作线程数加一\n            if (compareAndIncrementWorkerCount(c))\n                // 退出循环\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                // 运行状态发生变化 则继续轮询\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 创建 worker 对象\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    // 添加到 workers 工作线程集合中    \n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                // 线程启动\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n如下图所示为线程池创建 Worker 流程：\n\n![](https://i.loli.net/2019/06/21/5d0c7dbef0f5248338.png)\n\n> 从 addWorker 的实现可以看出，当线程池状态为 SHUTDOWN, STOP 时，将不会在接收新的任务\n\n##### Worker 执行\n\n> 接下来我们看下 Worker 的构建\n\n```java\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    // 创建线程\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n\n从 Worker 的构建可以看出，当线程启动时，实际上执行的是 Worker 的 run 方法。\n\n```java\npublic void run() {\n    runWorker(this);\n}\n```\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 若能够获取一个待执行的任务\n        // 也即是 firstTask 不为空或者 workQueue 工作队列中有待执行的任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    // 任务执行\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                // 当前 worker 完成的任务数加一\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n    }\n```\n\n> 接下来我们看下如何从 workQueue 中获取待执行的任务\n\n```java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 线程池状态为 SHUTDOWN 并且 workQueue 为空的时候返回 null\n        // 线程池状态为 STOP 返回 null\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        // 获取当前工作线程数\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        // allowCoreThreadTimeOut 该变量是指是否允许核心线程在指定存活时间内未获取到任务后回收;\n        // wc > corePoolSize 说明超过核心线程数的线程将会被回收\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n        // 工作线程数超过最大线程数 可销毁\n        // 工作线程数超过核心线程数且上次等待获取任务超时 可销毁\n        // 若工作线程数等于 1 且 workQueue 队列为空的时候 可销毁\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            // 工作线程数减一\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            // 从队列获取任务\n            // 若 timed 为 true, 则当前 worker 在指定的 keepAliveTime 时间内等待获取任务；若为空，那么 worker 在下次轮询的时候满足条件下将会退出被回收\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n如下图所示为 worker 获取任务及执行任务的流程：\n\n![](https://i.loli.net/2019/06/21/5d0c7dc200b0e22150.png)\n\n从 getTask 的实现可以看出在以下情况下将对 worker 执行退出销毁\n\n* 线程池状态为 STOP\n* 线程池状态为 SHUTDOWN, 且 workQueue 队列为空\n* 线程池工作线程数超过最大线程数\n* 线程池工作线程数大于 1，且允许核心线程回收（allowCoreThreadTimeOut = true）同时 worker 上次从队列获取任务时 timeout\n* 线程池工作线程数大于核心线程数并大于 1，同时 worker 上次从队列获取任务时 timeout\n* 线程池工作线程数等于 1 且 workQueue 为空\n\n> 个人理解 ：当 workQueue 不为空的时候，线程池最少会保留一个 worker 去执行任务\n\n接下来看下当 worker 退出后的逻辑 :\n\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // completedAbruptly 表示 worker 是否正常退出； true 说明用户任务处理过程中出现异常，false 是正常退出 \n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        // 若是异常退出的话，执行工作线程数减一\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        // 累加完成的任务数\n        completedTaskCount += w.completedTasks;\n        // 将 worker 从工作线程集合 workers 中移除\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    // 尝试终止线程池\n    tryTerminate();\n\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            // 计算线程池允许的最小线程数\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                // 若 min = 0，而 workQueue 不为空的话，说明有待处理的任务，则 min = 1，也就是至少有 1 个工作线程\n                min = 1;\n            // 若当前工作线程数 >= min, 则退出；反之创建新的 worker\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        // worker 非正常退出的话，重新创建新的 worker\n        addWorker(null, false);\n    }\n}\n```\n\n#### shutdown\n\n> 关闭线程池，运行状态改为 SHUTDOWN; 并中断空闲的工作线程\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 线程池状态修改为 SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        // 中断空闲 worker\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试终止线程池\n    tryTerminate();\n}\n```\n\n```java\nprivate void advanceRunState(int targetState) {\n    for (;;) {\n        int c = ctl.get();\n        // 当前状态值 小于 SHUTDOWN 的时候，执行更新\n        if (runStateAtLeast(c, targetState) ||\n            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))\n            break;\n    }\n}\n```\n\n```java\nprivate void interruptIdleWorkers() {\n    interruptIdleWorkers(false);\n}\n\n\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            if (!t.isInterrupted() && w.tryLock()) {\n                // worker 对应的线程未被中断过，且能够获取到锁，说明线程空闲（因为 worker 在获取到任务执行的时候，会 lock）\n                try {\n                    // 执行中断\n                    // 此时会唤醒阻塞在 workQueue.take 或 poll 操作上的 worker; 当 worker 在 getTask 继续轮询的时候会退出\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n```java\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        // 线程池状态为 STOP\n        // 线程池状态为 SHUTDOWN 且 workQueue 为空的时候可终止\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))\n            return;\n        // 工作线程数等于 0 的时候可终止\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            // 将工作线线程数改为 0，运行状态改为 TIDYING\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    // 执行终止操作，由子类实现\n                    terminated();\n                } finally {\n                    // 将运行状态改为 TERMINATED\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        // else retry on failed CAS\n    }\n    }\n```\n\n#### shutdownNow\n\n> 关闭线程池，运行状态修改为 STOP, 中断所有线程； 并返回未处理的任务\n\n```java\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 将线程池状态改为 STOP\n        advanceRunState(STOP);\n        // 中断所有的 Worder\n        interruptWorkers();\n        // 清除任务队列，并返回任务列表\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n```\n\n```java\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        // 将所有 worker 执行中断\n        for (Worker w : workers)\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n> 对于线程池的关闭操作 tryTerminate() 方法中的一段逻辑需要重点说明下，如下 \n```java\nif (workerCountOf(c) != 0) { // Eligible to terminate\n    interruptIdleWorkers(ONLY_ONE);\n    return;\n}\n```\n> interruptIdleWorkers(ONLY_ONE)是什么意思呢？中断闲置的Worker，直到回收全部的Worker。这里没有那么暴力，只中断一个，中断之后退出方法，中断了Worker之后，Worker会回收，然后还是会调用tryTerminate方法，如果还有闲置线程，那么继续中断\n\n> 譬如有个场景 ： 线程池在执行 shutdown 操作后，假设工作线程 A, B 还在执行任务，此时假设 workQueue 队列中还有一个任务； 当 A, B 分别在继续执行 getTask 时，有可能 A 先获取到任务，B 被阻塞到 workQueue.task() 操作上，如果不进行 interruptIdleWorkers(ONLY_ONE) 处理，那么工作线程 B 将一直存活而无法回收。\n\n\n","tags":["jdk","多线程"]},{"title":"Semaphore-源码分析","url":"/2018/12/15/Semaphore-的实现分析/","content":"## Semaphore\n\n> Semaphore 信号量：可以用来控制同时访问特定资源的线程数量；通过协调各个线程以保证合理的使用公共资源。\n\n<!-- more -->\n\n### 构造\n\n```java\n// permits 设置许可证的数量\npublic Semaphore(int permits) {\n    // 默认非公平\n    sync = new NonfairSync(permits);\n}\n// permits 设置许可数量\n// fair 设置是否采用公平模式\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n```\n### 非公平模式\n\n#### acquire()\n\n> 获取许可。只有当获取到可用的许可，或者当前线程被中断；否则该线程被阻塞\n\n```java\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n```\n默认会调用 NonfairSync 下的 tryAcquireShared 方法，继续调用父类的 nonfairTryAcquireShared 方法\n\n```java\nprotected int tryAcquireShared(int acquires) {\n    return nonfairTryAcquireShared(acquires);\n}\n```\n```java\nfinal int nonfairTryAcquireShared(int acquires) {\n    for (;;) {\n        // 获取当前 state 值\n        // 也即是当前可用的许可数\n        int available = getState();\n        // 当前可用许可数减去尝试获取许可的数\n        // 得到剩余许可数\n        int remaining = available - acquires;\n        // remaining < 0 说明当前可用许可数小于尝试获取许可数，也即是获取同步状态失败 直接返回 remaining, 退出循环 当前线程会被添加到同步队列中\n        // remaining > 0 说明当前可用许可数大于尝试获取许可数，\n        // 则执行 compareAndSetState 更新 state , 若更新成功则返回 退出循环 当前线程获取到许可\n        // 若 compareAndSetState 更新失败，说明有其他线程获取到许可，则继续轮询\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n\n#### release\n\n> 释放许可\n\n```java\npublic void release() {\n    sync.releaseShared(1);\n}\n```\n\n```java\nprotected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n        // 获取当前许可数\n        int current = getState();\n        // 当前许可 + 释放的许可数\n        int next = current + releases;\n        if (next < current) // overflow\n            throw new Error(\"Maximum permit count exceeded\");\n        // 更新 state 值, 更新成功则返回 true 退出循环；并唤醒同步队列上阻塞的线程\n        // 更新 state 值失败，说明有其他线程获取许可或释放了许可，则继续轮询\n        if (compareAndSetState(current, next))\n            return true;\n    }\n}\n```\n\n### 公平模式\n\n#### acquire\n\n> 公平模式下获取许可\n\n```java\nprotected int tryAcquireShared(int acquires) {\n    for (;;) {\n        // 判断同步队列上是否有阻塞的线程\n        // 若有的话，返回 -1 表示获取许可失败 退出循环加入同步队列中\n        if (hasQueuedPredecessors())\n            return -1;\n        int available = getState();\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n\n从上述代码中可以看到，公平模式下获取许可和非公平模式下基本类似，只是为了保证 FIFO ，添加了 hasQueuedPredecessors 判断限制。\n\n#### release\n\n> 公平模式下与非公平模式一样\n\n### 小结\n\nSemaphore 可以用来实现限流的作用。\n","tags":["jdk","多线程"]},{"title":"ReentrantReadWriteLock-读写锁源码分析","url":"/2018/12/13/ReentrantReadWriteLock-读写锁/","content":"### ReentrantReadWriteLock 读写锁\n\n> 读写锁不同于 ReentrantLock ，ReentrantLock 是排他锁同一时刻只允许一个线程访问，而读写锁同一时刻允许多个读线程访问，但是在写线程操作时，所有的读写操作均被阻塞。\n\n<!-- more -->\n\n#### 读写状态实现\n\n> 如何通过一个 int 值记录读状态，写状态呢 ?\n\n在 ReentrantReadWriteLock 中通过对同步状态值进行“按位切割”，因为 int 占 32 位 bit，故一分为二，采用高 16 位表示读状态，低 16 位表示写状态。\n\n##### 如何获取写状态值\n\n我们假设同步状态值转换为二进制如下：\n\n```java\n0000 0000 0000 0010 | 0000 0000 0000 0101\n```\n\n> 上述同步状态值表示：读状态为 2， 写状态为 5\n\n那么我们如何获取状态值呢 ？ 我们思考下位的相关运算 ：\n\n* 位与操作(&) 两个数同为 1 则为 1， 否则为 0\n* 位或操作(|) 两个数有一个为 1 则为 1， 否则为 0\n\n了解了 & ，| 运算规律我们是不是可以这样操作呢，将同步状态值与如下二进制进行 & 运算\n\n```java\n0000 0000 0000 0000 | 1111 1111 1111 1111\n```\n\n结果可得\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0101\n```\n\n也就是写状态的二进制表示，值为 5. 那么\n\n```java\n0000 0000 0000 0000 | 1111 1111 1111 1111\n```\n\n该位与操作数转成十进制也即是 65535 (2^15 + 2^14 + ..... + 2^0)，由`等比数列`可知等于 2^16 - 1, 也等于 (1 << 16) - 1 。 这也是 ReentrantReadWriteLock 内部定义的常量实现 ：\n\n```java\nstatic final int SHARED_SHIFT   = 16;\nstatic final int SHARED_UNIT    = (1 << SHARED_SHIFT);\nstatic final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\nstatic final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n```\n\n![](https://i.loli.net/2019/06/21/5d0c7dba4aa5563098.png)\n\n##### 如何获取读状态值\n\n获取读状态相比写状态来说就比较简单了，只需同步状态值 >> 右移 16 位即可\n\n![](https://i.loli.net/2019/06/21/5d0c7dbc528e669762.png)\n\n##### 写状态值加一\n\n当写锁重入的时候，如何更新写状态值呢 ? 我们知道状态值的低 16 位表示写状态，那么每次写状态加一操作相当于下面二进制相加操作（逢二进一）\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0011\n```\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0001\n```\n\n相加可得\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0100\n```\n\n也就是写状态值由 3 加一变成 4；那么对于写状态增加一时，也就是同步状态值 `S + 1` 即可。\n\n##### 读状态值加一\n\n读状态增加一，与写状态一样；只不过因为是高 16 位表示读状态，故是同步状态 `S + (1 << 16)`.\n\n#### 构造\n\n```java\npublic ReentrantReadWriteLock() {\n    this(false);\n}\n\npublic ReentrantReadWriteLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n    readerLock = new ReadLock(this);\n    writerLock = new WriteLock(this);\n}\n```\n#### writerLock() - 写锁\n\n```java\npublic ReentrantReadWriteLock.WriteLock writeLock() {\n  return writerLock;\n}\n```\n##### 获取锁\n\n当执行 writeLock.lock() 的时候，实际上调用的是 sync.acquire(), 如下：\n\n```java\npublic void lock() {\n    // 写锁是独占模式\n    sync.acquire(1);\n}\n```\n下面我们看下 sync 的 tryAcquire 实现如下：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n      /*\n       * Walkthrough:\n       * 1. If read count nonzero or write count nonzero\n       *    and owner is a different thread, fail.\n       * 2. If count would saturate, fail. (This can only\n       *    happen if count is already nonzero.)\n       * 3. Otherwise, this thread is eligible for lock if\n       *    it is either a reentrant acquire or\n       *    queue policy allows it. If so, update state\n       *    and set owner.\n       */\n      Thread current = Thread.currentThread();\n      // 获取同步状态值\n      int c = getState();\n      // 获取写状态值\n      int w = exclusiveCount(c);\n      if (c != 0) {\n          // (Note: if c != 0 and w == 0 then shared count != 0)\n          // c != 0 说明此时已经有读或有写或有读写\n          // 若 w == 0 说明此时有读操作，则获取写锁失败\n          // 若 w != 0 说明此时已经有写操作\n          // 若 current != getExclusiveOwnerThread() 说明当前获取写锁的线程并非是写锁对象的持有者, 则重入失败\n          if (w == 0 || current != getExclusiveOwnerThread())\n              return false;\n          // 重入次数超过最大值 抛出异常\n          if (w + exclusiveCount(acquires) > MAX_COUNT)\n              throw new Error(\"Maximum lock count exceeded\");\n          // Reentrant acquire\n          // 设置状态值\n          setState(c + acquires);\n          return true;\n      }\n      if (writerShouldBlock() ||\n          !compareAndSetState(c, c + acquires))\n          return false;\n      // 设置当前线程为写锁的持有者\n      setExclusiveOwnerThread(current);\n      return true;\n  }\n```\n从代码的实现及注释中所描述的内容，可得知以下场景会获取写锁失败 :\n\n* 当前已经有读操作，则获取写锁失败\n* 当前已经有写操作，但当前线程并非写锁对象的持有者，则获取写锁失败（也是重入失败）\n* 当前没有任何操作，CAS 更新状态值失败，则获取写锁失败\n\n##### 释放锁\n\n```java\nprotected final boolean tryRelease(int releases) {\n    // 判断当前线程是否为写锁对象的持有者\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    // 同步状态值释放\n    int nextc = getState() - releases;\n    // 判断写状态是否为 0; 写状态为 0 说明写锁完成释放\n    boolean free = exclusiveCount(nextc) == 0;\n    if (free)\n        // 清空写锁的持有者\n        setExclusiveOwnerThread(null);\n    setState(nextc);\n    return free;\n}\n```\n\n#### readLock() - 读锁\n\n```java\npublic ReentrantReadWriteLock.ReadLock  readLock()  {\n  return readerLock;\n}\n```\n\n##### 获取锁\n\n```java\npublic void lock() {\n    sync.acquireShared(1);\n}\n```\n\n> 因为读写锁是支持同时多个线程获取读锁，所以调用的是 sync 共享式获取同步状态。 这里针对读锁的获取和释放我们简化下实现忽略对读锁计数统计的操作。\n\n```java\nprotected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n   \n    for (;;) {\n        // 获取读状态值\n        int c = getState();\n        // exclusiveCount(c) != 0 说明有写操作\n        // getExclusiveOwnerThread != current 说明当前线程非写锁的对象持有者; 则获取读锁失败\n        // 若 getExclusiveOwnerThread == current 也就是说明线程获取写锁之后是可以继续获取读锁的\n        if (exclusiveCount(c) != 0) {\n            if (getExclusiveOwnerThread() != current)\n                return -1;\n            // else we hold the exclusive lock; blocking here\n            // would cause deadlock.\n        }\n        if (sharedCount(c) == MAX_COUNT)\n            throw new Error(\"Maximum lock count exceeded\");\n        if (compareAndSetState(c, c + SHARED_UNIT)) {\n            // 忽略读锁计数统计的操作 \n            return 1;\n        }\n    }\n}\n```\n\n##### 释放锁\n\n```java\nprotected final boolean tryReleaseShared(int unused) {\n    Thread current = Thread.currentThread();\n    // 忽略读锁计数统计的操作 \n    for (;;) {\n        int c = getState();\n        int nextc = c - SHARED_UNIT;\n        if (compareAndSetState(c, nextc))\n            // Releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            return nextc == 0;\n    }\n}\n```\n\n#### 小结\n\n* 读写锁的实现关键在于如何通过一个 int 值，分别记录读写状态。（采用按位切割，高 16 位为读状态，低 16 位状态）\n* 何时可以获取读锁 ?  获取写锁的线程可以再次获取读锁，获取读锁的线程数未超过 2^16 - 1 时是可以获取读锁。\n* 何时可以获取写锁 ?  已经有读锁在操作则不可用获取写锁\n\n","tags":["jdk","多线程"]},{"title":"ReentrantLock-重入锁源码分析","url":"/2018/12/11/ReentrantLock-重入锁源码分析/","content":"### ReentrantLock\n\n> 重入锁, 表示该锁支持一个线程对资源的重复加锁\n\n<!-- more -->\n\n#### 类结构\n\n首先让我们先看下 ReentrantLock 的类结构如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7db84264726957.png)\n\n从图中我们可以看出 ReentrantLock 实现 Lock 接口，同时内部类 Sync 是 AQS 的子类；而 Sync 又有两个子类 NonfairSync 和 FairSync 分别对应非公平和公平锁两种策略。\n\n#### 构造\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n```\n```java\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n> ReentrantLock 默认采用非公平的策略，也可以在构造的时候指定是否公平的策略。\n\n#### 非公平锁\n\n> 非公平锁是指在竞争获取锁的过程中，有可能后来者居上\n\n##### lock() 获取锁\n\n```java\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n\n    /**\n     * Performs lock.  Try immediate barge, backing up to normal\n     * acquire on failure.\n     */\n    final void lock() {\n    \t// CAS 设置 state 值为 1\n        if (compareAndSetState(0, 1))\n        \t// CAS 成功则说明获取到锁, 此时将当前线程设置为独占模式下锁对象的持有者\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n        \t// CAS 失败\n        \t// 可能是同一线程再次获取锁\n        \t// 也可能是不同线程获取锁\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n    \t// 调用父类 sync\n        return nonfairTryAcquire(acquires);\n    }\n}\n```\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n      // 此时说明已有线程释放了锁\n      // 有可能是同步队列里阻塞的线程被唤醒时尝试获取锁\n        if (compareAndSetState(0, acquires)) {\n        \t// CAS 成功则说明获取到锁, 此时将当前线程设置为独占模式下锁对象的持有者\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n    \t// 说明同一线程再次获取锁\n    \t// state 加 1\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n获取锁的过程如下 ：\n\n* 通过 CAS 操作， 设置 state = 1\n* 若 CAS 操作成功，则将当前线程设置为独占模式锁对象的持有者\n* 若 CAS 操作失败, 最终会调用 sync 的方法 nonfairTryAcquire; 此时说明可能是同一线程再次尝试获取锁，也有可能是其他线程尝试获取锁\n* 若当前 state == 0, 继续执行前两步操作\n* 若当前 state != 0, 则判断当前线程是否为锁的持有者；若判断成立，则对 state + 1\n\n##### unlock() - 释放锁\n\n> 非公平锁的释放调用的是父类 sync 的 tryRelease 方法\n\n```java\nprotected final boolean tryRelease(int releases) {\n    // state 减一操作\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        // 当前线程不是当前锁的持有者时抛出异常\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        // 只有 state == 0 时 才是真正完成锁的释放\n        free = true;\n        // 将锁的持有者清空\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n从释放锁的实现可以看出，获取锁与释放锁的操作是对等的，譬如下方伪代码：\n\n```java\nReentrantLock lock = new ReentrantLock();\n\npublic void do () {\n  lock.lock();\n\n  try {\n\n    do();\n    // 退出递归\n\n  } finally {\n    lock.unlock();\n  }\n}\n\n```\n\n#### 公平锁\n\n> 公平锁是指获取锁的顺序完全符合请求时间的顺序，也就是先到先得\n\n##### lock() - 获取锁\n\n接下来我们下公平锁与非公平锁在获取锁时有什么不同\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        // 不同于非公平锁操作，公平锁多了个判断条件 hasQueuedPredecessors\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n```java\npublic final boolean hasQueuedPredecessors() {\n    // The correctness of this depends on head being initialized\n    // before tail and on head.next being accurate if the current\n    // thread is first in queue.\n    Node t = tail; // Read fields in reverse initialization order\n    Node h = head;\n    Node s;\n    // h != t 说明同步队列已有等待的节点\n    // s = h.next == null 这个有点没明白; head 的后置为空应该就是 head == tail 吧\n    // s.thread != Thread.currentThread 是判断当前线程是不是同步队列的首个阻塞线程 如果是是允许获取到锁的\n    return h != t &&\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n```\n\n```\nQueries whether any threads have been waiting to acquire longer than the current thread.\n```\n\nhasQueuedPredecessors 方法主要实现的是查找是否有等待时间超过当前线程的其他线程, 公平锁也就是通过该方法保证获取锁的有序性。\n\n##### unlock() - 释放锁\n\n公平锁的释放与非公平锁的释放操作一致\n\n#### 小结\n\n- ReentrantLock 如何实现可重入 ? (通过判断当前线程是否为当前锁对象的持有者)\n- 如何实现公平锁 ? (若当前同步队列中有等待的节点则获取锁失败)\n- 非公平锁和公平锁对性能有什么影响 ? (公平锁会造成大量的线程切换，非公平锁会出现线程“饥饿”现象，但线程切换少提高吞吐量)\n","tags":["jdk","多线程"]},{"title":"CyclicBarrier 同步屏障的源码分析","url":"/2018/12/09/CyclicBarrier-同步屏障的实现分析/","content":"### CyclicBarrier\n\n> CyclicBarrier 是可循环使用的屏障，主要功能是让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开；所有被屏障拦截的线程才会继续执行。\n\n<!-- more -->\n\n#### 使用示例\n\n```java\npublic class CyclicBarrierTest {\n\n    // 线程个数\n    private int parties = 3;\n\n    private AtomicInteger atomicInteger = new AtomicInteger(parties);\n\n    private CyclicBarrier cyclicBarrier;\n\n    class Protector implements Runnable {\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(Thread.currentThread().getName() + \" - 到达屏障前\");\n\n                TimeUnit.SECONDS.sleep(2);\n\n                cyclicBarrier.await();\n\n                atomicInteger.decrementAndGet();\n\n                System.out.println(Thread.currentThread().getName() + \" - 到达屏障后\");\n\n            } catch (InterruptedException e) {\n                System.out.println(Thread.currentThread().getName() + \" - 等待中断\");\n            } catch (BrokenBarrierException e) {\n                System.out.println(Thread.currentThread().getName() + \" - 屏障被破坏\");\n            }\n        }\n    }\n\n\n    @Before\n    public void init() {\n        cyclicBarrier = new CyclicBarrier(parties);\n    }\n\n    @Test\n    public void allAwait() {\n        for (int i = 0; i < parties; i++) {\n            new Thread(new Protector(), \"Thread-\" + i).start();\n        }\n\n        while (true) {\n            if (atomicInteger.get() == 0) {\n                // 所有线程到达屏障后退出结束\n                System.out.println(\"test over\");\n                break;\n            }\n        }\n    }\n\n    @Test\n    public void oneAwaitInterrupted() throws InterruptedException {\n        Thread threadA = new Thread(new Protector(), \"Thread-A\");\n        Thread threadB = new Thread(new Protector(), \"Thread-B\");\n\n        threadA.start();\n        threadB.start();\n        // 等待 3 秒，避免是 time sleep 触发中断异常\n        TimeUnit.SECONDS.sleep(3);\n\n        threadA.interrupt();\n\n        while (true) {\n            if (atomicInteger.get() == 0) {\n                System.out.println(\"test over\");\n                break;\n            }\n            if (cyclicBarrier.isBroken()) {\n                System.out.println(\"屏障中断退出\");\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\nThread-A - 到达屏障前\nThread-B - 到达屏障前\n屏障中断退出\nThread-A - 等待中断\nThread-B - 屏障被破坏\n\nThread-0 - 到达屏障前\nThread-1 - 到达屏障前\nThread-2 - 到达屏障前\nThread-2 - 到达屏障后\nThread-0 - 到达屏障后\nThread-1 - 到达屏障后\ntest over\n```\n从 oneAwaitInterrupted 方法执行结果可以看出，当一个线程 A 执行中断时，另外一个线程 B 会抛出 BrokenBarrierException\n\n#### 构造\n\n```java\n// 可以指定拦截线程个数\npublic CyclicBarrier(int parties) {\n    this(parties, null);\n}\n\n// 指定拦截线程个数和所有线程到达屏障处后执行的动作\npublic CyclicBarrier(int parties, Runnable barrierAction) {\n    if (parties <= 0) throw new IllegalArgumentException();\n    this.parties = parties;\n    this.count = parties;\n    this.barrierCommand = barrierAction;\n}\n```\n\n#### 实现\n\n##### 概念\n\n* barrier : 屏障\n* parties : 为屏障拦截的线程数\n* tripped : 跳闸，可以理解为打开屏障\n* generation.broken : 屏障是否破损，当屏障被打开或被重置的时候会改变值\n\n> 简单的理解就是，当线程都到达屏障的时候，会打开屏障。\n\n##### await()\n\n> await 说明线程到达屏障\n\n```java\npublic int await() throws InterruptedException, BrokenBarrierException {\n    try {\n        return dowait(false, 0L);\n    } catch (TimeoutException toe) {\n        throw new Error(toe); // cannot happen\n    }\n}\n```\n\n```java\nprivate int dowait(boolean timed, long nanos)\n        throws InterruptedException, BrokenBarrierException,\n               TimeoutException {\n    final ReentrantLock lock = this.lock;\n    // 获取排他锁\n    lock.lock();\n    try {\n        final Generation g = generation;\n        // 屏障被破坏则抛异常\n        if (g.broken)\n            throw new BrokenBarrierException();\n\n        if (Thread.interrupted()) {\n        \t// 线程中断 则退出屏障\n            breakBarrier();\n            throw new InterruptedException();\n        }\n\n        // 到达屏障的计数减一\n        int index = --count;      \n        if (index == 0) {  // tripped\n        \t// index == 0, 说明指定 count 的线程均到达屏障\n        \t// 此时可以打开屏障\n            boolean ranAction = false;\n            try {\n                final Runnable command = barrierCommand;\n                if (command != null)\n                \t// 若指定了 barrierCommand 则执行\n                    command.run();\n                ranAction = true;\n                // 唤醒阻塞在屏障的线程并重置 generation\n                nextGeneration();\n                return 0;\n            } finally {\n                if (!ranAction)\n                    breakBarrier();\n            }\n        }\n\n        // loop until tripped, broken, interrupted, or timed out\n        for (;;) {\n            try {\n                if (!timed)\n                \t// 若未指定阻塞在屏障处的等待时间，则一直等待；直至最后一个线程到达屏障处的时候被唤醒\n                    trip.await();\n                else if (nanos > 0L)\n                \t// 若指定了阻塞在屏障处的等待时间，则在指定时间到达时会返回\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) {\n                if (g == generation && ! g.broken) {\n                \t// 若等待过程中，线程发生了中断，则退出屏障\n                    breakBarrier();\n                    throw ie;\n                } else {\n                    // We're about to finish waiting even if we had not\n                    // been interrupted, so this interrupt is deemed to\n                    // \"belong\" to subsequent execution.\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            // 屏障被破坏 则抛出异常\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            if (g != generation)\n            \t// g != generation 说明所有线程均到达屏障处 可直接返回\n            \t// 因为所有线程到达屏障处的时候，会重置 generation\n            \t// 参考 nextGeneration\n                return index;\n\n            if (timed && nanos <= 0L) {\n            \t// 说明指定时间内，还有线程未到达屏障处，也就是等待超时\n            \t// 退出屏障\n                breakBarrier();\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n```java\nprivate void nextGeneration() {\n    // signal completion of last generation\n    // 唤醒阻塞在等待队列的线程\n    trip.signalAll();\n    // set up next generation\n    // 重置 count\n    count = parties;\n    // 重置 generation\n    generation = new Generation();\n}\n```\n\n```java\nprivate void breakBarrier() {\n\t// broken 设置为 true\n    generation.broken = true;\n    // 重置 count\n    count = parties;\n    // 唤醒等待队列的线程\n    trip.signalAll();\n}\n```\n\n如下图为 CyclicBarrier 实现效果图：\n\n![](https://i.loli.net/2019/06/21/5d0c7d7db330d70388.gif)\n\n##### isBroken()\n\n> 返回屏障是否被破坏，也是是否被中断\n\n```java\npublic boolean isBroken() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        return generation.broken;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n##### reset()\n\n```java\npublic void reset() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 唤醒阻塞的线程\n        breakBarrier();   // break the current generation\n        // 重新设置 generation\n        nextGeneration(); // start a new generation\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n##### getNumberWaiting\n\n> 获取阻塞在屏障处的线程数\n\n```java\npublic int getNumberWaiting() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 拦截线程数 - 未到达屏障数\n        return parties - count;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n#### 小结\n\nCyclicBarrier 和 CountDownLatch 功能类似，不同之处在于 CyclicBarrier 支持重复利用，而 CountDownLatch 计数只能使用一次。\n","tags":["jdk","多线程"]},{"title":"CountDownLatch-源码分析","url":"/2018/12/07/CountDownLatch实现分析/","content":"### CountDownLatch\n\n> CountdownLatch 是 JDK 并发包中提供的并发工具类，其允许一个或多个线程等待其他线程完成操作。常用作将一个任务拆分成多个子任务同时执行，只有子任务都执行完毕主线程才往下执行。\n\n<!-- more -->\n\n#### 使用示例\n\n```java\npublic class App implements Runnable\n{\n    private CountDownLatch countDownLatch;\n\n    public App (CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    public static void main( String[] args )\n    {\n    \t// 指定同时运行3个子任务\n        int count = 3;\n\n        CountDownLatch countDownLatch = new CountDownLatch(count);\n\n        for (int i = 0; i < count; i++) {\n            new Thread(new App(countDownLatch), \"Thread-\" + i).start();\n        }\n\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n        }\n\n        System.out.println(\"count down over !\");\n    }\n\n    @Override\n    public void run() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n\n            System.out.println(Thread.currentThread().getName() + \" - 执行完毕.\" );\n\n        } catch (InterruptedException e) {\n        } finally {\n            countDownLatch.countDown();\n        }\n    }\n}\n\n```\n运行结果如下：\n\n```java\nThread-2 - 执行完毕.\nThread-0 - 执行完毕.\nThread-1 - 执行完毕.\ncount down over !\n```\n从结果中可以看出 main 主线程会在 3 个子线程处理完毕之后才继续执行。\n\n#### 构造\n\n```java\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n```\n\nCountDownLatch 与其他同步组件一样，内部类 Sync 继承了 AQS，构造的时候会指定子任务个数 count , 也即是同步状态初始值。\n\n#### await()\n\n```java\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n```\n\n接下来看下 sync 获取共享同步状态的实现\n\n```java\nprotected int tryAcquireShared(int acquires) {\n\t// state == 0 的时候返回 1，反之返回 -1\n\t// state != 0 说明还有子任务未处理完\n    return (getState() == 0) ? 1 : -1;\n}\n```\n\n从实现可以看出 await() 方法执行时，当子任务未处理完毕时(state ！= 0)，调用线程会被添加到同步队列而阻塞等待。\n\n#### countDown()\n\n```java\npublic void countDown() {\n    sync.releaseShared(1);\n}\n```\n\n接下来看下 sync 的共享同步状态值释放\n\n```java\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    for (;;) {\n        int c = getState();\n        if (c == 0)\n            return false;\n        // 每次释放的时候，也就是子任务完成的时候计数值减一\n        int nextc = c-1;\n        // 更新 state 值\n        if (compareAndSetState(c, nextc))\n        \t// 子任务均处理完毕后，返回 true； 也就是真正的释放\n        \t// 将唤醒阻塞在同步队列的线程\n            return nextc == 0;\n    }\n}\n```\n\n从实现可以看出，每次子任务在调用 countDown 时，会将同步状态值减一，当所有子任务均完成时 (state = 0) 此时会唤醒阻塞在同步队列的节点。\n\n#### 小结\n\n子任务在进行 countDown 操作时，最好是在 finally 块处理； 避免出现子任务处理异常，导致主线程一直阻塞的问题。\n","tags":["jdk","多线程"]},{"title":"AQS 之 Condition-的源码分析","url":"/2018/12/05/AQS 之 Condition/","content":"\n> 在使用 Lock 锁的过程中，我们往往会使用到另外一个对象 Condition ，用于等待/通知模式的处理。\n\n<!-- more -->\n\n#### Condition 的创建\n\n```java\n\tLock lock = new ReentrantLock();\n\tCondition condition = lock.newCondition();\n```\n\n使用 Condition 的前提是获取锁\n\n```java\nfinal ConditionObject newCondition() {\n    return new ConditionObject();\n}\n```\n\n从 newCondition 方法看出 Condition 对象实际上是 AQS 的内部类 ConditionObject ()。\n\n#### 成员变量\n\n```java\n/** First node of condition queue. */\nprivate transient Node firstWaiter;\n/** Last node of condition queue. */\nprivate transient Node lastWaiter;\n```\n\n从内部定义的变量 firstWaiter, lastWaiter 看出， ConditionObject 对象内部维护了一个同样以 Node 为节点的等待队列。\n\n#### await()\n\n> await 操作会使当前线程释放锁并进入等待模式。\n\n```java\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n    \t// 当前线程中断 抛出中断异常\n        throw new InterruptedException();\n    // 将当前线程构造节点插入等待队列尾部\n    Node node = addConditionWaiter();\n    // 当前线程释放锁，唤醒同步队列 head 的后置节点\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 节点添加到同步队列后 退出循环\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        // 应该是在其他线程释放锁后被唤醒\n        // 检查当前线程是否中断，若未中断则返回 0\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // node 进入自旋过程尝试获取锁\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n\n```java\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // If lastWaiter is cancelled, clean out.\n    if (t != null && t.waitStatus != Node.CONDITION) {\n    \t// 移除等待队列中状态非 CONDITION 的节点\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    // 将当前线程构造节点并设置状态为 CONDITION\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    if (t == null)\n    \t// 等待队列为空的时候将 firstWaiter 指向 node\n        firstWaiter = node;\n    else\n    \t// 等待队列非空时将 lastWaiter 尾节点的 nextWaiter 指向 node\n        t.nextWaiter = node;\n    // 移动尾节点\n    lastWaiter = node;\n    return node;\n}\n```\n\n```java\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        // 当前线程释放锁，并唤醒同步队列中 head 的后置节点\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n```\n\n```java\n// 判断节点是否在同步队列上\nfinal boolean isOnSyncQueue(Node node) {\n\t// 节点状态为 CONDITION 或 节点的前置为空 说明节点还在等待队列上\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    // 如果节点存在后置节点 next 则说明节点在同步队列上\n    if (node.next != null) // If has successor, it must be on queue\n        return true;\n    /*\n     * node.prev can be non-null, but not yet on queue because\n     * the CAS to place it on queue can fail. So we have to\n     * traverse from tail to make sure it actually made it.  It\n     * will always be near the tail in calls to this method, and\n     * unless the CAS failed (which is unlikely), it will be\n     * there, so we hardly ever traverse much.\n     */\n    // 从 tail 尾节点开始遍历同步队列查找 node 节点；若存在返回 true,反之返回 false\n    return findNodeFromTail(node);\n}\n```\n\nawait 操作流程如下 ：\n\n* 将当前线程构造一个新的 node 节点，状态为 CONDITION 添加到等待队列尾部\n* 释放锁，唤醒同步队列 head 的后置节点\n* 判断当前 node 节点是否在同步队列中，若不在同步队列上则挂起当前线程，等待其他线程释放锁时被唤醒\n* 节点 node 被唤醒后若在同步队列上，则进入自旋过程再次尝试获取锁\n\n#### signal()\n\n> signal 操作激活等待队列中节点\n\n```java\npublic final void signal() {\n\t// 判断当前线程是否为锁的持有者\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n```\n\n```java\nprivate void doSignal(Node first) {\n    do {\n    \t// 判断 first 的后置节点是否为空，为空说明等待队列为空\n        if ( (firstWaiter = first.nextWaiter) == null)\n        \t// 等待队列的尾节点置为空\n            lastWaiter = null;\n        // 将 first 的后置节点置为空，也即是将 first 节点从等待队列中移除\n        first.nextWaiter = null;\n\n        // 执行信号转移\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n}\n```\n\n```java\n// 将节点从等待队列 (condition queue) 转移到 同步队列 (sync queue)\nfinal boolean transferForSignal(Node node) {\n\t/*\n\t * If cannot change waitStatus, the node has been cancelled.\n\t */\n\t// 将节点状态设置为 0\n\tif (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n\t    return false;\n\n\t/*\n\t * Splice onto queue and try to set waitStatus of predecessor to\n\t * indicate that thread is (probably) waiting. If cancelled or\n\t * attempt to set waitStatus fails, wake up to resync (in which\n\t * case the waitStatus can be transiently and harmlessly wrong).\n\t */\n\t// 将节点添加到同步队列(sync queue)尾部， 此时 p 应该是 node 的前置节点 ws 为 0\n\tNode p = enq(node);\n\t// \n\tint ws = p.waitStatus;\n\t// 将 node 的前置节点状态改为 SIGNAL; 便于节点 p 释放锁的时候唤醒 node\n\tif (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n\t    LockSupport.unpark(node.thread);\n\treturn true;\n\t}\n```\n\nsignal 操作的流程如下：\n\n* 将等待队列中的节点从队列中移除\n* 将等待队列中的节点状态由 CONDITION 改为 0\n* 将等待队列中的节点添加到 AQS 的同步队列尾部\n\n> signal 的作用 只是将节点从等待队列转移到同步队列中，只有当前线程释放锁后，转移到同步队列的节点才会有机会获取到锁。\n\n如下图所示为 Condition 操作节点的转移过程：\n\n![](https://i.loli.net/2019/06/21/5d0c7d7a3617c38746.png)\n\n### 小结\n\n从 Condition 的 await()、signal() 操作可以看出，其作用等效于 Object 对象的 await(), notify() 方法； \n","tags":["jdk","多线程"]},{"title":"AbstractQueuedSynchronizer 队列同步器源码分析-共享锁","url":"/2018/12/04/AbstractQueuedSynchronizer 队列同步器源码分析-共享锁/","content":"### AQS 共享式同步状态获取和释放\n\n> 上一篇文章中主要分析了 AQS 的独占模式对同步状态的获取和释放过程，本文主要分析下共享模式下的同步状态的获取和释放是如何实现的\n\n<!-- more -->\n\n### 共享锁获取\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n    \t// 获取锁失败\n        doAcquireShared(arg);\n}\n```\n\n```java\nprivate void doAcquireShared(int arg) {\n\t// 不同于独占模式下，创建的节点模式不同\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                \t// 不同独占模式\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n从 doAcquireShared 实现可以看出，共享模式下同步队列的节点在自旋的过程与独占模式基本类似，不同在于自旋过程中成功获取同步状态时的处理 \n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n    \n    // 若 progagate > 0 说明可继续向下传播唤醒节点\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n从 setHeadAndPropagate 的实现我们可以看出在移动 head 节点之后，若满足继续往下传播唤醒的条件时将会调用 doReleaseShared 方法。\n\n#### 共享锁释放\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n    \t// 释放同步状态\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n``\n\n```java\nprivate void doReleaseShared() {   \n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n            \t// 将 head 节点状态重置为 0\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                // CAS 成功则唤醒下个节点\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        // 头节点指向未发生变化的时候 退出循环\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n因共享模式下，会存在多个线程同时释放同步状态的场景， doReleaseShared 通过不断的轮询和 CAS 操作保证节点的唤醒。\n我们还是以图的形式模拟下多线程释放的场景：\n\n![](https://i.loli.net/2019/06/21/5d0c7d6ccbb2872851.png)\n","tags":["jdk","多线程"]},{"title":"AbstractQueuedSynchronizer 队列同步器源码分析","url":"/2018/12/02/AbstractQueuedSynchronizer-队列同步器源码分析/","content":"### AbstractQueuedSynchronizer 队列同步器（AQS）\n\n> 队列同步器 (AQS), 是用来构建锁或其他同步组件的基础框架，它通过使用 int 变量表示同步状态，通过内置的 FIFO 的队列完成资源获取的排队工作。（摘自《Java并发编程的艺术》）\n\n我们知道获取同步状态有独占和共享两种模式，本文先针对独占模式进行分析。\n\n<!-- more -->\n\n#### 变量定义\n\n```java\nprivate transient volatile Node head;\n```\n\nhead 同步队列头节点\n\n```java\nprivate transient volatile Node tail;\n```\n\ntail 同步队列尾节点\n\n```java\nprivate volatile int state;\n```\n\nstate 同步状态值\n\n#### Node - 同步队列节点定义\n\n```java\nvolatile int waitStatus;\n```\nwaitStatus 节点的等待状态，可取值如下 :\n\n* 0 : 初始状态\n* -1 : SIGNAL 处于该状态的节点，说明其后置节点处于等待状态； 若当前节点释放了锁可唤醒后置节点\n* -2 : CONDITION 该状态与 Condition 操作有关后续在说明\n* -3 : PROPAGATE 该状态与共享式获取同步状态操作有关后续在说明\n* 1 : CANCELLED 处于该状态的节点会取消等待，从队列中移除\n\n```java\nvolatile Node prev;\n```\n\nprev 指向当前节点的前置节点\n\n```java\nvolatile Node next;\n```\n\nnext 指向当前节点的后置节点\n\n```java\nvolatile Thread thread;\n```\n\nthread 节点对应的线程也是指当前获取锁失败的线程\n\n```java\nNode nextWaiter;\n```\n\n#### acquire()\n\n> 独占模式下获取同步状态， 既是当前只允许一个线程获取到同步状态\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n从 acquire 方法中我们可以大概猜测下，获取锁的过程如下：\n\n* tryAcquire 尝试获取同步状态， 具体如何判定获取到同步状态由子类实现\n* 当获取同步状态失败时，执行 addWaiter 创建独占模式下的 Node 并将其添加到同步队列尾部\n* 加入同步队列之后，再次尝试获取同步状态，当达到某种条件的时候将当前线程挂起等待唤醒\n\n下面具体看下各个阶段如何实现：\n\n```java\nprivate Node addWaiter(Node mode) {\n\t// 绑定当前线程 创建 Node 节点\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    // 判断同步队列尾节点是否为空\n    if (pred != null) {\n    \t// node 的前置节点指向队列尾部\n        node.prev = pred;\n        // 将同步队列的 tail 移动指向 node\n        if (compareAndSetTail(pred, node)) {\n        \t// 将原同步队列的尾部后置节点指向 node\n            pred.next = node;\n            return node;\n        }\n    }\n    // tail 为空说明同步队列还未初始化\n    // 此时调用 enq 完成队列的初始化及 node 入队\n    enq(node);\n    return node;\n}\n```\n\n```java\nprivate Node enq(final Node node) {\n\t// 轮询的方式执行\n\t// 成功入队后退出\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n        \t// 创建 Node, 并将 head 指向该节点\n        \t// 同时将 tail 指向该节点\n        \t// 完成队列的初始化\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n        \t// node 的前置节点指向队列尾部\n            node.prev = t;\n            // 将同步队列的 tail 移动指向 node\n            if (compareAndSetTail(t, node)) {\n            \t// 将原同步队列的尾部后置节点指向 node\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n从代码中可以看出通过 CAS 操作保证节点入队的有序安全，其入队过程中如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7d7198e6761216.png)\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        // \n        for (;;) {\n        \t// 获取当前节点的前置节点\n            final Node p = node.predecessor();\n            // 判断前置节点是否为 head 头节点\n            // 若前置节点为 head 节点，则再次尝试获取同步状态\n            if (p == head && tryAcquire(arg)) {\n            \t// 若获取同步状态成功\n            \t// 则将队列的 head 移动指向当前节点\n                setHead(node);\n                // 将原头部节点的 next 指向为空，便于对象回收\n                p.next = null; // help GC\n                failed = false;\n                // 退出轮询过程\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n    \t// 若前置节点状态为 -1 ，则说明后置节点 node 可以安全挂起了\n        return true;\n    if (ws > 0) {\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do {\n        \t// ws > 0 说明前置节点状态为 CANCELLED , 也就是说前置节点为无效节点\n        \t// 此时从前置节点开始向队列头节点方向寻找有效的前置节点\n        \t// 此操作也即是将 CANCELLED 节点从队列中移除\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        // 若前置节点状态为初始状态 则将其状态设为 -1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n\t// 将当前线程挂起\n    LockSupport.park(this);\n    // 被唤醒后检查当前线程是否被挂起\n    return Thread.interrupted();\n}\n```\n\n从 acquireQueued 的实现可以看出，节点在入队后会采用轮询的方式（自旋）重复执行以下过程：\n\n* 判断前置节点是否为 head， 若为 head 节点则尝试获取同步状态； 若获取同步状态成功则移动 head 指向当前节点并退出循环\n* 若前置节点非 head 节点或者获取同步状态失败，则将前置节点状态修改为 -1， 并挂起当前线程，等待被唤醒重复执行以上过程\n\n如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7d750150f78988.png)\n\n接下来我们看看同步状态释放的实现。\n\n#### release\n\n> 释放同步状态\n\n```java\npublic final boolean release(int arg) {\n\t// 尝试释放同步状态\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n        \t// 唤醒后置节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n```java\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus;\n    if (ws < 0)\n    \t// 将 head 节点状态改为 0\n        compareAndSetWaitStatus(node, ws, 0);\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    // 获取后置节点\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n    \t// 唤醒后置节点上所阻塞的线程\n        LockSupport.unpark(s.thread);\n}\n```\n\n从上述代码，我们可以明白释放同步状态的过程如下：\n\n* 调用 tryRelease 尝试释放同步状态，同样其具体的实现由子类控制\n* 成功释放同步状态后，将 head 节点状态改为 0\n* 唤醒后置节点上阻塞的线程\n\n如下图所示（红色曲线表示节点自旋过程） :\n\n![](https://i.loli.net/2019/06/21/5d0c7d774e37b54306.png)\n\n\n#### acquireInterruptibly()\n\n> 独占模式下获取同步状态，不同于 acquire 方法，该方法对中断操作敏感； 也就是说当前线程在获取同步状态的过程中，若被中断则会抛出中断异常\n\n```java\npublic final void acquireInterruptibly(int arg)\n            throws InterruptedException {\n    if (Thread.interrupted())\n    \t// 检查线程是否被中断\n    \t// 中断则抛出中断异常由调用方处理\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n```\n\n```java\nprivate void doAcquireInterruptibly(int arg)\n        throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                // 不同于 acquire 的操作，此处在唤醒后检查是否中断，若被中断直接抛出中断异常\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n        \t// 抛出中断异常后最终执行 cancelAcquire\n            cancelAcquire(node);\n    }\n}\n```\n\n```java\nprivate void cancelAcquire(Node node) {\n        // Ignore if node doesn't exist\n    if (node == null)\n        return;\n\n    node.thread = null;\n\n    // Skip cancelled predecessors\n    Node pred = node.prev;\n    while (pred.waitStatus > 0)\n        node.prev = pred = pred.prev;\n\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    Node predNext = pred.next;\n\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    node.waitStatus = Node.CANCELLED;\n\n    // If we are the tail, remove ourselves.\n    // 若当前节点为 tail 节点，则将 tail 移动指向 node 的前置节点\n    if (node == tail && compareAndSetTail(node, pred)) {\n    \t// 同时将node 前置节点的 next 指向 null\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred's next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n            pred.thread != null) {\n        \t// 当前节点位于队列中部    \n            Node next = node.next;\n            if (next != null && next.waitStatus <= 0)\n            \t// 将前置节点的 next 指向 node 的后置节点\n                compareAndSetNext(pred, predNext, next);\n        } else {\n        \t// 若 node 的前置节点为 head 节点则唤醒 node 节点的后置节点\n            unparkSuccessor(node);\n        }\n\n        node.next = node; // help GC\n    }\n}\n```\n\n从 acquireInterruptibly 的实现可以看出，若线程在获取同步状态的过程中出现中断操作，则会将当前线程对应的同步队列等待节点从队列中移除并唤醒可获取同步状态的线程。\n\n#### tryAcquireNanos()\n\n> 独占模式超时获取同步状态，该操作与acquireInterruptibly一样对中断操作敏感，不同在于超过等待时间若未获取到同步状态将会返回\n\n```java\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n            throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    return tryAcquire(arg) ||\n        doAcquireNanos(arg, nanosTimeout);\n}\n```\n```java\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n            throws InterruptedException {\n    if (nanosTimeout <= 0L)\n        return false;\n    // 计算等待到期时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout <= 0L)\n            \t// 超时时间到期直接返回\n                return false;\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                // 按指定时间挂起s\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n\n#### 节点的状态\n\n同步队列中的节点在自旋获取同步状态的过程中，会将前置节点的状态由 0 初始状态改为 -1 SIGNAL, 若是中断敏感的操作则会将状态由 0 改为 1\n\n同步队列中的节点在释放同步状态的过程中会将同步队列的 head 节点的状态改为 0， 也即是由 -1 变为 0；\n\n#### 小结\n\n本文主要分析了独占模式获取同步状态的操作，其大概流程如下：\n\n* 在获取同步状态时，AQS 内部维护了一个同步队列，获取状态失败的线程会被构造一个节点加入到队列中并进行一系列自旋操作\n* 在释放同步状态时，唤醒 head 的后置节点去获取同步状态\n","tags":["jdk","多线程"]},{"title":"TCP：三次握手、四次握手、backlog及其他","url":"/2018/03/13/TCP：三次握手、四次握手、backlog及其他/","content":"\n参考博客　[TCP：三次握手、四次握手、backlog及其他](https://www.cnblogs.com/xrq730/p/6910719.html)\n"},{"title":"Java内存模型","url":"/2018/03/11/Java内存模型/","content":"\n##### 定义\n\nJava 虚拟机规范中通过定义一种 Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的内存访问效果。\n\n###### 主内存与工作内存\n\n主内存 : 在 Java 内存模型中规定了所有的变量都存储在主内存中。\n工作内存 : 每个线程都有自己的工作内存，在工作内存中保存了该线程使用到的变量的主内存副本拷贝；线程对变量的所有操作必须在工作内存中完成，而不能直接读写主内存的变量；不同线程之间无法直接访问对方的工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n![](https://i.loli.net/2019/06/21/5d0c7d8737aec83687.png)\n\n```\n此处我们描述的主内存，工作内存与 Java 运行时数据中的堆,栈，方法区并不是同一层次的内存划分；二者基本上是没有关系的，不过也可以理解为主内存对应于 Java 堆中的对象实例，而工作内存对应于虚拟机中的栈。\n```\n\n###### 内存间如何交互\n\n在 Java 内存模型中定义了８中操作用来实现内存间的交互，也即是变量如何从主内存拷贝到工作内存，以及工作内存中的变量如何同步回主内存。\n\n８中操作如下：\n\n* lock : 锁定，作用于主内存的变量，将变量标志为一条线程独占的状态\n* unlock : 解锁，作用于主内存的变量，将处于锁定状态的变量释放，方便其他线程锁定\n* read : 读取，作用于主内存的变量，将一个变量的值从主内存传输到工作内存中\n* load : 载入，作用于工作内存，将read操作从主内存得到的变量放入工作内存的变量副本中\n* use : 使用，作用于工作内存的变量\n* assign : 赋值\n* store : 存储\n* write :\n\n在 Java 模型中还规定了在完成上述操作时必须满足以下规则：\n\n* 变量在工作内存中改变之后必须把该变化同步到主内存\n* 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次；多次 lock 之后，只有执行相同次数的 unlock 操作，变量才会被解锁；也就是可重入锁。\n* 对一个变量执行 lock 操作，将会清空工作内存中此变量的值也就是从主内存重新获取该变量的值更新到工作内存中\n* 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中\n\n\n\n\n\n"},{"title":"Jdk之LinkedHashMap","url":"/2018/03/05/Jdk之LinkedHashMap/","content":"\n##### 概述\n\nLinkedHashMap 与 HashMap 的不同之处在于前者遍历有序，后者遍历无序\n\n![](https://i.loli.net/2019/06/21/5d0c7d976cc6977729.png)\n\n从上图中可以看出 LinkedHashMap 继承至 HashMap , 并重写了 init, createEntry, addEntry, iterator 等方法。\n\n同时新增了全局变量 header, 并自定义了 LinkedHashMap.Entry 内部类\n<!-- more -->\n```java\nprivate static class Entry<K,V> extends HashMap.Entry<K,V> {\n        // These fields comprise the doubly linked list used for iteration.\n        Entry<K,V> before, after;\n\n        Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n            super(hash, key, value, next);\n        }\n\n        /**\n         * Removes this entry from the linked list.\n         */\n        private void remove() {\n            before.after = after;\n            after.before = before;\n        }\n\n        /**\n         * Inserts this entry before the specified existing entry in the list.\n         */\n        private void addBefore(Entry<K,V> existingEntry) {\n            after  = existingEntry;\n            before = existingEntry.before;\n            before.after = this;\n            after.before = this;\n        }\n\n    }\n\n```\n\n从代码中可以看出 LinkedHashMap.Entry 继承至 HashMap.Entry ,　新增了变量 before, after; 以及内部方法 addBefore;\n\n那么 LinkedHashMap 如何保证遍历有序的呢？下文将详细说明，首先我们先看下 LinkedHashMap 的初始化操作有何不同。\n\n###### init\n\n```java\n\tvoid init() {\n        header = new Entry<>(-1, null, null, null);\n        header.before = header.after = header;\n    }\n```\n\n在初始化过程中 构建了 header 节点\n\n###### createEntry\n\n```java\n\t/**\n     * This override differs from addEntry in that it doesn't resize the\n     * table or remove the eldest entry.\n     */\n    void createEntry(int hash, K key, V value, int bucketIndex) {\n        HashMap.Entry<K,V> old = table[bucketIndex];\n        Entry<K,V> e = new Entry<>(hash, key, value, old);\n        table[bucketIndex] = e;\n        e.addBefore(header);\n        size++;\n    }\n```\n\n从代码中可以看出与 HashMap 不同之处在于 构建 Entry 实例之后执行了 e.addBefore 方法\n\n```java\n\tprivate void addBefore(Entry<K,V> existingEntry) {\n            // 当前节点的后驱节点指向 existingEntry\n\t\t\tafter  = existingEntry;\n\t\t\t// 当前节点的前驱节点指向 existingEntry 的后驱节点\n            before = existingEntry.before;\n\t\t\t// 当前节点的前驱节点的后驱节点指向当前节点\n            before.after = this;\n\t\t\t// 当前节点的后驱节点的前驱节点指向当前节点\n            after.before = this;\n        }\n```\n\n从init, Entry.addBefore 方法可以看出 LinkedHashMap 内部维护了一个\"双向链表\"，每次添加元素的时候会将该节点添加到链表中；如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7d9f1561214315.png)\n\n###### iterator\n\n```java\nprivate abstract class LinkedHashIterator<T> implements Iterator<T> {\n        Entry<K,V> nextEntry    = header.after;\n        Entry<K,V> lastReturned = null;\n\n        /**\n         * The modCount value that the iterator believes that the backing\n         * List should have.  If this expectation is violated, the iterator\n         * has detected concurrent modification.\n         */\n        int expectedModCount = modCount;\n\n        public boolean hasNext() {\n\t\t\t// 当 nextEntry 不等于 header 的表示还未遍历到链表末尾\n            return nextEntry != header;\n        }\n\n        public void remove() {\n            if (lastReturned == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n\n            LinkedHashMap.this.remove(lastReturned.key);\n            lastReturned = null;\n            expectedModCount = modCount;\n        }\n\n        Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (nextEntry == header)\n                throw new NoSuchElementException();\n\n            Entry<K,V> e = lastReturned = nextEntry;\n\t\t\t// 指向节点的后驱节点\n            nextEntry = e.after;\n            return e;\n        }\n    }\n```\n\n从内部类 LinkedHashIterator 中可以看出 LinkedHashMap 是遍历双向链表，从而保证遍历的时候有序.\n\n同样 LinkedHashSet 内部是调用 LinkedHashMap 实现，同样也保证了遍历有序。\n\n","tags":["数据结构"]},{"title":"Jdk之HashMap","url":"/2018/03/05/Jdk之HashMap/","content":"\n##### 概述\n\nHashMap 是散列表的一种基于拉链法的实现方式。\n\n本文先看下 HashMap 的迭代实现方式\n\n```java\n\tprivate abstract class HashIterator<E> implements Iterator<E> {\n        Entry<K,V> next;        // next entry to return\n        int expectedModCount;   // For fast-fail\n        int index;              // current slot\n        Entry<K,V> current;     // current entry\n\n        HashIterator() {\n            expectedModCount = modCount;\n            if (size > 0) { // advance to first entry\n                Entry[] t = table;\n\t\t\t\t// 遍历数组 直到发现一个不为空的 Entry\n                while (index < t.length && (next = t[index++]) == null)\n                    ;\n            }\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n        final Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            Entry<K,V> e = next;\n            if (e == null)\n                throw new NoSuchElementException();\n\t\t\t// 获取当前 Entry 链表的下一个节点，如果下个节点为空说明当前链表已经遍历结束\n\t\t\t// 此时继续遍历数组 直到发现一个不为空的 Entry\n            if ((next = e.next) == null) {\n                Entry[] t = table;\n                while (index < t.length && (next = t[index++]) == null)\n                    ;\n            }\n            current = e;\n            return e;\n        }\n\n        public void remove() {\n            if (current == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            Object k = current.key;\n            current = null;\n            HashMap.this.removeEntryForKey(k);\n            expectedModCount = modCount;\n        }\n    }\n```\n\n遍历过程如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7d90e6c6223539.png)\n\n"},{"title":"jdk之LinkedList","url":"/2018/02/28/jdk之LinkedList/","content":"\n##### 定义\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n```\n\n从定义可以看出 LinkedList 实现了接口 List, Deque, 表明其支持列表,栈，队列，双端队列的操作。\n\n<!-- more -->\n\n##### 变量\n\n```java\n\ttransient int size = 0;\n\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last;\n```\n\n* size : 链表元素个数\n* first : 指向链表的头节点\n* last : 指向链表的尾节点\n\n###### 内部类\n\n```java\n\tprivate static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n\nNode 是 LinkedList 的内部类，定义了链表的节点结构:\n* item : 节点存储的元素\n* prev : 当前节点的前驱节点\n* next : 当前节点的后驱节点\n\n##### Api\n\n###### add(E)\n\n向链表中添加元素\n\n```java\n\tpublic boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n```\n\n```java\n    void linkLast(E e) {\n        final Node<E> l = last;\n\t\t// 定义插入节点\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n\t\t\t// 链表为空 头尾节点均指向新插入的节点\n            first = newNode;\n        else\n\t\t\t// 链表的尾节点后驱节点指向新插入的节点\n            l.next = newNode;\n\t\t// 元素个数加一\n        size++;\n        modCount++;\n    }\n```\n\n* 首先构建待插入的节点\n* 将尾节点指向待插入的节点\n* 若原尾节点为空，说明队列为空，将头节点也指向待插入的节点\n* 若原尾节点非空，则将原尾节点的后驱节点指向待插入节点\n* 元素个数加一\n\n###### add(index, e)\n\n向链表中指定的位置插入元素\n\n```java\n\tpublic void add(int index, E element) {\n        // 检查位置index 是否在链表范围内\n\t\tcheckPositionIndex(index);\n\n        if (index == size)\n\t\t\t// 表明在链表的末尾插入节点\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n```\n\nnode(index) 方法用于获取链表指定位置的节点\n\n```java\n\tNode<E> node(int index) {\n        // assert isElementIndex(index);\n\t\t// 判断index 是否比链表长度的一半小；size >> 1 相当于 size/2\n\t\t// 如果小于链表的一半，则从头节点开始遍历\n\t\t// 如果大于链表的一半，则从尾节点开始遍历\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n\nlinkBefor(E e, Node succ) 方法用于在指定节点前插入元素\n\n```java\n\tvoid linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n###### set(index, e)\n\n更新链表指定位置节点的元素，并返回老的元素\n\n```java\n\tpublic E set(int index, E element) {\n        checkElementIndex(index);\n        // 获取指定位置的节点\n\t\tNode<E> x = node(index);\n        E oldVal = x.item;\n\t\t// 更新节点元素\n        x.item = element;\n        return oldVal;\n    }\n```\n\n###### get(index)\n\n获取链表指定位置的元素\n\n```java\n\tpublic E get(int index) {\n        checkElementIndex(index);\n\t\t// 获取指定位置的节点　然后返回其存储的元素\n        return node(index).item;\n    }\n```\n\n###### remove(index)\n\n删除链表指定位置的节点并返回该节点存储的元素\n\n```java\n\tpublic E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n```\n\nunlink(node) 该方法从字面上理解即解除节点与链表的链接\n\n```java\n\tE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n\t\t\t// 前驱节点为空，说明删除的节点为头节点\n\t\t\t// 那么将头节点指向删除节点的后驱节点\n            first = next;\n        } else {\n\t\t\t// 前驱节点不为空\n\t\t\t// 将前驱节点的后驱节点指向删除节点的后驱节点\n            prev.next = next;\n\t\t\t// 删除节点的前驱节点指向空\n            x.prev = null;\n        }\n\n        if (next == null) {\n\t\t\t// 删除节点的后驱节点为空，说明删除节点为尾节点\n\t\t\t// 那么将尾节点指向删除节点的前驱节点\n            last = prev;\n        } else {\n\t\t\t// 后驱节点不为空\n\t\t\t// 将后驱节点的前驱节点指向删除节点的前驱节点\n            next.prev = prev;\n\t\t\t// 删除节点的后驱节点指向空\n            x.next = null;\n        }\n\t\t//　存储元素改为空,元素个数减一\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n###### iterator()\n\n链表的迭代, 内部调用的是 listIterator(0) 方法\n\n```java\n\tpublic ListIterator<E> listIterator(int index) {\n        checkPositionIndex(index);\n        return new ListItr(index);\n    }\n```\n\n```java\nprivate class ListItr implements ListIterator<E> {\n        private Node<E> lastReturned = null;\n        private Node<E> next;\n        private int nextIndex;\n        private int expectedModCount = modCount;\n\n        ListItr(int index) {\n            // assert isPositionIndex(index);\n            next = (index == size) ? null : node(index);\n            nextIndex = index;\n        }\n\n        public boolean hasNext() {\n\t\t\t// nextIndex 小于 size 表明还未遍历到链表结尾\n            return nextIndex < size;\n        }\n\n        public E next() {\n            checkForComodification();\n            if (!hasNext())\n                throw new NoSuchElementException();\n\t\t\t\n            lastReturned = next;\n            // next 指向下一个节点\n\t\t\tnext = next.next;\n\t\t\t// nextIndex 加一\n            nextIndex++;\n            return lastReturned.item;\n        }\n\n    }\n\n```\n\n\n\n","tags":["jdk"]},{"title":"数据结构-平衡二叉树","url":"/2018/02/26/数据结构-平衡二叉树/","content":"\n##### 概念\n\n###### 平衡二叉树\n\n平衡二叉树(Self-Balancing Binary Search Tree) 是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于１。\n\n<!-- more -->\n\n###### 平衡因子\n\n平衡因子 BF (Balance Factor) : 我们将二叉树上节点的左子树的深度减去右子树的深度值称为平衡因子；那么平衡二叉树上所有节点的平衡因子只可能是 -1, 0, 1。\n\n```\n只要二叉树上有一个节点的平衡因子的绝对值大于１, 那么该二叉树就是不平衡的\n```\n\n###### 最小不平衡子树\n\n最小不平衡子树: 当我们在执行平衡二叉树插入节点时，距离插入节点最近的，且平衡因子的绝对值大于１的节点为根的子树，我们将其称之为最小不平衡子树。\n\n###### 示例\n\n现通过下图一些样例说明何为平衡二叉树\n\n![数据结构-平衡二叉树-1.png](https://i.loli.net/2019/06/21/5d0c819e5bf6196713.png)\n\n* 图１为平衡二叉树：因为除了根节点的平衡因子为０，其他节点的平衡因子的绝对值均为１，符合平衡二叉树的条件\n* 图２不是平衡二叉树：因为节点５８的左节点为５９，５９ > 58 不符合二叉树的性质左节点小于根节点，所以也不符合平衡二叉树\n* 图３不是平衡二叉树：因为节点５８的左子树的深度为２，而右子树为空；平衡因子为２，所以不符合平衡二叉树的条件\n* 图４为平衡二叉树，满足平衡二叉树的条件\n\n![](https://i.loli.net/2019/06/21/5d0c7deb754b362557.png)\n\n同样如上图所示，插入节点３７时，距离它最近的且平衡因子超过１的节点为５８，所以５８节点开始以下的子树为最小不平衡子树。\n\n##### 实现原理\n\n平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点时先检查是否因插入而破坏了树的平衡性；若是则找出最小不平衡子树，在保持二叉排序树特性的前提下调整最小不平衡子树中各节点之间的链接关系进行相应的旋转，使其成为新的平衡子树。\n\n下面以一个数组 a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8} 构建平衡二叉树的过程来说明其实现原理。\n\n![](https://i.loli.net/2019/06/21/5d0c7df376f1545117.png)\n\n\n![](https://i.loli.net/2019/06/21/5d0c7dfb195a685186.png)\n\n以上两张图说明了平衡二叉树在构建过程的原理。针对构建过程发现不平衡的处理有如下几个步骤：\n\n* 当最小不平衡子树根节点的平衡因子BF大于１时，右旋；当平衡因子小于-1时左旋\n* 当最小不平衡子树的BF与其子节点BF符号相反时，需要先对子节点进行一次旋转使得符号相同后再进行一次旋转已达到平衡\n\n```\n右旋 : 将旋转节点的左节点指向其左节点的右节点，然后将旋转节点的左节点的右节点指向旋转节点（旋转节点下降，其左节点上浮）\n```\n\n```\n左旋 : 将旋转节点的右节点指向其右节点的左节点，然后将旋转节点的右节点的左节点指向旋转节点（旋转节点下降，其右节点上浮）\n```\n\n\n\n\n"},{"title":"jdk之LinkedBlockingQueue","url":"/2018/01/26/jdk之LinkedBlockingQueue/","content":"\n##### 概述\n\n在上一篇文章中我们分析了 ArrayBlockingQueue ,　今天在看下采用链表结构实现的阻塞队列。\n\n分析前我们同样有以下疑问：\n\n- 如何通过链表实现队列的 FIFO ?\n- 如何保证队列操作的同步 ?\n- 与 ArrayBlockingQueue 相比有如何优势 ?\n\n<!-- more -->\n\n##### 定义\n\n同样首先我们先来看下 LinkedBlockingQueue 的相关属性定义如下：\n\n```java\n \t/**\n     * 定义链表节点\n\t *\n\t * item : 节点存储的元素\n\t * next : 当前节点的后继节点\n     */\n    static class Node<E> {\n        E item;\n\n        Node<E> next;\n\n        Node(E x) { item = x; }\n    }\n\n    /** 定义队列的容量 默认为 Integer.MAX_VALUE */\n    private final int capacity;\n\n    /** 定义当前队列的存储元素个数 */\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    /**\n     * 队列头节点\n     * Invariant: head.item == null\n     */\n    private transient Node<E> head;\n\n    /**\n     * 队列尾节点\n     * Invariant: last.next == null\n     */\n    private transient Node<E> last;\n\n    /** Lock held by take, poll, etc */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** Wait queue for waiting takes */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** Lock held by put, offer, etc */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** Wait queue for waiting puts */\n    private final Condition notFull = putLock.newCondition();\n```\n\n从定义中有以下几个疑问：\n\n- 当前队列元素个数为什么采用原子操作类 AtomicInteger ? int 类型的变量为什么不可以？\n- 队列的头尾节点定义注释中为什么说 head last 都有一个不变性 item 永远为空 ?\n\n##### 构造\n\n```java\n\tpublic LinkedBlockingQueue() {\n\t\t// 队列默认容量为 int 最大值\n        this(Integer.MAX_VALUE);\n    }\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n\t\t// 设置队列容量\n        this.capacity = capacity;\n\t\t// 初始队列头尾节点\n        last = head = new Node<E>(null);\n    }\n```\n\n##### API\n\n###### offer(E e)\n\n```java\n\tpublic boolean offer(E e) {\n        if (e == null) throw new NullPointerException();\n        final AtomicInteger count = this.count;\n        if (count.get() == capacity)\n\t\t\t// 若队列满了 返回 false; 说明插入失败\n            return false;\n        int c = -1;\n\t\t// 定义节点\n        Node<E> node = new Node(e);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock();\n        try {\n            if (count.get() < capacity) {\n\t\t\t\t// 插入队列\n                enqueue(node);\n\t\t\t\t// 队列元素个数加一，并返回原来的个数\n                c = count.getAndIncrement();\n                if (c + 1 < capacity)\n\t\t\t\t\t// 队列未满唤醒因为队列满而阻塞的 put 操作\n                    notFull.signal();\n            }\n        } finally {\n            putLock.unlock();\n        }\n\t\t// c == 0 说明队列曾经为空，那么需要唤醒阻塞在 take poll 操作上的线程\n        if (c == 0)\n            signalNotEmpty();\n        return c >= 0;\n    }\n```\n\n```java\n\tprivate void enqueue(Node<E> node) {\n\t\t// 将原尾节点的后继节点 指向 node\n\t\t// 将尾节点指针指向 node\n        last = last.next = node;\n    }\n```\n\noffer 之后 last 永远指向链表的最近插入的节点，所以 last 节点的 next 永远为空。\n\n###### poll()\n\n```java\n\tpublic E poll() {\n        final AtomicInteger count = this.count;\n        if (count.get() == 0)\n\t\t\t// 队列为空 返回 null\n            return null;\n        E x = null;\n        int c = -1;\n        final ReentrantLock takeLock = this.takeLock;\n        takeLock.lock();\n        try {\n            if (count.get() > 0) {\n\t\t\t\t// 出队 获取队列头部元素\n                x = dequeue();\n\t\t\t\t// 队列元素个数减一 并返回原个数\n                c = count.getAndDecrement();\n                if (c > 1)\n\t\t\t\t\t// 唤醒因队列为空而阻塞的 take poll 操作\n                    notEmpty.signal();\n            }\n        } finally {\n            takeLock.unlock();\n        }\n\t\t// c== capacity 说明队列曾经满了有 offer put 线程阻塞，故需唤醒\n        if (c == capacity)\n            signalNotFull();\n        return x;\n    }\n```\n\n```java\n\tprivate E dequeue() {\n        Node<E> h = head;\n\t\t// 取 head 的后继节点\n        Node<E> first = h.next;\n\t\t// 将 head 节点的 next 指向自己\n        h.next = h; // help GC\n\t\t// 将 head 重新指向头节点\n        head = first;\n\t\t\n        E x = first.item;\n        // 将 item 置为空\n\t\tfirst.item = null;\n        return x;\n    }\n```\n\n此时我们可以看出 LinkedBlockingQueue 中通过移动节点 head last 指针来实现队列的 FIFO; 效果如下图所示：\n\n![](https://i.loli.net/2019/06/21/5d0c7d9421b3689118.png)\n\n\t因为插入和获取头部操作里采用的是两个不同的锁，所以为了保持不同线程不同操作内队列元素个数的一致性所以采用 AtomicInteger 计算而非 int 类型。\n\n\n###### put(E e)\n\n```java\npublic void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        // Note: convention in all put/take/etc is to preset local var\n        // holding count negative to indicate failure unless set.\n        int c = -1;\n        Node<E> node = new Node(e);\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly();\n        try {\n            while (count.get() == capacity) {\n                notFull.await();\n            }\n            enqueue(node);\n            c = count.getAndIncrement();\n            if (c + 1 < capacity)\n                notFull.signal();\n        } finally {\n            putLock.unlock();\n        }\n        if (c == 0)\n            signalNotEmpty();\n    }\n```\n\n###### take()\n\n\n\n\n\n","tags":["jdk"]},{"title":"jdk之ArrayBlockingQueue","url":"/2018/01/24/jdk之ArrayBlockingQueue/","content":"\n##### 概述\n\nArrayBlockingQueue 又称为数组阻塞队列；其基于数组实现的有界阻塞队列，能容纳的元素数量固定，一旦创建就不能再增加其容量。\n\n那么接下来我们会带着以下两个疑问进行分析：\n\n- 如何通过数组实现队列的特性 FIFO ?\n- 如何保证队列插入获取操作的同步 ?\n\n<!-- more -->\n\n##### 定义\n\n首先看下 ArrayBlockingQueue 的属性定义　如下：\n\n```java\n\t/** 固定大小数组用于存储队列元素 */\n    final Object[] items;\n\n    /** 指向下次获取元素的下标 可以理解为指向队列头部 */\n    int takeIndex;\n\n    /** 指向下次插入元素的下标 可以理解为指向队列尾部 */\n    int putIndex;\n\n    /** 当前队列存储元素的个数 */\n    int count;\n\n    /** 定义可重入锁 */\n    final ReentrantLock lock;\n\n    /** 用于控制 take 操作的 condition */\n    private final Condition notEmpty;\n\n    /** 用于控制 put 操作的 condition */\n    private final Condition notFull;\n\n```\n\n##### 构造函数\n\n```java\n\tpublic ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n\n\t/**\n\t * 创建固定容量的阻塞队列并设置访问策略\n\t * @param capacity 队列的最大容量 \n\t * @param fair 队列的访问策略，true为公平锁策略, false为非公平锁；默认为 false\n\t */\n    public ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n\n```\n\n从构造函数可以看出，在创建 ArrayBlockinQueue 实例时，需指定队列最大存储元素的容量并设置内部重入锁的访问策略默认为非公平锁。\n\n##### API\n\n###### add(E e)\n\n```java\n\tpublic boolean add(E e) {\n        return super.add(e);\n    }\n```\n\n从代码可以看出 ArrayBlockingQueue 的 add 方法的实现是基于父类 AbstractQueu 的实现如下：\n\n```java\n\tpublic boolean add(E e) {\n        if (offer(e))\n            return true;\n        else\n            throw new IllegalStateException(\"Queue full\");\n    }\n```\n\n从代码中我们知道 add 方法的主要实现在 offer 方法内（将会在下文分析），如果能够插入成功则返回 true, 否则抛出 IllegalStateException 异常\n\n###### remove()\n\nremove 方法移除队列的头部元素并返回, 其实现是在父类 AbstractQueue 中如下:\n\n```java\n\tpublic E remove() {\n        E x = poll();\n        if (x != null)\n            return x;\n        else\n            throw new NoSuchElementException();\n    }\n```\n\n如上代码知道 remov的主要实现在 poll 方法内；如果获取的头部元素不为空将返回，若为空则抛出 NoSUchElementException 异常。\n\n###### offer(E e)\n\n```java\n\tpublic boolean offer(E e) {\n\t\t// 检查元素是否为空\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n\t\t// 获取锁\n        lock.lock();\n        try {\n\t\t\t// 元素个数达到最大容量时返回 fae\n            if (count == items.length)\n                return false;\n\t\t\t// 执行插入返回 true\n            else {\n                insert(e);\n                return true;\n            }\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n```java\n\tprivate void insert(E x) {\n\t\t// 将元素插入数组指定的位置\n        items[putIndex] = x;\n\t\t// 将 putIndex 移动到下一个位置\n        putIndex = inc(putIndex);\n\t\t// 元素个数加一\n        ++count;\n\t\t// 当前队列非空，唤醒阻塞在获取元素操作上的线程\n        notEmpty.signal();\n    }\n```\n\n从代码可以看出 offer 方法将元素插入队列的逻辑如下：\n\n- 判断元素是否为空\n- 获取锁\n- 判断队列是否已满，若已满则返回 false\n- 通过指针 putIndex 将元素放入数组\n- 移动指针 putIndex 指向下一个位置\n- 队列当前元素个数加一\n- 唤醒阻塞在获取元素操作上的线程\n- 释放锁\n\n###### poll()\n\n```java\n\tpublic E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n\t\t\t// 队列空的时候 返回 null; 非空的时候调用 extract\n            return (count == 0) ? null : extract();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n```java\n\tprivate E extract() {\n        final Object[] items = this.items;\n\t\t// 获取头部的元素\n        E x = this.<E>cast(items[takeIndex]);\n\t\t// 将队列头部置为空\n        items[takeIndex] = null;\n\t\t// 移动头部指针\n        takeIndex = inc(takeIndex);\n\t\t// 队列元素个数减一\n        --count;\n\t\t// 唤醒因队列满而阻塞的插入操作\n        notFull.signal();\n        return x;\n    }\n```\n\npoll 方法获取头部元素逻辑如下：\n\n- 获取锁\n- 判断队列是否为空，若空则返回 null\n- 通过 takeIndex 头部指针获取队列头元素\n- 将队列头部置为空\n- 移动头部指针指向下个位置\n- 队列元素个数减一\n- 唤醒因队列满而阻塞的插入操作\n- 返回头部元素并释放锁\n\n此时我们可以看出 ArrayBlockingQueue 中通过两个指针 takeIndex putIndex 的移动来保证队列的 FIFO,如下图所示：\n\n![jdk之ArrayBlockingQueue-1.png](https://i.loli.net/2019/06/21/5d0c80bfa72f661446.png)\n\n>\t我们知道数组有界　在队列中又是如何保证循环利用的呢？\n\n```java\n\tfinal int inc(int i) {\n        return (++i == items.length) ? 0 : i;\n    }\n```\n\n从  inc 方法可以看出在移动 takeindex putindex 指针的时候，当他们到达末尾的时候重新指向头部。\n\n###### offer(E e,long timeout,TimeUnit u)\n\n该方法表示在指定的时间内将元素插入队列中，若失败返回 false 。\n\n```java\n\tpublic boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n\n        checkNotNull(e);\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n\t\t// 获取锁\n        lock.lockInterruptibly();\n        try {\n\t\t\t// 当前元素个数达到队列最大容量时 等待\n            while (count == items.length) {\n                if (nanos <= 0)\n\t\t\t\t\t// 说明已超时 队列满了插入失败 返回 false\n                    return false;\n                nanos = notFull.awaitNanos(nanos);\n            }\n\t\t\t// 执行插入\n            insert(e);\n            return true;\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 offer(e) 实现基本相同，只是在当队列满的情况下会在设置的 timeout 时间内等待。\n\n###### poll(long timeout, TimeUnit unit)\n\n```java\n\tpublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 当队列空的时候等待队列有元素；若等待超时之后还未有元素则返回 false\n            while (count == 0) {\n                if (nanos <= 0)\n                    return null;\n                nanos = notEmpty.awaitNanos(nanos);\n            }\n\t\t\t// 队列非空时　获取头部元素\n            return extract();\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n与 poll() 方法类似，不同之处在于当队列为空的时候等待。\n\n###### put(E e)\n\n```java\n\tpublic void put(E e) throws InterruptedException {\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 队列满的时候\n            while (count == items.length)\n\t\t\t\t// 释放锁当前线程阻塞；等待 take 操作唤醒\n                notFull.await();\n\t\t\t// 队列未满执行插入\n            insert(e);\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 offer 不同之处在于当队列满的时候，当前线程会阻塞直至等待 take 操作唤醒。\n\n###### take()\n\n```java\n\tpublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 队列为空的时候\n            while (count == 0)\n\t\t\t\t// 释放锁当前线程阻塞；等待 put 操作唤醒\n                notEmpty.await();\n\t\t\t// 队列非空　获取头部元素\n            return extract();\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 poll 不同之处在于当队列为空的时候，当前线程会一直阻塞直至等待 put 操作唤醒。\n\n##### 小结\n\n- ArrayBlockingQueue 采用数组作为元素存储，故其为有界队列\n- ArrayBlockingQueue 通过指针 takeIndex putIndex 的移动来实现 FIFO\n- ArrayBlockingQueue 通过定义 ReentrantLock 重入锁来保证插入获取操作的同步。也就是当前若有线程在执行插入操作，则获取操作同样会被阻塞。\n\n\n\n","tags":["jdk"]},{"title":"jdk之BlockingQueue","url":"/2018/01/24/jdk之BlockingQueue/","content":"\n##### 概述\n\n\nBlockingQueue 被称为阻塞队列，除了具备 Queue 的特点外，还支持另外两项重要特性：\n\n```\n\n对于有界队列，当队列满的时候，插入操作会阻塞等待队列可用；\n\n当队列空的时候，获取元素的操作会阻塞等待队列为非空\n\n```\n\n阻塞队列常用于“生产者－消费者”模式的业务场景，生产者就是往阻塞队列中插入元素的线程，消费者就是从阻塞队列中获取元素的线程；当生产者的速度大于消费者的速度，就可能出现有界队列满的情况，此时生产者就会出现阻塞等待状态直到队列中出现空闲；当生产者的速度小于消费者的速度就可能出现空队列的情况，消费者就会出现阻塞等待状态，直到队列中有元素。\n\n<!-- more -->\n\n##### API\n\n###### add(Object o)\n\n该方法是将指定元素插入到队列中，如果队列可插入则返回 true, 否则抛出异常\n\n###### offer(Object o)\n\n该方法将指定元素插入到队列中，如果队列可插入则返回 true, 否则返回 false\n\n###### offer (Object, timeout, timeunit)\n\n该方法在设定的等待时间内如果能将指定元素插入到队列中返回 true, 否则返回 false\n\n###### poll(long timeout,TimeUnit unit)\n\n该方法从队列中取出一个队首的元素，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。超时后，依然没有取得数据则返回NULL\n\n###### put(Object o)\n\n把对象o加入到BlockingQueue里，如果BlockingQueue没有足够空间，则调用此方法的线程会被阻塞等待，直到BlockingQueue里面有空闲空间时再继续执行\n\n###### take( )\n\n取走BlockingQueue里排在首位的对象，如果BlockingQueue为空，则调用此方法的线程会被阻塞等待，直到BlockingQueue里面有新元素被加入后再继续执行\n\n后续将会对 BlockingQueue 的几种实现进行分析.\n\n","tags":["jdk"]},{"title":"Netty客户端链接派发分析","url":"/2018/01/20/Netty客户端链接派发分析/","content":"\n在上篇针对 Netty 的服务端启动过程进行了分析，我们知道服务端包含了两个 NioEventLoopGroup, 一个是 boss 用于接收客户端的请求，一个是 worker 用于处理客户端的读写操作；那么 boss group 是如何将客户端链接通道派发到 worker 呢？本文主要针对这个问题进行分析。\n\n<!-- more -->\n\n##### NioEventLoop\n\n上文中我们知道 netty 主要通过 NioEventLoop 内部的线程处理客户端请求，那么我们接下来详细看下该线程的实现：\n\n```java\nprotected SingleThreadEventExecutor(\n            EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks,\n            RejectedExecutionHandler rejectedHandler) {\n        if (threadFactory == null) {\n            throw new NullPointerException(\"threadFactory\");\n        }\n\n        this.parent = parent;\n        this.addTaskWakesUp = addTaskWakesUp;\n\n        thread = threadFactory.newThread(new Runnable() {\n            @Override\n            public void run() {\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run();\n                    success = true;\n                } catch (Throwable t) {\n                    logger.warn(\"Unexpected exception from an event executor: \", t);\n                } finally {\n                    \n                }\n            }\n        });\n        threadProperties = new DefaultThreadProperties(thread);\n        this.maxPendingTasks = Math.max(16, maxPendingTasks);\n        taskQueue = newTaskQueue();\n        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n    }\n```\n\nNioEventLoop 内部的线程运行时会调用抽象方法 run, 其实现如下：\n\n```java\nprotected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                        // fall through\n                    default:\n                }\n\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\n\n该线程内部以“死循环”的方式 执行 select 后处理 selectedKeys :\n\n```java\nprivate void processSelectedKeys() {\n        if (selectedKeys != null) {\n            processSelectedKeysOptimized();\n        } else {\n            processSelectedKeysPlain(selector.selectedKeys());\n        }\n    }\n```\nselectedKeys 是在NioEventLoop构建时创建的SelectedSelectionKeySet实例，故会调用 processSelectedKeysOptimized 方法如下：\n```java\nprivate void processSelectedKeysOptimized() {\n        for (int i = 0; i < selectedKeys.size; ++i) {\n            final SelectionKey k = selectedKeys.keys[i];\n            // null out entry in the array to allow to have it GC'ed once the Channel close\n            // See https://github.com/netty/netty/issues/2363\n            selectedKeys.keys[i] = null;\n\n            final Object a = k.attachment();\n\n            if (a instanceof AbstractNioChannel) {\n                processSelectedKey(k, (AbstractNioChannel) a);\n            } else {\n                @SuppressWarnings(\"unchecked\")\n                NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;\n                processSelectedKey(k, task);\n            }\n\n            if (needsToSelectAgain) {\n                // null out entries in the array to allow to have it GC'ed once the Channel close\n                // See https://github.com/netty/netty/issues/2363\n                selectedKeys.reset(i + 1);\n\n                selectAgain();\n                i = -1;\n            }\n        }\n    }\n```\n\n其实现是循环遍历 selectedKeys 集合中的 selectedKey 进行处理，那么此时我们会有一个疑惑：\n\n\tselector 选择器中就绪的通道的 selectedKey 是如何添加到 selectedKeys 集合中呢？\n\n让我们回过头在看下 NioEventLoop 开启 selector 的过程：\n\n```java\nprivate SelectorTuple openSelector() {\n        final Selector unwrappedSelector;\n        try {\n\t\t\t// 开启 selector 返回 EpollSelectorImpl 实例\n            unwrappedSelector = provider.openSelector();\n        } catch (IOException e) {\n            throw new ChannelException(\"failed to open a new selector\", e);\n        }\n\n        if (DISABLE_KEYSET_OPTIMIZATION) {\n            return new SelectorTuple(unwrappedSelector);\n        }\n\n        final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();\n\t\t\n\t\t// ......\n\n        final Class<?> selectorImplClass = (Class<?>) maybeSelectorImplClass;\n\n        Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                try {\n                    Field selectedKeysField = selectorImplClass.getDeclaredField(\"selectedKeys\");\n                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(\"publicSelectedKeys\");\n\n                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField);\n                    if (cause != null) {\n                        return cause;\n                    }\n                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField);\n                    if (cause != null) {\n                        return cause;\n                    }\n                    // 将 Selector 实现类的属性 selectedKeys 替换为 netty 自定义的　SelectedSelectionKeySet\n                    // 这样当选择器　有就绪的通道时　就会把 selectKey 添加到　SelectedSelectionKeySet　中\n                    selectedKeysField.set(unwrappedSelector, selectedKeySet);\n                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n                    return null;\n                } catch (NoSuchFieldException e) {\n                    return e;\n                } catch (IllegalAccessException e) {\n                    return e;\n                }\n            }\n        });\n\n        if (maybeException instanceof Exception) {\n            selectedKeys = null;\n            Exception e = (Exception) maybeException;\n            logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, e);\n            return new SelectorTuple(unwrappedSelector);\n        }\n        selectedKeys = selectedKeySet;\n        logger.trace(\"instrumented a special java.util.Set into: {}\", unwrappedSelector);\n        return new SelectorTuple(unwrappedSelector,\n                                 new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));\n    }\n```\n\n从代码中可以看出 NioEventLoop 内部对于 selector 进行了包装，通过反射对 EpollSelectorImpl 实例内字段 selectedKeys publicSelectedKeys 替换为 SelectedSelectionKeySet 实例；这样就保证了当选择器有就绪的通道时就会把 selectKey 添加到 selectedSelectionKeySet 中\n\n我们在回到 processSelectedKeysOptimized 方法中，当集合中有就绪的 selectedKey 时，会获取绑定在该 key 上的附件 attachment 针对服务端来说 也就是 NioServerSocketChannel （注册的时候绑定的)；接下来会调用 processSelectedKey 如下：\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n        final NioUnsafe unsafe = ch.unsafe();\n            try {\n            int readyOps = k.readyOps();\n            // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise\n            // the NIO JDK channel implementation may throw a NotYetConnectedException.\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking\n                // See https://github.com/netty/netty/issues/924\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n\n                unsafe.finishConnect();\n            }\n\n            // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n                // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write\n                ch.unsafe().forceFlush();\n            }\n\n            // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead\n            // to a spin loop\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read();\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n    }\n```\n\n因服务端监听的是 ACCEPT 事件，故当有客户端链接请求就绪的时候会调用 unsafe.read() ,此时 unsafe 实例为 NioMessageSafe:\n\n```java\npublic void read() {\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config();\n            if (!config.isAutoRead() && !isReadPending()) {\n                // ChannelConfig.setAutoRead(false) was called in the meantime\n                removeReadOp();\n                return;\n            }\n\n            final int maxMessagesPerRead = config.getMaxMessagesPerRead();\n            final ChannelPipeline pipeline = pipeline();\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    for (;;) {\n                        int localRead = doReadMessages(readBuf);\n\t\t\t\t\t\t// 当没有客户端通道时退出\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        // stop reading and remove op\n                        if (!config.isAutoRead()) {\n                            break;\n                        }\n\n                        if (readBuf.size() >= maxMessagesPerRead) {\n                            break;\n                        }\n                    }\n                } catch (Throwable t) {\n                    exception = t;\n                }\n                setReadPending(false);\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n\t\t\t\t\t// 触发 pipeline 的 channelRead 事件\n                    pipeline.fireChannelRead(readBuf.get(i));\n                }\n\n                readBuf.clear();\n\t\t\t\t// 触发 pipeline 的 channelReadComplete 事件\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                \n            }\n        }\n```\n\n```java\nprotected int doReadMessages(List<Object> buf) throws Exception {\n\t\t// 获取客户端通道\n        SocketChannel ch = SocketUtils.accept(javaChannel());\n\n        try {\n            if (ch != null) {\n\t\t\t\t// 将 nio socketChannel 封装为 NioSocketChannell 添加到 buf　集合中\n                buf.add(new NioSocketChannel(this, ch));\n                return 1;\n            }\n        } catch (Throwable t) {\n            logger.warn(\"Failed to create a new channel from an accepted socket.\", t);\n\n            try {\n                ch.close();\n            } catch (Throwable t2) {\n                logger.warn(\"Failed to close a socket.\", t2);\n            }\n        }\n\n        return 0;\n    }\n```\n\n其流程为：\n\n- 获取客户端通道 socketChannel 并将其封装为 NioSocketChannel 添加到缓冲中\n- 触发 pipeline 的 channelRead 事件\n- 触发 pipeline 的 channelReadComplete 事件\n\n最终会触发 ServerBootstrapAcceptor handler 的 channelRead 事件如下： \n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n\t\t\t// msg 为 NioSocketChannel 实例\n            final Channel child = (Channel) msg;\n\t\t\t// 将 ServerBootstrap 设置的 childHandler 添加到 NioSocketChannel 的 pipeline 中\n            child.pipeline().addLast(childHandler);\n\n            setChannelOptions(child, childOptions, logger);\n\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n\n            try {\n\t\t\t\t// childGroup 也就是我们所理解的 wrker group\n\t\t\t\t// 执行注册 nioSocketChannel 即将 NioSocektChannel 注册到 worker group 中的 NioEventLoop 的 selector\n                childGroup.register(child).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n                forceClose(child, t);\n            }\n        }\n```\n\nchannelReadComplete 事件在执行过程中最终会调用 NioSocktChannel 的 doBegingRead 方法如下：\n\n```java\nprotected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        if (inputShutdown) {\n            return;\n        }\n\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) {\n\t\t\t// NioSocetChannel 创建的时候 readInterestop 值为 O_READ\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n```java\nprotected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {\n        super(parent, ch, SelectionKey.OP_READ);\n    }\n```\n\n\t至此将 SocketChannel 客户端通道注册到 worker group 中的 NioEventLoop　内的 selector 并监听 OP_READ 事件。\n\n\n此时 netty 内部线程模型如下：\n\n![Netty客户端链接派发分析-1.png](https://i.loli.net/2019/06/21/5d0c810e3345031603.png)","tags":["netty"]},{"title":"Netty服务端启动源码分析","url":"/2018/01/17/Netty服务端启动源码分析/","content":"\n  Netty 是一个高性能异步事件驱动的 NIO 框架, 因其底层采用的 NIO, 故其启动过程一样可以分为以下几个步骤:\n\n- selector 多路复用选择器开启\n- ServerSocketChannel 通道建立并绑定端口\n- ServerSocketChannel 通道注册到 selector 并监听 accept 事件\n\n在进行服务端启动分析前，我们先看下 netty 的服务端使用示例。\n\n<!-- more -->\n\n##### 示例\n\n```java\n// Configure the server.\nEventLoopGroup bossGroup = new NioEventLoopGroup(1);\nEventLoopGroup workerGroup = new NioEventLoopGroup();\ntry {\n\tServerBootstrap b = new ServerBootstrap();\n\tb.group(bossGroup, workerGroup)\n\t\t.channel(NioServerSocketChannel.class)\n\t \t.handler(new LoggingHandler(LogLevel.INFO))\n\t \t.childHandler(new ChannelInitializer<SocketChannel>() {\n\t\t\t @Override\n\t\t \tpublic void initChannel(SocketChannel ch) throws Exception {\n\t\t\t \tChannelPipeline p = ch.pipeline();\n\t\t\t \tif (sslCtx != null) {\n\t\t\t\t \tp.addLast(sslCtx.newHandler(ch.alloc()));\n\t\t\t \t}\t\n\t\t\t \tp.addLast(new EchoServerHandler());\n\t\t \t}\n\t \t});\n\n\t// Start the server.\n\tChannelFuture f = b.bind(PORT).sync();\n\n\t// Wait until the server socket is closed.\n\tf.channel().closeFuture().sync();\n} finally {\n\t// Shut down all event loops to terminate all threads.\n\tbossGroup.shutdownGracefully();\n\tworkerGroup.shutdownGracefully();\n}\n```\n\n从示例可以看出 netty 服务端通过创建 ServerBootstrap 实例，并对其配置 EventLoopGroup, channel, handler 之后即完成服务端的启动。\n\n##### NioEventLoopGroup - selector的创建\n\n从示例中可以看出 ServerBootstrap 启动的过程中需要两个 EventLoopGroup 实例，从职责上可以将其分为两种 boss 和 worker;前者主要负责客户端链接的接收以及派发到 worker, 后者主要负责客户端链接的读写请求操作。\n\n\n###### NioEventLoopGroup 的创建\n\n```java\n\n\tpublic NioEventLoopGroup(int nThreads) {\n\t\tthis(nThreads, null);\n\t}\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n\t\tthis(nThreads, threadFactory, SelectorProvider.provider());\n\t}\t\t\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider) {\n\t\tthis(nThreads, threadFactory, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);\n\t}\t\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) {\n\t\tsuper(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());\n\t}\n``` \n```java\nstatic {\n        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(\n                \"io.netty.eventLoopThreads\", NettyRuntime.availableProcessors() * 2));\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.eventLoopThreads: {}\", DEFAULT_EVENT_LOOP_THREADS);\n        }\n    }\n```\n```java\n\tprotected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {\n\t\tsuper(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);\n\t}\n```\n\n加载 MultithreadEventLoopGroup 类时，会先计算默认线程数其值为处理器个数的两倍。\n\n在看下父类MultithreadEventExecutorGroup的构造方法：\n\n```java\n\tprotected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) {\n        if (nThreads <= 0) {\n            throw new IllegalArgumentException(String.format(\"nThreads: %d (expected: > 0)\", nThreads));\n        }\n\n        if (threadFactory == null) {\n            threadFactory = newDefaultThreadFactory();\n        }\n\n        children = new SingleThreadEventExecutor[nThreads];\n\t\t// 创建 事件执行器的选择器\n        if (isPowerOfTwo(children.length)) {\n            chooser = new PowerOfTwoEventExecutorChooser();\n        } else {\n            chooser = new GenericEventExecutorChooser();\n        }\n\n        for (int i = 0; i < nThreads; i ++) {\n            boolean success = false;\n            try {\n\t\t\t// 创建 NioEventLoop\n                children[i] = newChild(threadFactory, args);\n                success = true;\n            } catch (Exception e) {\n                // TODO: Think about if this is a good exception type\n                throw new IllegalStateException(\"failed to create a child event loop\", e);\n            } finally {\n          \t\n\t\t\t}\t \n        }\n\t\t// 非核心代码省略\n    }\n```\n\nnewChild 是抽象方法由子类 NioEventLoopGroup 实现\n\n```java\n\tprotected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception {\n        return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0],\n            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);\n    }\n```\n\n从上述代码中可以看出 NioEventLoopGroup 构建过程中会按指定的线程数创建 NioEventLoop 实例并存储在 children 事件执行器数组中；同时创建了 chooser 实例，chooser 用于在新的客户端链接请求到达的时候从 children 数组中选取 eventLoop 的策略。\n\n###### NioEventLoop的创建\n\n先看下 NioEventLoop 的构造\n\n```java\nNioEventLoop(NioEventLoopGroup parent, ThreadFactory threadFactory, SelectorProvider selectorProvider,\n                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {\n        super(parent, threadFactory, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);\n        if (selectorProvider == null) {\n            throw new NullPointerException(\"selectorProvider\");\n        }\n        if (strategy == null) {\n            throw new NullPointerException(\"selectStrategy\");\n        }\n        provider = selectorProvider;\n        final SelectorTuple selectorTuple = openSelector();\n        // 创建 selector 选择器\n\t\tselector = selectorTuple.selector;\n        unwrappedSelector = selectorTuple.unwrappedSelector;\n        selectStrategy = strategy;\n    }\n```\n\n其父类构造如下：\n\n```java\n\tprotected SingleThreadEventExecutor(\n            EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks,\n            RejectedExecutionHandler rejectedHandler) {\n        if (threadFactory == null) {\n            throw new NullPointerException(\"threadFactory\");\n        }\n\n        this.parent = parent;\n        this.addTaskWakesUp = addTaskWakesUp;\n\t\t// 内部线程\n        thread = threadFactory.newThread(new Runnable() {\n            @Override\n            public void run() {\n               // 此处省略线程的具体执行 \n            }\n        });\n        threadProperties = new DefaultThreadProperties(thread);\n        this.maxPendingTasks = Math.max(16, maxPendingTasks);\n\t\t// 任务队列\n        taskQueue = newTaskQueue();\n        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n    }\n```\n\n```java\n\tprotected Queue<Runnable> newTaskQueue() {\n        return newTaskQueue(maxPendingTasks);\n    }\n\n\tprotected Queue<Runnable> newTaskQueue(int maxPendingTasks) {\n        return new LinkedBlockingQueue<Runnable>(maxPendingTasks);\n    }\n```\n\n从 NioEventLoop 的构造方法可以看出,　其内部包含了一个 thread 以及 taskQueue 并且绑定了一个 selector; taskQueue 用于存储内部执行的任务, thread 该线程主要用来执行 taskQueue 中的任务及处理客户端链接的请求。\n\n\t此时完成了 selector 选择器的创建,并将其绑定到 NioEventLoop 实例\n\n在完成了两个 NioEventLoopGroup 实例的创建之后　我们可以看出 Netty 内部线程模型大概如下：\n\n![Netty服务端启动源码分析-1.png](https://i.loli.net/2019/06/21/5d0c814c1502a84087.png)\n\n##### NioServerSocketChannel 通道创建\n\nServerBootstrap 在完成 group, channel, handler 的配置之后调用 bind 完成服务端启动，让我们看下其实现:\n\n```java\n \tpublic ChannelFuture bind(int inetPort) {\n        return bind(new InetSocketAddress(inetPort));\n    }\n\n    public ChannelFuture bind(String inetHost, int inetPort) {\n        return bind(SocketUtils.socketAddress(inetHost, inetPort));\n    }\n\n    public ChannelFuture bind(InetAddress inetHost, int inetPort) {\n        return bind(new InetSocketAddress(inetHost, inetPort));\n    }\n\n    public ChannelFuture bind(SocketAddress localAddress) {\n        validate();\n        if (localAddress == null) {\n            throw new NullPointerException(\"localAddress\");\n        }\n        return doBind(localAddress);\n    }\n\n    private ChannelFuture doBind(final SocketAddress localAddress) {\n        final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel();\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n       \t// 暂时省略 \n    }\n```\n\n从上述代码中可以在 bind 过程中，先完成 channel 的注册及初始化其实现在 initAndRegister 方法中如下：\n\n```java\nfinal ChannelFuture initAndRegister() {\n        Channel channel = null;\n        try {\n\t\t\t// 创建 NioServerSocketChannel\n            channel = channelFactory().newChannel();\n\t\t\t// 初始化 channel\n            init(channel);\n        } catch (Throwable t) {\n            if (channel != null) {\n                // channel can be null if newChannel crashed (eg SocketException(\"too many open files\"))\n                channel.unsafe().closeForcibly();\n            }\n            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);\n        }\n\t\t// channel 注册\n        ChannelFuture regFuture = group().register(channel);\n        if (regFuture.cause() != null) {\n            if (channel.isRegistered()) {\n                channel.close();\n            } else {\n                channel.unsafe().closeForcibly();\n            }\n        }\n        return regFuture;\n    }\n```\n\n从 initAndRegister 方法中可以看出，该方法主要完成以下三件事:\n\n- NioServerSocketChannel 实例的创建\n- NioServerSocketChannel 的初始化\n- NioServerSocketChannel 的注册\n\n###### NioServerSocketChannel的创建\n\n先让我们回过头看下 ServerBootstrap 启动时配置 channel 方法：\n\n```java\n\tpublic B channel(Class<? extends C> channelClass) {\n        if (channelClass == null) {\n            throw new NullPointerException(\"channelClass\");\n        }\n        return channelFactory(new BootstrapChannelFactory<C>(channelClass));\n    }\n\n   \tpublic B channelFactory(ChannelFactory<? extends C> channelFactory) {\n        if (channelFactory == null) {\n            throw new NullPointerException(\"channelFactory\");\n        }\n        if (this.channelFactory != null) {\n            throw new IllegalStateException(\"channelFactory set already\");\n        }\n\n        this.channelFactory = channelFactory;\n        return self();\n    }\n```\n\n也就是说此时 channelFactory 实例为 BootstrapChannelFactory, 接下来我们看下其实现：\n\n```java\nprivate static final class BootstrapChannelFactory<T extends Channel> implements ChannelFactory<T> {\n        private final Class<? extends T> clazz;\n\n        BootstrapChannelFactory(Class<? extends T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T newChannel() {\n            try {\n                return clazz.getConstructor().newInstance();\n            } catch (Throwable t) {\n                throw new ChannelException(\"Unable to create Channel from class \" + clazz, t);\n            }\n        }\n    }\n```\n\n故 channelFactory.newChannel() 方法也就是创建指定了 channel class 的实例也就是 NioServerSocketChannel 实例，接下来看下其构造实现：\n\n```java\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) {\n        try {\n            return provider.openServerSocketChannel();\n        } catch (IOException e) {\n            throw new ChannelException(\n                    \"Failed to open a server socket.\", e);\n        }\n    }\n\n    private final ServerSocketChannelConfig config;\n\n    public NioServerSocketChannel() {\n        this(newSocket(DEFAULT_SELECTOR_PROVIDER));\n    }\n\n    public NioServerSocketChannel(SelectorProvider provider) {\n        this(newSocket(provider));\n    }\n\n    public NioServerSocketChannel(ServerSocketChannel channel) {\n        super(null, channel, SelectionKey.OP_ACCEPT);\n        config = new NioServerSocketChannelConfig(this, javaChannel().socket());\n    }\n```\n\n其父类 AbstractNioChannel AbstractChannel 构造方法如下：\n\n```java\nprotected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {\n        super(parent);\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false);\n        } catch (IOException e) {\n        }\n    }\n```\n\n```java\nprotected AbstractChannel(Channel parent) {\n        this.parent = parent;\n        unsafe = newUnsafe();\n        pipeline = newChannelPipeline();\n    }\n```\n\n从 NioServerSocketChannel 的构造方法看出其主要流程如下:\n\n- 通过 newSocket 方法创建了 ServerSocketChannel 实例并设置为非阻塞模式\n- 设置了待监听事件 OP_ACCEPT\n- 创建 unsafe 实例为 NioMessageUnsafe\n- 创建 pipeline 实例为 DefaultChannelPipeline\n\n\n\t此时完成了 nio 中的 ServerSocketChannel 的创建\n\n###### NioServerSocktChannel的初始化\n\ninit 为抽象方法由子类实现\n\n```java\nvoid init(Channel channel) throws Exception {\n        final Map<ChannelOption<?>, Object> options = options();\n        synchronized (options) {\n            setChannelOptions(channel, options, logger);\n        }\n\n        final Map<AttributeKey<?>, Object> attrs = attrs();\n        synchronized (attrs) {\n            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n                @SuppressWarnings(\"unchecked\")\n                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n                channel.attr(key).set(e.getValue());\n            }\n        }\n\n        ChannelPipeline p = channel.pipeline();\n\n        final EventLoopGroup currentChildGroup = childGroup;\n        final ChannelHandler currentChildHandler = childHandler;\n        final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n        synchronized (childOptions) {\n            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));\n        }\n        synchronized (childAttrs) {\n            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));\n        }\n\n        p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(final Channel ch) throws Exception {\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n\n                logger.info(\"ServerBootStrap init channel addLast ChannelInitializer init channel\");\n                ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n    }\n```\n\ninit 主要设置 channel 的 attr 和　options;并在 pipeline 中添加 ChannelInitializer handler\n\n###### NioServerSocketChannel的注册\n\n在完成 channel 的创建及初始化之后即调用 NioEventLoopGroup.register(channel) 方法完成 channel 的注册。\n\n```java\n\t@Override\n    public EventLoop next() {\n        return (EventLoop) super.next();\n    }\n\n    @Override\n    public ChannelFuture register(Channel channel) {\n        return next().register(channel);\n    }\n```\n\nnext() 方法是按照 chooser 选取策略从 NioEventLoopGroup 中获取一个 NioEventLoop 实例;跟踪 register 方法最终调用的是 unsafe.register 方法如下:\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n\t// ......\n\tAbstractChannel.this.eventLoop = eventLoop;\n\n\tif (eventLoop.inEventLoop()) {\n\t\tregister0(promise);\n\t} else {\n\t\ttry {\n\t\t\teventLoop.execute(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tregister0(promise);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (Throwable t) {\n\t   }\n\t}\n}\n\nprivate void register0(ChannelPromise promise) {\n\ttry {\n\t\t// ......\n\t\tboolean firstRegistration = neverRegistered;\n\t\tdoRegister();\n\n\t\tneverRegistered = false;\n\t\tregistered = true;\n\n\t\tpipeline.invokeHandlerAddedIfNeeded();\n\n\t\tsafeSetSuccess(promise);\n\t\tpipeline.fireChannelRegistered();\n\t\t\n\t\t// ......                \n\t} catch (Throwable t) {\n\t}\n}\n```\n\n调用了由子类实现的 doRegister() 方法如下：\n\n```java\n@Override\nprotected void doRegister() throws Exception {\n\tboolean selected = false;\n\tfor (;;) {\n\ttry {\n\t\t// ServerSocketChannel 注册到 selector\n\t\tselectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n\t\treturn;\n\t} catch (CancelledKeyException e) {\n\t\tif (!selected) {\n\t\t\t// Force the Selector to select now as the \"canceled\" SelectionKey may still be\n\t\t\t// cached and not removed because no Select.select(..) operation was called yet.\n\t\t\teventLoop().selectNow();\n\t\t\tselected = true;\n\t\t} else {\n\t\t\t// We forced a select operation on the selector before but the SelectionKey is still cached\n\t\t\t// for whatever reason. JDK bug ?\n\t\t\tthrow e;\n\t\t}\n\t}\n\t}\t\n}\n```\n\n其实现就是将 ServerSocketChannel 注册到 selector 上，并以自身NioServerSocketChannel 作为附件；\n\n\t注意：此时注册的时候　监听的事件　并不是 ACCEPT; 而是 0\n\n##### NioServerSocketChannel 端口绑定\n\n上文中在完成了 channel 的注册之后，我们在回头看 doBind 的实现:\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n        final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel();\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        promise.setFailure(cause);\n                    } else {\n                        promise.executor = channel.eventLoop();\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n    }\n```\n\n在 channel 注册完成后会执行 doBind0 \n\n```java\nprivate static void doBind0(\n            final ChannelFuture regFuture, final Channel channel,\n            final SocketAddress localAddress, final ChannelPromise promise) {\n        channel.eventLoop().execute(new Runnable() {\n            @Override\n            public void run() {\n                if (regFuture.isSuccess()) {\n                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n                } else {\n                    promise.setFailure(regFuture.cause());\n                }\n            }\n        });\n    }\n```\n\n会调用 channel.bind()　跟踪发现最终会调用 unsafe.bind() 方法如下：\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n            assertEventLoop();\n\t\t\t// ......\n            boolean wasActive = isActive();\n            try {\n\t\t\t// 绑定地址端口\n                doBind(localAddress);\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n\n            if (!wasActive && isActive()) {\n\t\t\t// 绑定端口成功之后　触发 pipeline handler 的 channel active 事件\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive();\n                    }\n                });\n            }\n\n            safeSetSuccess(promise);\n        }\n```\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n        if (PlatformDependent.javaVersion() >= 7) {\n            javaChannel().bind(localAddress, config.getBacklog());\n        } else {\n            javaChannel().socket().bind(localAddress, config.getBacklog());\n        }\n    }\n```\n\n\t此时完成了 ServerSocketChannel 的服务端地址绑定\n\n##### NioServerSocketChannel 注册 ACCEPT 事件\n\n上文中在完成 bind 操作之后，会触发 channelPipeline 的 channel active 事件　最终调用了 channel 的 doBeginRead 方法\n\n```java\nprotected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        if (inputShutdown) {\n            return;\n        }\n\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) {\n\t\t\t// 将 selectionKey 添加 ACCEPT 事件的监听\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n\t至此完成了 ServerSocketChannel 注册到 selector 并让其监听 ACCEPT　事件；服务端也启动完毕。\n\n##### 小结\n\n对Netty的服务端启动分析完之后，大概认识了其包含的一些组件以及各组件的作用\n\n- ServerBootstrap ：该类是服务端启动的引导类，其主要用于配置 Netty 的各个组件\n- NioEventLoopGroup : 该类用于管理 NioEventLoop , 并提供了 Selector 选择器创建的入口并将其绑定到 NioEventLoop 实例\n- NioEventLoop : 该类内部绑定了一个线程以及一个任务队列用于处理 register bind的相关任务及客户端处理（后续会详细分析）\n- NioServerSocketChannel : 该类是对 ServerSocketChannel 的一个包装其内部包含了 unsafe channelPipeline 实例\n- Unsafe : 该类提供了底层的 register bind write read 等操作\n- DefaultChannelPipeline : 该类是个双向链表结构，其主要作用是在通道注册链接　读写的操作之后会触发相应的事件\n\n\n\n\n","tags":["netty"]},{"title":"zookeeper源码阅读之watch","url":"/2017/12/22/zookeeper源码阅读之watch/","content":"#### watcher 流程概述\n\n\twatcher 用来客户端监听某一节点的特性变化，执行对应的操作. 从下图可以看出 watcher 的流程主要包括:\n\n![](https://i.loli.net/2019/06/21/5d0c7de156e2432479.png)\n\n> - watcher 注册, 包括客户端注册, 服务端的注册\n> - watcher 触发\n> - watcher 执行\n\n<!-- more -->\n\n#### watcher 注册\n\n\t本文我们以 zookeeper.getData 操作为例，对 watcher 的注册流程就行说明。\n\n##### watcher 客户端注册\n\t\n\tgetData api　如下:\n\n```java\npublic byte[] getData(final String path, Watcher watcher, Stat stat)\n\t\tthrows KeeperException, InterruptedException\n{\n\t\tfinal String clientPath = path;\n\t\tPathUtils.validatePath(clientPath);\n\n\t\t// the watch contains the un-chroot path\n\t\tWatchRegistration wcb = null;\n\t\tif (watcher != null) {\n\t\t\t\t// 定义 watcher 注册\n\t\t\t\twcb = new DataWatchRegistration(watcher, clientPath);\n\t\t}\n\n\t\tfinal String serverPath = prependChroot(clientPath);\n\n\t\tRequestHeader h = new RequestHeader();\n\t\th.setType(ZooDefs.OpCode.getData);\n\t\tGetDataRequest request = new GetDataRequest();\n\t\trequest.setPath(serverPath);\n\t\t// watcher 不为空的时候　设置为 true\n\t\trequest.setWatch(watcher != null);\n\t\tGetDataResponse response = new GetDataResponse();\n\t\tReplyHeader r = cnxn.submitRequest(h, request, response, wcb);\n\t\tif (r.getErr() != 0) {\n\t\t\t\tthrow KeeperException.create(KeeperException.Code.get(r.getErr()),\n\t\t\t\t\t\t\t\tclientPath);\n\t\t}\n\t\tif (stat != null) {\n\t\t\t\tDataTree.copyStat(response.getStat(), stat);\n\t\t}\n\t\treturn response.getData();\n}\n\n```\n\t在完成本次请求，处理返回 packet 的时候, 会调用 ClinetCnxn.finishPacket(packet) 方法\n\n```java\nprivate void finishPacket(Packet p) {\n\tint err = p.replyHeader.getErr();\n\tif (p.watchRegistration != null) {\n\t\t\t// 调用 wwatcher　register; 处理正常的时候 err 值为 0; 可参考类 FinalRequestProcessor\n\t\t\tp.watchRegistration.register(err);\n\t}\n\t// 省略\n}\n```\n\t以下为 watchRegistration.register 源码:\n\n```java\npublic void register(int rc) {\n\tif (shouldAddWatch(rc)) {\n\t\t// client　下允许对多个路径设置监听\n\t\tMap<String, Set<Watcher>> watches = getWatches(rc);\n\t\tsynchronized(watches) {\n\t\t\t\tSet<Watcher> watchers = watches.get(clientPath);\n\t\t\t\tif (watchers == null) {\n\t\t\t\t\t\t//　同一路径下允许有多个 watcher　\n\t\t\t\t\t\twatchers = new HashSet<Watcher>();\n\t\t\t\t\t\twatches.put(clientPath, watchers);\n\t\t\t\t}\n\t\t\t\twatchers.add(watcher);\n\t\t}\n\t}\n}\n\nprotected boolean shouldAddWatch(int rc) {\n\t\treturn rc == 0;\n}\n\nprotected Map<String, Set<Watcher>> getWatches(int rc) {\n\t\treturn watchManager.dataWatches;\n}\n```\n\n> 从以上代码中可以看出, 客户端在定义 watcher 之后会将其与 path 绑定添加到 ZKWatchManager.dataWatches; 从而完成 watcher 的注册。\n\n##### watcher 服务端注册\n\nserver 在接收到客户端请求执行 FinalRequestProcessor.processRequest 方法过程中，会执行对 watcher　的注册，这里同样以 getData 操作的代码进行分析:\n\n```java\n\tcase OpCode.getData: {\n\t \tlastOp = \"GETD\";\n\t \tGetDataRequest getDataRequest = new GetDataRequest();\n\t \tByteBufferInputStream.byteBuffer2Record(request.request,\n\t\t\t\t\t getDataRequest);\n\t \tDataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());\n\t\tif (n == null) {\n\t\t\t throw new KeeperException.NoNodeException();\n\t \t}\n\t \tPrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),\n\t\t\t\t\t ZooDefs.Perms.READ,\n\t\t\t\t\t request.authInfo);\n\t \tStat stat = new Stat();\n\t\t// 若 client 请求的时候 watch 为 true,　则将 cnxn　作为参数\n\t\t// cnxn 为每个客户端请求链接的时候　针对 selectorKey 绑定的 NIOServerCnxn 实例\n\t \tbyte b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,\n\t\t\t\t\t getDataRequest.getWatch() ? cnxn : null);\n\t \trsp = new GetDataResponse(b, stat);\n\t \tbreak;\n\t}\n\n```\n\n从上面代码中  zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDataRequest.getWatch() ? cnxn : null); 跟踪发现其最后调用了 WatchManager.addWatch(path, watcher) 方法.\n\n```java\n// 注意 : 此时传递的参数 watcher 并不是客户端定义的 watcher 实例，而是服务端存储的与客户端绑定的\n// NIOServerCnxn 实例；因为 NIOServerCnxn 实现了 watcher 接口;\n// watchTable 用来存储 path　与　watcher　的关系; 也可以表示为 多个客户端监听了同一节点\n// watch2Paths　用来存储 watcher 与 path 的关系; 也可以表示为 每个客户端下监听了哪些节点\nsynchronized void addWatch(String path, Watcher watcher) {\n\t\tHashSet<Watcher> list = watchTable.get(path);\n\t\tif (list == null) {\n\t\t\t\t// don't waste memory if there are few watches on a node\n\t\t\t\t// rehash when the 4th entry is added, doubling size thereafter\n\t\t\t\t// seems like a good compromise\n\t\t\t\tlist = new HashSet<Watcher>(4);\n\t\t\t\twatchTable.put(path, list);\n\t\t}\n\t\tlist.add(watcher);\n\n\t\tHashSet<String> paths = watch2Paths.get(watcher);\n\t\tif (paths == null) {\n\t\t\t\t// cnxns typically have many watches, so use default cap here\n\t\t\t\tpaths = new HashSet<String>();\n\t\t\t\twatch2Paths.put(watcher, paths);\n\t\t}\n\t\tpaths.add(path);\n}\n\n```\n> 从上面代码中可以看出,服务端在处理完客户端请求的时候　若客户端设置了 watcher 则会将其添加到 watchmanager 的 watchTable 中；至此服务端针对 watcher 的注册完毕.\n\n#### watcher 触发\n\n针对 watcher 触发的操作，这里以 setData api 为例说明。此时假设某个客户端执行了 setData 操作, 服务端在处理客户端请求的时候, 在调用 FinalRequestProcessor.processRequest　方法的时候会调用 \n```java\n\tzookeeperServer.processTxn(request);\n```\n\n最终会调用 DataTree.processTxn() 方法，此处摘取针对 setData 的操作如下　：\n```java\ncase OpCode.setData:\n\tSetDataTxn setDataTxn = (SetDataTxn) txn;\n\trc.path = setDataTxn.getPath();\n\trc.stat = setData(setDataTxn.getPath(), setDataTxn\n\t\t\t\t.getData(), setDataTxn.getVersion(), header\n\t\t\t\t.getZxid(), header.getTime());\n\tbreak;\n```\n\n```java\npublic Stat setData(String path, byte data[], int version, long zxid,\n\t\t\t\tlong time) throws KeeperException.NoNodeException {\n\t\tStat s = new Stat();\n\t\tDataNode n = nodes.get(path);\n\t\tif (n == null) {\n\t\t\t\tthrow new KeeperException.NoNodeException();\n\t\t}\n\t\tbyte lastdata[] = null;\n\t\tsynchronized (n) {\n\t\t\t\tlastdata = n.data;\n\t\t\t\tn.data = data;\n\t\t\t\tn.stat.setMtime(time);\n\t\t\t\tn.stat.setMzxid(zxid);\n\t\t\t\tn.stat.setVersion(version);\n\t\t\t\tn.copyStat(s);\n\t\t}\n\t\t// now update if the path is in a quota subtree.\n\t\tString lastPrefix = getMaxPrefixWithQuota(path);\n\t\tif(lastPrefix != null) {\n\t\t\t\t// 更新节点数据\n\t\t\t\tthis.updateBytes(lastPrefix, (data == null ? 0 : data.length)\n\t\t\t\t\t\t\t\t- (lastdata == null ? 0 : lastdata.length));\n\t\t}\n\t\t// 触发该节点下的 watcher\n\t\tdataWatches.triggerWatch(path, EventType.NodeDataChanged);\n\t\treturn s;\n}\n\n```\n\n从上述代码中可以看出, 服务端在完成对节点数据更新之后调用了 watcher.triggerWatch(); 该方法接收两个参数一个为节点path, 一个为事件类型\n\n```java\nSet<Watcher> triggerWatch(String path, EventType type, Set<Watcher> supress) {\n\t\tWatchedEvent e = new WatchedEvent(type,\n\t\t\t\t\t\tKeeperState.SyncConnected, path);\n\t\tHashSet<Watcher> watchers;\n\t\tsynchronized (this) {\n\t\t\t\twatchers = watchTable.remove(path);\n\t\t\t\tif (watchers == null || watchers.isEmpty()) {\n\t\t\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tZooTrace.logTraceMessage(LOG,\n\t\t\t\t\t\t\t\t\t\t\t\tZooTrace.EVENT_DELIVERY_TRACE_MASK,\n\t\t\t\t\t\t\t\t\t\t\t\t\"No watchers for \" + path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfor (Watcher w : watchers) {\n\t\t\t\t\t\tHashSet<String> paths = watch2Paths.get(w);\n\t\t\t\t\t\tif (paths != null) {\n\t\t\t\t\t\t\t\tpaths.remove(path);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tfor (Watcher w : watchers) {\n\t\t\t\tif (supress != null && supress.contains(w)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tw.process(e);\n\t\t}\n\t\treturn watchers;\n}\n\n```\n\n从以上代码中看出在触发 watcher 的时候，会先从 watchManager 中的 watchTable 获取指定 path 的 watcher 并将其从集合中移除（从此处我们可以看出客户端定义的 watcher　若未作处理的话　将只会监听一次）。在查找到 watcher 之后将会调用 watcher.process 即执行 watcher.\n\n#### watcher 执行\n\n在服务端触发 watcher　之后，会调用 watcher.process　方法，此时 watcher 的实例为 NIOServerCnxn;接下来我们看下 NIOSserverCnxn 的 process　方法:\n\n```java \npublic void process(WatchedEvent event) {\n\t\tReplyHeader h = new ReplyHeader(-1, -1L, 0);\n\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\tZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n\t\t\t\t\t\t\t\t\"Deliver event \" + event + \" to 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(this.sessionId)\n\t\t\t\t\t\t\t\t+ \" through \" + this);\n\t\t}\n\n\t\t// Convert WatchedEvent to a type that can be sent over the wire\n\t\tWatcherEvent e = event.getWrapper();\n\n\t\tsendResponse(h, e, \"notification\");\n}\n\n```\n\n从上面代码中可以看出服务端向客户端发出了 tag 为 \"notification\" 的响应；　接下来我们看下客户端如何处理该响应:\n在 ClientCnxn 下的 SendThread.readResponse 方法中我们可以看到针对 watcher　的处理如下：\n```java\nif (replyHdr.getXid() == -1) {\n\t\t// -1 means notification\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Got notification sessionid:0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId));\n\t\t}\n\t\t// 从 response 中反序列化\n\t\tWatcherEvent event = new WatcherEvent();\n\t\tevent.deserialize(bbia, \"response\");\n\n\t\t// convert from a server path to a client path\n\t\tif (chrootPath != null) {\n\t\t\t\tString serverPath = event.getPath();\n\t\t\t\tif(serverPath.compareTo(chrootPath)==0)\n\t\t\t\t\t\tevent.setPath(\"/\");\n\t\t\t\telse if (serverPath.length() > chrootPath.length())\n\t\t\t\t\t\tevent.setPath(serverPath.substring(chrootPath.length()));\n\t\t\t\telse {\n\t\t\t\t\t\tLOG.warn(\"Got server path \" + event.getPath()\n\t\t\t\t\t\t\t\t\t\t+ \" which is too short for chroot path \"\n\t\t\t\t\t\t\t\t\t\t+ chrootPath);\n\t\t\t\t}\n\t\t}\n\n\t\tWatchedEvent we = new WatchedEvent(event);\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Got \" + we + \" for sessionid 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId));\n\t\t}\n\t\t// 将 watchedEvent 交由 eventThread　处理\n\t\teventThread.queueEvent( we );\n\t\treturn;\n}\n\n```\n```java\nprivate void queueEvent(WatchedEvent event,\n\t\t\t\tSet<Watcher> materializedWatchers) {\n\t\tif (event.getType() == EventType.None\n\t\t\t\t\t\t&& sessionState == event.getState()) {\n\t\t\t\treturn;\n\t\t}\n\t\tsessionState = event.getState();\n\t\tfinal Set<Watcher> watchers;\n\t\tif (materializedWatchers == null) {\n\t\t\t\t// materialize the watchers based on the event\n\t\t\t\t// 从 ZKWatchManager 中获取 path　的 watcher\n\t\t\t\twatchers = watcher.materialize(event.getState(),\n\t\t\t\t\t\t\t\tevent.getType(), event.getPath());\n\t\t} else {\n\t\t\t\twatchers = new HashSet<Watcher>();\n\t\t\t\twatchers.addAll(materializedWatchers);\n\t\t}\n\t\tWatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);\n\t\t// queue the pair (watch set & event) for later processing\n\t\twaitingEvents.add(pair);\n}\n\n```\n\n从上面代码看出 客户端在处理 watcher　通知的时候会将其封装为 WatcherSetEventPair 对象并添加到 waitingEvents　队列中此时会唤醒阻塞在队列的操作，也即 eventThread 的 run 方法，如下：\n\n```java\npublic void run() {\n\t\ttry {\n\t\tisRunning = true;\n\t\twhile (true) {\n\t\t\t\tObject event = waitingEvents.take();\n\t\t\t\tif (event == eventOfDeath) {\n\t\t\t\t\t\twasKilled = true;\n\t\t\t\t} else {\n\t\t\t\t\t\tprocessEvent(event);\n\t\t\t\t}\n\t\t\t\tif (wasKilled)\n\t\t\t\t\t\tsynchronized (waitingEvents) {\n\t\t\t\t\t\t\t\tif (waitingEvents.isEmpty()) {\n\t\t\t\t\t\t\t\t\t\tisRunning = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\t\tLOG.error(\"Event thread exiting due to interruption\", e);\n\t\t}\n\n\t\tLOG.info(\"EventThread shut down for session: 0x{}\",\n\t\t\t\t\t\tLong.toHexString(getSessionId()));\n}\n\n```\n截取 processEvent 方法中针对 watcher 的处理\n```java \nf (event instanceof WatcherSetEventPair) {\n\t\t// each watcher will process the event\n\t\tWatcherSetEventPair pair = (WatcherSetEventPair) event;\n\t\tfor (Watcher watcher : pair.watchers) {\n\t\t\t\ttry {\n\t\t\t\t\t\t// 执行 watcher\n\t\t\t\t\t\twatcher.process(pair.event);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLOG.error(\"Error while calling watcher \", t);\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n从上面代码看出当 waitingEvents　队列中存在待处理的 watcher 时将会依次调用；至此完成 watcher的执行；到此完成对 zookeeper　watcher　的分析.\n\n","tags":["zookeeper"]},{"title":"NIO selector的wakeup","url":"/2017/12/21/NIO-selector的wakeup/","content":"\n###### wakeUp\n\n> 某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。\n如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。\n\n引用至 http://ifeve.com/selectors/\n\n<!-- more -->\n\n###### 测试\n\n```java\npublic class App \n{\n\t\tprivate Selector selector;\n\n\t\tpublic void start () throws IOException {\n\t\t\t\t// 开启选择器 selector\n\t\t\t\tselector = Selector.open();\n\n\t\t\t\t// 开启服务端 socket 通道\n\t\t\t\tServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\t\t\t\t// 设置为非阻塞\n\t\t\t\tserverSocketChannel.configureBlocking(false);\n\t\t\t\t// 绑定服务端端口\n\t\t\t\tserverSocketChannel.socket().bind(new InetSocketAddress(8888));\n\t\t\t\t// 通道注册到选择器上　并监听　接收客户端事件\n\t\t\t\tserverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\t\t\t\t// 因 selector.select 会阻塞当前线程　故异步处理\n\t\t\t\tnew Thread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tSystem.out.println(\"select 前执行\");\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tselector.select();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSystem.out.println(\"select 后执行\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}).start();\n\n\t\t}\n\n\t\tpublic void wakeup () {\n\t\t\t\tSystem.out.println(\"开始唤醒\");\n\t\t\t\tselector.wakeup();\n\t\t}\n\n\t\tpublic static void main( String[] args ) throws IOException, InterruptedException {\n\t\t\t\tfinal App app = new App();\n\t\t\t\tapp.start();\n\n\t\t\t\tThread thread = new Thread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapp.wakeup();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthread.start();\n\n\t\t\t\tthread.join();\n\t\t}\n}\n\n```\n\n\n```java\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\n```\n\n从执行结果可以看出 在调用了 wakeup() 方法之后，即可唤醒阻塞在 select() 上的操作　也即 select() 方法会立马返回.\n\n","tags":["NIO"]},{"title":"zookeeper源码阅读之client","url":"/2017/12/15/zookeeper源码阅读之client/","content":"\n#### zookeeper client 启动流程\n> 先看下 zookeeper client 相关类图\n![](https://i.loli.net/2019/06/21/5d0c7dce48fc932501.png)\n\n<!-- more -->\n\n##### 执行 zkCli.sh 脚本时, 会运行 org.apache.zookeeper.ZookeeperMain 类主方法.\n```java\npublic static void main(String args[])\n\t\tthrows KeeperException, IOException, InterruptedException\n{\n\tZooKeeperMain main = new ZooKeeperMain(args);\n\tmain.run();\n}\n\n```\n```java\npublic ZooKeeperMain(String args[]) throws IOException, InterruptedException {\n\t// 启动参数解析\n\tcl.parseOptions(args);\n\tSystem.out.println(\"Connecting to \" + cl.getOption(\"server\"));\n\t// 链接 zookeeper server\n\tconnectToZK(cl.getOption(\"server\"));\n}\n```\n\n> 从代码中可以看出 client 启动时首先构造 ZookeeperMain　对象实例,构造过程中会先解析 client 的启动参数（若未指定任何参数将会默认链接本机 2181 端口 zookeeper server）\n<!-- more -->\n##### 通过调用 connectToZK 链接 zookeeper server\n```java\nprotected void connectToZK(String newHost) throws InterruptedException, IOException {\n\tif (zk != null && zk.getState().isAlive()) {\n\t\t// 若已创建 zookeeper 对象并且状态为激活　则关闭重新创建\n\t\tzk.close();\n\t}\n\thost = newHost;\n\tboolean readOnly = cl.getOption(\"readonly\") != null;\n\tif (cl.getOption(\"secure\") != null) {\n\t\tSystem.setProperty(ZKClientConfig.SECURE_CLIENT, \"true\");\n\t\tSystem.out.println(\"Secure connection is enabled\");\n\t}\n\t// 构造 Zookeeper 对象实例\n\tzk = new ZooKeeper(host,Integer.parseInt(cl.getOption(\"timeout\")),\n\t\t\t\tnew MyWatcher(), readOnly);\n}\n\n```\n##### 创建 Zookeeper 对象实例\n```java\n// connectString 是形如 host:port,host:port 的字符串片段\npublic ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,\n\t\t\t\tboolean canBeReadOnly, HostProvider aHostProvider,\n\t\t\t\tZKClientConfig clientConfig) throws IOException {\n\n\tif (clientConfig == null) {\n\t\t// 创建 ZKClient Config 对象\n\t\tclientConfig = new ZKClientConfig();\n\t}\n\tthis.clientConfig = clientConfig;\n\twatchManager = defaultWatchManager();\n\twatchManager.defaultWatcher = watcher;\n\tConnectStringParser connectStringParser = new ConnectStringParser(\n\t\t\t\tconnectString);\n\thostProvider = aHostProvider;\n\t// 创建 ClientCnxn 对象\n\tcnxn = new ClientCnxn(connectStringParser.getChrootPath(),\n\t\t\t\thostProvider, sessionTimeout, this, watchManager,\n\t\t\t\tgetClientCnxnSocket(), canBeReadOnly);\n\tcnxn.start();\n}\n// 创建 ClientCnxnSocket对象 默认为 ClientCnxnSocketNIO 对象\nprivate ClientCnxnSocket getClientCnxnSocket() throws IOException {\n\t\tString clientCnxnSocketName = getClientConfig().getProperty(\n\t\t\t\t\t\tZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);\n\t\tif (clientCnxnSocketName == null) {\n\t\t\t\tclientCnxnSocketName = ClientCnxnSocketNIO.class.getName();\n\t\t}\n\t\ttry {\n\t\t\t\tConstructor<?> clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);\n\t\t\t\tClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());\n\t\t\t\treturn clientCxnSocket;\n\t\t} catch (Exception e) {\n\t\t\t\tIOException ioe = new IOException(\"Couldn't instantiate \"\n\t\t\t\t\t\t\t\t+ clientCnxnSocketName);\n\t\t\t\tioe.initCause(e);\n\t\t\t\tthrow ioe;\n\t\t}\n}\n```\n> 从代码中看出 Zookeeper 关联了 ClientCnxn 对象, 在创建了 ClientCnxn 对象实例之后调用了 cnxn.start() 方法。\n##### 创建 ClientCnxn 对象实例\n\n```java\npublic ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,\n\t\t\t\tClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,\n\t\t\t\tlong sessionId, byte[] sessionPasswd, boolean canBeReadOnly) {\n\t\tthis.zooKeeper = zooKeeper;\n\t\tthis.watcher = watcher;\n\t\tthis.sessionId = sessionId;\n\t\tthis.sessionPasswd = sessionPasswd;\n\t\tthis.sessionTimeout = sessionTimeout;\n\t\tthis.hostProvider = hostProvider;\n\t\tthis.chrootPath = chrootPath;\n\t\t// 计算连接超时时间　读数据超时时间\n\t\tconnectTimeout = sessionTimeout / hostProvider.size();\n\t\treadTimeout = sessionTimeout * 2 / 3;\n\t\treadOnly = canBeReadOnly;\n\t\t// 创建了 SendThread EventThread　线程实例\n\t\tsendThread = new SendThread(clientCnxnSocket);\n\t\teventThread = new EventThread();\n\t\tthis.clientConfig=zooKeeper.getClientConfig();\n}\n\npublic void start() {\n\t\tsendThread.start();\n\t\teventThread.start();\n}\n```\n> 从 start 方法中可以看出分别启动了 sendThread eventThread　两个线程。\n\n##### SendThread 线程的构造及启动\n```java\nSendThread(ClientCnxnSocket clientCnxnSocket) {\n\t\tsuper(makeThreadName(\"-SendThread()\"));\n\t\tstate = States.CONNECTING;\n\t\tthis.clientCnxnSocket = clientCnxnSocket;\n\t\tsetDaemon(true);\n}\n\n```\n> SendThread 是 ClientCnxn 的内部类, 创建该线程实例时会将 ClientCnxn 的状态由默认状态(未连接)改为连接中,并赋值 clientCnxnSocket。\n\n###### ClientCnxn 的主要成员变量说明\n> 在了解 sendThread 线程的启动过程有必要先了解一下关于 SendThread 和 ClientCnxn 的相关成员变量。\n\n| 变量名 | 描述 |\n|--------|------|\n| state  | 客户端连接状态 |\n| outgoingQueue | 存储需要被发送出去的报文的队列 |\n| pendingQueue | 存储已经发送等待响应结果的队列 |\n\n##### SendThread 线程启动\n```java\npublic void run() {\n\t// 将 sendThread sessionId outgoingQueue 绑定到的 clientCnxnSocketNIO\n\tclientCnxnSocket.introduce(this, sessionId, outgoingQueue);\n\tclientCnxnSocket.updateNow();\n\tclientCnxnSocket.updateLastSendAndHeard();\n\tint to;\n\tlong lastPingRwServer = Time.currentElapsedTime();\n\tfinal int MAX_SEND_PING_INTERVAL = 10000; //10 seconds\n\twhile (state.isAlive()) {\n\t\ttry {\n\t\t\tif (!clientCnxnSocket.isConnected()) {\n\t\t\t\t// don't re-establish connection if we are closing\n\t\t\t\tif (closing) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 如果 clientCnxnSocketNIO 未连接　则开始连接\n\t\t\t\tstartConnect();\n\t\t\t\tclientCnxnSocket.updateLastSendAndHeard();\n\t\t\t}\t\n\n\t\t\t\tif (state.isConnected()) {\n\t\t\t\t\t\t// determine whether we need to send an AuthFailed event.\n\t\t\t\t\t\tif (zooKeeperSaslClient != null) {\n\t\t\t\t\t\t\t// ssl client　的处理此处省略\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = readTimeout - clientCnxnSocket.getIdleRecv();\n\t\t\t\t} else {\n\t\t\t\t\t\tto = connectTimeout - clientCnxnSocket.getIdleRecv();\n\t\t\t\t}\n\n\t\t\t\tif (to <= 0) {\n\t\t\t\t\t\tString warnInfo;\n\t\t\t\t\t\twarnInfo = \"Client session timed out, have not heard from server in \"\n\t\t\t\t\t\t\t\t+ clientCnxnSocket.getIdleRecv()\n\t\t\t\t\t\t\t\t+ \"ms\"\n\t\t\t\t\t\t\t\t+ \" for sessionid 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId);\n\t\t\t\t\t\tLOG.warn(warnInfo);\n\t\t\t\t\t\tthrow new SessionTimeoutException(warnInfo);\n\t\t\t\t}\n\t\t\t\tif (state.isConnected()) {\n\t\t\t\t\t\t//1000(1 second) is to prevent race condition missing to send the second ping\n\t\t\t\t\t\t//also make sure not to send too many pings when readTimeout is small \n\t\t\t\t\t\tint timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - \n\t\t\t\t\t\t\t\t((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n\t\t\t\t\t\t//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n\t\t\t\t\t\tif (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n\t\t\t\t\t\t\t\t// 发送心跳\n\t\t\t\t\t\t\t\tsendPing();\n\t\t\t\t\t\t\t\tclientCnxnSocket.updateLastSend();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (timeToNextPing < to) {\n\t\t\t\t\t\t\t\t\t\tto = timeToNextPing;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we are in read-only mode, seek for read/write server\n\t\t\t\tif (state == States.CONNECTEDREADONLY) {\n\t\t\t\t\t\tlong now = Time.currentElapsedTime();\n\t\t\t\t\t\tint idlePingRwServer = (int) (now - lastPingRwServer);\n\t\t\t\t\t\tif (idlePingRwServer >= pingRwTimeout) {\n\t\t\t\t\t\t\t\tlastPingRwServer = now;\n\t\t\t\t\t\t\t\tidlePingRwServer = 0;\n\t\t\t\t\t\t\t\tpingRwTimeout =\n\t\t\t\t\t\t\t\t\t\tMath.min(2*pingRwTimeout, maxPingRwTimeout);\n\t\t\t\t\t\t\t\tpingRwServer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = Math.min(to, pingRwTimeout - idlePingRwServer);\n\t\t\t\t}\n\n\t\t\t\tclientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n\t\t} catch (Throwable e) {\n\t\t\t// 异常处理的部分省略...\t\n\t\t}\n\t\t}\n\t\tsynchronized (state) {\n\t\t\t\t// When it comes to this point, it guarantees that later queued\n\t\t\t\t// packet to outgoingQueue will be notified of death.\n\t\t\t\tcleanup();\n\t\t}\n\t\tclientCnxnSocket.close();\n\t\tif (state.isAlive()) {\n\t\t\t\teventThread.queueEvent(new WatchedEvent(Event.EventType.None,\n\t\t\t\t\t\t\t\t\t\tEvent.KeeperState.Disconnected, null));\n\t\t}\n\t\tZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),\n\t\t\t\t\t\t\"SendThread exited loop for session: 0x\"\n\t\t\t\t\t\t+ Long.toHexString(getSessionId()));\n}\n```\n>  从代码中可以看出 sendThread 主要做以下事情\n> - 创建客户端连接\n> - 发送心跳\n> - 发送消息 (终端输入的指令)\n\n> 下面将针对上面三种流程分析\n\n###### 客户端连接创建流程\n\n> 先大概看下此流程活动图　如下:\n\n![](https://i.loli.net/2019/06/21/5d0c7dd21a15341180.png)\n\n> - sendThread 轮询过程中　先判断 clientCnxnSocket 是否已连接；若未连接则调用 sendThread.startConnect() 将 ClientCnxn.state 的状态改为 \"连接中\", 接下来同步调用 clientCnxnSocket.connect 完成客户端 socket 的创建及注册到 selector 并监听连接事件\n> - 上述操作完成后会调用 clientCnxnSocket.doTransport (), 该方法主要处理 selector 选择器上就绪的通道事件.\n> - 当客户端 socket 连接就绪的时候会调用 sendThread.primeConnection() 准备连接方法，该方法 ConnectionRequet　的 Packet　并将其添加到 outgoingQueue　对列中，接下来调用 clientCnxnSocket.connectionPrimed 该方法主要告知 socket　准备好连接了 此时客户端在 selector 上注册读写事件 (此时会触发通道的写就绪事件)\n> - 当客户端 socket 写就绪的时候会调用 clientCnxnSocket.findSendablePacket 该方法从 outgoingQueue 队列中获取待发送的 Packet , 最后执行 socket.write() 发送消息(此时会触发通道的读就绪事件)\n> - 当客户端 socket 读就绪的时候判断 initialized 是否为 true，若为 false 说明执行连接初始化会调用 sendThread.onConnected 更改客户端状态为 \"已连接\"，　继续注册监听客户端的读写事件\n\n###### 客户端心跳流程\n> 心跳流程如下：\n\n![](https://i.loli.net/2019/06/21/5d0c7dd6106a397271.png)\n\n> - sendThread 轮询过程中　判断 state 是否为 \"已连接\"; 若已连接判断是否满足心跳条件, 调用 sendPing 创建心跳 packet　header xid = -2; 接下来将 packet　添加到 outgoingQueue　队列中并调用 clientCnxnSocket.packetAddedd　最后唤醒阻塞在 selector.select 上的操作\n> - 当客户端 socket 写就绪的时候调用 findSendablePacket 获取待发送的 packet 最后调用 socket.write 执行发送\n> - 当客户端 socket 读就绪的时候调用 sendThread.readResponse 解析服务端的响应结果, 通过获取 response heaher xid 判断 xid == -2 ;　若为 -2 则打印心跳返回日志返回，　此时一次心跳结束\n\n###### 客户端终端发送指令流程\n\n> 发送指令流程图如下:\n\n![](https://i.loli.net/2019/06/21/5d0c7ddaac2f166051.png)\n\n> - ZookeeperMain 构建完成后会调用 run　方法，等待用户输入\n> - 输入指令后会相应调用 executeLine, processCmd, processZKCmd 通过解析参数获取相应的 CliCommand\n> - 此处采用了命令模式 内置了各种 CliCommand 对应客户端相应的操作，包括(CreateCommand, GetCommand, SetCommand ....）; 获取对应的命令后，调用 parse, exec　方法执行命令\n> - 执行命令会调用 zookeeper 对应的操作(create, getData, setData)，在内部会调用 ClientCnxn.submitRequest 方法\n> - 在 clientCnxn.submitRequest　方法中会调用 queuePacket　创建 packet　并将其添加到队列中，接着唤醒 clientCnxnSocketNIO 的 selector.select 操作；后续操作就是读写就绪事件的处理与心跳流程类似。\n\n\n至此 zookeeper client 的相关流程介绍完毕　细节的地方后续在处理.\n\n\n"},{"title":"NIO之粘包拆包处理","url":"/2017/12/14/NIO之粘包拆包处理/","content":"\n#### 概述\n\n> 我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。\n\n<!-- more -->\n\n#### 粘包拆包的原因\n\n> 关于 tcp 传输过程中，发生粘包拆包的原因及表现形式可参考网上的一篇[博客](https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/); 这里就不在说明.\n\n#### 粘包拆包的解决方法\n\n> 本文给出针对自定义消息报文格式，通过在消息头部添加消息载体长度来处理\n<!-- more -->\n##### 实现方式\n\n###### 消息内容包装\n\n```java\npublic class PacketWrapper {\n\n\t\t// 消息有效长度\n\t\tprivate int length;\n\t\t// 消息的有效载体\n\t\tprivate byte[] payload;\n\n\t\tpublic PacketWrapper(String payload) {\n\t\t\t\tthis.payload = payload.getBytes();\n\t\t\t\tthis.length = this.payload.length;\n\t\t}\n\n\t\tpublic PacketWrapper(byte[] payload) {\n\t\t\t\tthis.payload = payload;\n\t\t\t\tthis.length = this.payload.length;\n\t\t}\n\n\t\t// 返回包装后的字节数组\n\t\tpublic byte[] getBytes() {\n\t\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(this.length + 4);\n\t\t\t\tbyteBuffer.putInt(this.length);\n\t\t\t\tbyteBuffer.put(payload);\n\t\t\t\treturn byteBuffer.array();\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor (byte b : getBytes()) {\n\t\t\t\t\t\tsb.append(String.format(\"0x%02X \", b));\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t}\n}\n\n```\n\n###### 消息报文的解码\n\n```java\n\npublic class NioDecodeHandler {\n\n    private static Logger log = Logger.getLogger(NioDecodeHandler.class);\n\n    private final int HEAD_LENGTH = 4;\n\n    protected ByteBuffer lastReadBuffer = null;\n\n    public void decode (SocketChannel socketChannel) {\n        // 从通道中读取内容\n\t\tByteBuffer readByteBuffer = ByteBuffer.allocate(128);\n        try {\n            int read = socketChannel.read(readByteBuffer);\n            if (read < 0) {\n                throw new RuntimeException(\"\");\n            }\n        } catch (IOException e) {\n\n        }\n\n        ByteBuffer newByteBuffer = readByteBuffer;\n        if (newByteBuffer == null) {\n            return;\n        }\n        // 切换到读模式\n        newByteBuffer.flip();\n\n        if (lastReadBuffer != null) {\n            // 将上次遗留的数据与本次已读的数据合并\n            newByteBuffer = ByteBufferUtil.composite(lastReadBuffer, newByteBuffer);\n        }\n\n        decode : while (true) {\n            if (newByteBuffer.remaining() <= HEAD_LENGTH) {\n\t\t\t\t// 报文字节数达不到报文长度退出\n                lastReadBuffer = ByteBuffer.wrap(ByteBufferUtil.readBuffer(newByteBuffer, newByteBuffer.remaining()));\n                return;\n            }\n\n            // 获取报文头部, 即报文有效长度\n            int payloadLength = newByteBuffer.getInt();\n            if (newByteBuffer.remaining() < payloadLength) {\n                // 拆包 : 后续字节不够一个完整报文\n                // 因上一操作 getInt 读取了 4　字节, 故需将　position 退回移动 4　字节\n                newByteBuffer.position(newByteBuffer.position() - HEAD_LENGTH);\n                lastReadBuffer = ByteBuffer.wrap(ByteBufferUtil.readBuffer(newByteBuffer, newByteBuffer.remaining()));\n                return;\n            }\n\n            // 获取有效报文\n            handlerPacket(socketChannel, ByteBufferUtil.readBuffer(newByteBuffer, payloadLength));\n\n            if (newByteBuffer.remaining() > 0) {\n                // 剩下的报文 可能是有效报文,　继续解码\n                continue decode;\n            }\n\n            return;\n        }\n    }\n\n\n\n    private void handlerPacket (SocketChannel socketChannel, byte[] packet) {\n        ServiceLoader<PacketHandler> packetHandlers = ServiceLoader.load(PacketHandler.class);\n        Iterator<PacketHandler> packetHandlerIterator = packetHandlers.iterator();\n\n        while (packetHandlerIterator.hasNext()) {\n            packetHandlerIterator.next().handler(socketChannel, packet);\n        }\n    }\n\n}\n\n```\n\n依赖的工具方法如下：\n\n```java\n\npublic class ByteBufferUtil {\n\n    private ByteBufferUtil () {}\n\n    /**\n     * 将两个 bytebuffer 合并\n     *\n     * @param byteBuffer1\n     * @param byteBuffer2\n     * @return\n     */\n    public static ByteBuffer composite(ByteBuffer byteBuffer1, ByteBuffer byteBuffer2) {\n        int capacity = byteBuffer1.limit() - byteBuffer1.position() + byteBuffer2.limit() - byteBuffer2.position();\n        ByteBuffer ret = ByteBuffer.allocate(capacity);\n\n        ret.put(byteBuffer1);\n        ret.put(byteBuffer2);\n\n        ret.position(0);\n        ret.limit(ret.capacity());\n        return ret;\n    }\n\n    /**\n     * 获取 bytebuffer 中可读的内容\n     *\n     * @param byteBuffer\n     * @param size\n     * @return\n     */\n    public static byte[] readBuffer(ByteBuffer byteBuffer, int size) {\n        byte[] bytes = new byte[size];\n\n        byteBuffer.get(bytes);\n\n        return bytes;\n    }\n}\n\n```\n","tags":["NIO"]},{"title":"NIO之ByteBuffer","url":"/2017/12/13/NIO之ByteBuffer/","content":"\n### ByteBuffer\n\n###### 字段说明\n> * Capacity : Buffer 固定的容量大小\n* Position : 表示当前的位置， 初始值为0；当为写模式时，当写入一个字节的时候，position会向前移动到下一个可插入数据的buffer单元；当为读模式时，position会重置为0，每读取一个字节的时候，position会向前移动下一个可读取的位置。\n* Limit : 表示buffer最多可写或可读的数量。写模式下limit = capacity; 读模式下limit = position\n\n<!-- more -->\n\n###### 初始化\n\n> 采用jvm堆内存初始\n\n```java\n  /**\n   * 定义初始容量10字节的缓冲区 capacity=10, limit=10, position=0\n   */\n  ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n```\n<!-- more -->\n> 采用堆外内存初始\n\n```java\n  /**\n   * 定义初始容量10字节的缓冲区 capacity=10, limit=10, position=0\n   */\n  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(10);\n\n```\n\n###### put(byte byte)\n\n> 写入数据时，每写入一个字节的时候 会检验 position >= limit, 之后执行position++ 自增操作；\n\n```java\n  public Bytebuffer put (byte x) {\n    hb[ix(nextPutIndex())] = x;\n    return this;\n  }\n\n  int nextPutIndex () {\n    if (position >= limit) {\n      throw new BufferOverflowException();\n    }\n    return position++;\n  }\n```\n\n![](https://i.loli.net/2019/06/21/5d0c7db13766110823.png)\n\n###### flip()\n\n> buffer 由写模式切换到读模式; limit 值为position， position会重置为0\n\n```java\n\n  public final Buffer flip() {\n    limit = position;\n    position = 0;\n    mark = -1;\n    return this;\n  }\n\n```\n![](https://i.loli.net/2019/06/21/5d0c7db3d139960621.png)\n\n###### get()\n\n> buffer 读取数据的时候，检验position>=limit; 之后执行position++\n\n```java\n  public byte get() {\n    return hb[ix(nextGetIndex())];\n  }\n\n  int nextGetIndex () {\n    if (position >= limit){\n      throw new BufferUnderflowException();\n    }\n    return position++;\n  }\n```\n\n![](https://i.loli.net/2019/06/21/5d0c7db61021985424.png)\n","tags":["NIO","bytebuffer"]},{"title":"zookeeper源码阅读之server","url":"/2017/12/12/zookeeper源码阅读之server/","content":"\n#### zookeeper server 启动流程概述\n\n> 此次只针对单机模式对 server 端的启动流程分析, 首先看下 zookeeper server 启动时序图，如下：\n\n![](https://i.loli.net/2019/06/21/5d0c7ddcef06919432.png)\n\n<!-- more -->\n\n> 其启动流程如下：\n> - 执行 zkServer.sh start 脚本, 会调用 QuorumPeerMain.main(); 执行 initializeAndRun 方法\n> - 调用 QuorumPeerConfig.parse() 方法，该方法主要是对启动参数的解析并加载相应的配置文件\n> - 通过上文解析的配置, 判断当前启动模式是否为集群或单机模式\n> - 单机模式下调用 ZookeeperServerMain.main() 方法\n> - 执行 ZookeeperServerMain.initializeAndRun 方法\n> - 调用 ServerConfig.parse 再次解析启动参数加载配置文件\n> - 调用 runFromConfig , 在该方法中依次启动 JettyAdminServer.start(), NIOServerCnxnFactory.startup()\n\n> 至此 zookeeper server 完成单机模式下启动，接下来将详细看下 NIOServerCnxnFactory.startup 的启动过程。\n<!-- more -->\n#### zookeeper server 线程模型\n\n> 在 NIOServerCnxnFactory.startup() 启动前, 我们先看下针对 NIOServerCnxnFactory 的对象的创建及相关配置:\n\n###### NIOServerCnxnFactory 的创建\n\n> 通过 ServerCnxnFactory.createFactory 完成 ServerCnxnFactory 的创建\n```java\n\tstatic public ServerCnxnFactory createFactory() throws IOException {\n\t\t// 获取系统变量 zookeeper.serverCnxnFactory\n\t\tString serverCnxnFactoryName =\n\t\t\t\tSystem.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);\n\t\tif (serverCnxnFactoryName == null) {\n\t\t\t// 若未指定该变量值 则默认返回 NIOServerCnxnFactory; 同时支持 NettyServerCnxnFactory\n\t\t\t\tserverCnxnFactoryName = NIOServerCnxnFactory.class.getName();\n\t\t}\n\t\ttry {\n\t\t\t\treturn (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)\n\t\t\t\t\t\t.newInstance();\n\t\t} catch (Exception e) {\n\t\t\t\tIOException ioe = new IOException(\"Couldn't instantiate \"\n\t\t\t\t\t\t\t\t+ serverCnxnFactoryName);\n\t\t\t\tioe.initCause(e);\n\t\t\t\tthrow ioe;\n\t\t}\n\t}\n```\n\n###### NIOServerCnxnFactory 的配置\n\n> 在执行 startup 前会调用 configure 方法执行相关参数的初始化并绑定 serverSocket \n\n```java\npublic void configure(InetSocketAddress addr, int maxcc, boolean secure) throws IOException {\n\t\tif (secure) {\n\t\t\t\tthrow new UnsupportedOperationException(\"SSL isn't supported in NIOServerCnxn\");\n\t\t}\n\t\tconfigureSaslLogin();\n\n\t\tmaxClientCnxns = maxcc;\n\t\tsessionlessCnxnTimeout = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);\n\t\t\n\t\tcnxnExpiryQueue =\n\t\t\t\tnew ExpiryQueue<NIOServerCnxn>(sessionlessCnxnTimeout);\n\t\texpirerThread = new ConnectionExpirerThread();\n\t\t// 返回虚拟机的可用处理器数量　也可认为 cpu 核数\n\t\tint numCores = Runtime.getRuntime().availableProcessors();\n\t\t// 32 cores sweet spot seems to be 4 selector threads\n\t\t// 计算 selectorThread 线程个数\n\t\tnumSelectorThreads = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_NUM_SELECTOR_THREADS,\n\t\t\t\t\t\tMath.max((int) Math.sqrt((float) numCores/2), 1));\n\t\tif (numSelectorThreads < 1) {\n\t\t\t\tthrow new IOException(\"numSelectorThreads must be at least 1\");\n\t\t}\n\n\t\t// 工作线程　workerThread　数; 默认为　2*numCores\n\t\tnumWorkerThreads = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);\n\t\tworkerShutdownTimeoutMS = Long.getLong(\n\t\t\t\t\t\tZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);\n\t\t// 创建 selectorThread 线程集合\n\t\tfor(int i=0; i<numSelectorThreads; ++i) {\n\t\t\t\tselectorThreads.add(new SelectorThread(i));\n\t\t}\n\n\t\t// 开启服务端链接通道并绑定端口\n\t\tthis.ss = ServerSocketChannel.open();\n\t\tss.socket().setReuseAddress(true);\n\t\tLOG.info(\"binding to port \" + addr);\n\t\tss.socket().bind(addr);\n\t\tss.configureBlocking(false);\n\n\t\t// 创建 AcceptThread 并绑定 ServerSocketChannel selecorThreads　\n\t\tacceptThread = new AcceptThread(ss, addr, selectorThreads);\n}\n```\n\n###### NIOServerCnxnFactory 的启动\n> 启动过程包括 NIOServerCnxnFactory 的启动和 ZookeeperServer 的启动\n```java\n\t\t@Override\n\tpublic void startup(ZooKeeperServer zks, boolean startServer)\n\t\tthrows IOException, InterruptedException {\n\t\tstart();\n\t\tsetZooKeeperServer(zks);\n\t\tif (startServer) {\n\t\t\t\tzks.startdata();\n\t\t\t\tzks.startup();\n\t\t}\n\t}\n\n```\n\n```java\npublic void start() {\n\t\tstopped = false;\n\t\tif (workerPool == null) {\n\t\t\t\tworkerPool = new WorkerService(\n\t\t\t\t\t\t\t\t\"NIOWorker\", numWorkerThreads, false);\n\t\t}\n\t\tfor(SelectorThread thread : selectorThreads) {\n\t\t\t\tif (thread.getState() == Thread.State.NEW) {\n\t\t\t\t\t\tthread.start();\n\t\t\t\t}\n\t\t}\n\t\t// ensure thread is started once and only once\n\t\tif (acceptThread.getState() == Thread.State.NEW) {\n\t\t\t\tacceptThread.start();\n\t\t}\n\t\tif (expirerThread.getState() == Thread.State.NEW) {\n\t\t\t\texpirerThread.start();\n\t\t}\n}\n```\n> 从代码中可以看出 NIOServerCnxnFactory 启动的时候开启了 AcceptThread SelectorThread ExpirerThread workerPool\n\n###### AcceptThread \n\n```java\npublic void run() {\n\ttry {\n\t\t// 当 server 未停止　并且 serverSocket 未关闭的时候一直轮询执行select()\n\t\twhile (!stopped && !acceptSocket.socket().isClosed()) {\n\t\t\t\ttry {\n\t\t\t\t\t\tselect();\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected runtime exception\", e);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected exception\", e);\n\t\t\t\t}\n\t\t}\n\t} finally {\n\t\tcloseSelector();\n\t\t// This will wake up the selector threads, and tell the\n\t\t// worker thread pool to begin shutdown.\n\t\tif (!reconfiguring) {                    \n\t\t\t\tNIOServerCnxnFactory.this.stop();\n\t\t}\n\t\tLOG.info(\"accept thread exitted run method\");\n\t}\n}\n```\n\n```java\nprivate void select() {\n\ttry {\n\t\tselector.select();\n\n\t\tIterator<SelectionKey> selectedKeys =\n\t\t\t\tselector.selectedKeys().iterator();\n\t\twhile (!stopped && selectedKeys.hasNext()) {\n\t\t\t\tSelectionKey key = selectedKeys.next();\n\t\t\t\tselectedKeys.remove();\n\n\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (key.isAcceptable()) {\n\t\t\t\t\t\tif (!doAccept()) {\n\t\t\t\t\t\t\tpauseAccept(10);\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Unexpected ops in accept select \"\n\t\t\t\t\t\t\t\t\t\t+ key.readyOps());\n\t\t\t\t}\n\t\t}\n\t} catch (IOException e) {\n\t\tLOG.warn(\"Ignoring IOException while selecting\", e);\n\t}\n}\n```\n\n```java\nprivate boolean doAccept() {\n\t\tboolean accepted = false;\n\t\tSocketChannel sc = null;\n\t\ttry {\n\t\t\t\t// 获取客户端链接\n\t\t\t\tsc = acceptSocket.accept();\n\t\t\t\taccepted = true;\n\t\t\t\tInetAddress ia = sc.socket().getInetAddress();\n\t\t\t\tint cnxncount = getClientCnxnCount(ia);\n\t\t\t\t// 判断该客户端连接数是否超过最大值\n\t\t\t\tif (maxClientCnxns > 0 && cnxncount >= maxClientCnxns){\n\t\t\t\t\t\tthrow new IOException(\"Too many connections from \" + ia\n\t\t\t\t\t\t\t\t\t\t+ \" - max is \" + maxClientCnxns );\n\t\t\t\t}\n\n\t\t\t\tLOG.info(\"Accepted socket connection from \"\n\t\t\t\t\t\t\t\t+ sc.socket().getRemoteSocketAddress());\n\t\t\t\tsc.configureBlocking(false);\n\n\t\t\t\t// Round-robin assign this connection to a selector thread\n\t\t\t\t// 选取一个 selectorThread\n\t\t\t\tif (!selectorIterator.hasNext()) {\n\t\t\t\t\t\tselectorIterator = selectorThreads.iterator();\n\t\t\t\t}\n\t\t\t\tSelectorThread selectorThread = selectorIterator.next();\n\t\t\t\t// 将接收到的链接　添加到　selector thread 的接收队列中\n\t\t\t\tif (!selectorThread.addAcceptedConnection(sc)) {\n\t\t\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\t\t\t\t\"Unable to add connection to selector queue\"\n\t\t\t\t\t\t\t\t\t\t+ (stopped ? \" (shutdown in progress)\" : \"\"));\n\t\t\t\t}\n\t\t\t\tacceptErrorLogger.flush();\n\t\t} catch (IOException e) {\n\t\t\t\t// accept, maxClientCnxns, configureBlocking\n\t\t\t\tacceptErrorLogger.rateLimitLog(\n\t\t\t\t\t\t\t\t\"Error accepting new connection: \" + e.getMessage());\n\t\t\t\tfastCloseSock(sc);\n\t\t}\n\t\treturn accepted;\n}\n```\n>  从代码中可以看出 AcceptThread 主要用来接收客户端的链接，并将就绪的客户端链接添加到 selectorThread线程对象的 acceptQueue 中\n\n###### SelectorThread\n\n```java\npublic boolean addAcceptedConnection(SocketChannel accepted) {\n\t\tif (stopped || !acceptedQueue.offer(accepted)) {\n\t\t\t\treturn false;\n\t\t}\n\t\t// 当接收到一个链接的时候, 唤醒阻塞在 selector.select(）操作上的线程\n\t\twakeupSelector();\n\t\treturn true;\n}\n```\n> 当 AcceptThread 将就绪的客户端链接添加到 selectorThread 对象的 acceptQueue 队列中的时候，同时会唤醒阻塞在 acceptQueue.poll() , selector.select() 操作的实例\n\n```java\npublic void run() {\n\t\ttry {\n\t\t\t\twhile (!stopped) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tselect();\n\t\t\t\t\t\t\t\t// 处理 acceptedQueue 队列里面的客户端链接\n\t\t\t\t\t\t\t\tprocessAcceptedConnections();\n\t\t\t\t\t\t\t\tprocessInterestOpsUpdateRequests();\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected runtime exception\", e);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected exception\", e);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Close connections still pending on the selector. Any others\n\t\t\t\t// with in-flight work, let drain out of the work queue.\n\t\t\t\tfor (SelectionKey key : selector.keys()) {\n\t\t\t\t\t\tNIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\t\t\t\t\t\tif (cnxn.isSelectable()) {\n\t\t\t\t\t\t\t\tcnxn.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t}\n\t\t\t\tSocketChannel accepted;\n\t\t\t\twhile ((accepted = acceptedQueue.poll()) != null) {\n\t\t\t\t\t\tfastCloseSock(accepted);\n\t\t\t\t}\n\t\t\t\tupdateQueue.clear();\n\t\t} finally {\n\t\t\t\tcloseSelector();\n\t\t\t\t// This will wake up the accept thread and the other selector\n\t\t\t\t// threads, and tell the worker thread pool to begin shutdown.\n\t\t\t\tNIOServerCnxnFactory.this.stop();\n\t\t\t\tLOG.info(\"selector thread exitted run method\");\n\t\t}\n}\n```\n\n```java\nprivate void select() {\n\t\ttry {\n\t\t\t\tselector.select();\n\n\t\t\t\tSet<SelectionKey> selected = selector.selectedKeys();\n\t\t\t\tArrayList<SelectionKey> selectedList =\n\t\t\t\t\t\tnew ArrayList<SelectionKey>(selected);\n\t\t\t\tCollections.shuffle(selectedList);\n\t\t\t\tIterator<SelectionKey> selectedKeys = selectedList.iterator();\n\t\t\t\twhile(!stopped && selectedKeys.hasNext()) {\n\t\t\t\t\t\tSelectionKey key = selectedKeys.next();\n\t\t\t\t\t\tselected.remove(key);\n\n\t\t\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (key.isReadable() || key.isWritable()) {\n\t\t\t\t\t\t\t\thandleIO(key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOG.warn(\"Unexpected ops in select \" + key.readyOps());\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(\"Ignoring IOException while selecting\", e);\n\t\t}\n}\n\n```\n\n```java\nprivate void handleIO(SelectionKey key) {\n\t\tIOWorkRequest workRequest = new IOWorkRequest(this, key);\n\t\tNIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\n\t\t// Stop selecting this key while processing on its\n\t\t// connection\n\t\tcnxn.disableSelectable();\n\t\tkey.interestOps(0);\n\t\ttouchCnxn(cnxn);\n\n\t\tLOG.info(\"Selector THread 开始处理　io\");\n\t\tworkerPool.schedule(workRequest);\n}\n```\n\n```java\nprivate void processAcceptedConnections() {\n\t\tSocketChannel accepted;\n\t\twhile (!stopped && (accepted = acceptedQueue.poll()) != null) {\n\t\t\t\tSelectionKey key = null;\n\t\t\t\ttry {\n\t\t\t\t\t\t// 将　acceptQueue 中的　socketChannel 注册到 selector　并监听读事件\n\t\t\t\t\t\tkey = accepted.register(selector, SelectionKey.OP_READ);\n\t\t\t\t\t\t// 新建　nioServerCnxn 并以附加信息的方式绑定到 selectkey\n\t\t\t\t\t\tNIOServerCnxn cnxn = createConnection(accepted, key, this);\n\t\t\t\t\t\tkey.attach(cnxn);\n\t\t\t\t\t\taddCnxn(cnxn);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// register, createConnection\n\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t\t\tfastCloseSock(accepted);\n\t\t\t\t}\n\t\t}\n}\n```\n\n从以上代码可以看出 selectorThread 流程如下:\n> - 轮询 selector 选择器上是否有就绪的客户端通道\n> - 当有就绪 Read 事件的客户端通道时　将该客户端派发到 wokerPool 去执行\n> - 当 acceptQueue 队列中有新接收的到客户通道的时候 将其注册到 selector 上并监听 READ 事件；同时并创建一个 NIOServerCnxn 对象绑定到 key 上（待执行 handleIO 时用到）\n\n接下来看下 wokerPool 如何处理 workRequest\n\n```java\npublic void schedule(WorkRequest workRequest, long id) {\n\t\tif (stopped) {\n\t\t\t\tworkRequest.cleanup();\n\t\t\t\treturn;\n\t\t}\n\n\t\tScheduledWorkRequest scheduledWorkRequest =\n\t\t\t\tnew ScheduledWorkRequest(workRequest);\n\n\t\t// If we have a worker thread pool, use that; otherwise, do the work\n\t\t// directly.\n\t\t// 如果　workers 数量大于 0, 则通过　ExecutorService 执行　scheduledWorkRequest；　反之直接调用　ScheduledWorkRequest\n\t\tint size = workers.size();\n\t\tif (size > 0) {\n\t\t\t\ttry {\n\t\t\t\t\t\t// make sure to map negative ids as well to [0, size-1]\n\t\t\t\t\t\tint workerNum = ((int) (id % size) + size) % size;\n\t\t\t\t\t\tExecutorService worker = workers.get(workerNum);\n\t\t\t\t\t\tworker.execute(scheduledWorkRequest);\n\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\tLOG.warn(\"ExecutorService rejected execution\", e);\n\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t}\n\t\t} else {\n\t\t\t\t// When there is no worker thread pool, do the work directly\n\t\t\t\t// and wait for its completion\n\t\t\t\tscheduledWorkRequest.start();\n\t\t\t\ttry {\n\t\t\t\t\t\tscheduledWorkRequest.join();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tLOG.warn(\"Unexpected exception\", e);\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n```java\nprivate class ScheduledWorkRequest extends ZooKeeperThread {\n\t\tprivate final WorkRequest workRequest;\n\n\t\tScheduledWorkRequest(WorkRequest workRequest) {\n\t\t\t\tsuper(\"ScheduledWorkRequest\");\n\t\t\t\tthis.workRequest = workRequest;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\t\t// Check if stopped while request was on queue\n\t\t\t\t\t\tif (stopped) {\n\t\t\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tworkRequest.doWork();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLOG.warn(\"Unexpected exception\", e);\n\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n```java\nprivate class IOWorkRequest extends WorkerService.WorkRequest {\n\t\tprivate final SelectorThread selectorThread;\n\t\tprivate final SelectionKey key;\n\t\tprivate final NIOServerCnxn cnxn;\n\n\t\tIOWorkRequest(SelectorThread selectorThread, SelectionKey key) {\n\t\t\t\tthis.selectorThread = selectorThread;\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.cnxn = (NIOServerCnxn) key.attachment();\n\t\t}\n\n\t\tpublic void doWork() throws InterruptedException {\n\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\tselectorThread.cleanupSelectionKey(key);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key.isReadable() || key.isWritable()) {\n\n\t\t\t\t\t\tLOG.info(\"IOWorker Request do work \");\n\t\t\t\t\t\tcnxn.doIO(key);\n\n\t\t\t\t\t\t// Check if we shutdown or doIO() closed this connection\n\t\t\t\t\t\tif (stopped) {\n\t\t\t\t\t\t\t\tcnxn.close();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\t\t\tselectorThread.cleanupSelectionKey(key);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttouchCnxn(cnxn);\n\t\t\t\t}\n\n\t\t\t\t// Mark this connection as once again ready for selection\n\t\t\t\tcnxn.enableSelectable();\n\t\t\t\t// Push an update request on the queue to resume selecting\n\t\t\t\t// on the current set of interest ops, which may have changed\n\t\t\t\t// as a result of the I/O operations we just performed.\n\t\t\t\tif (!selectorThread.addInterestOpsUpdateRequest(key)) {\n\t\t\t\t\t\tcnxn.close();\n\t\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t\t\tpublic void cleanup() {\n\t\t\t\t\t\tcnxn.close();\n\t\t\t\t}\n}\n```\n\n> 从上面代码可以看出在执行 IOWorkRequest 时会选择由线程池执行还是单线程执行；最终会由 NIOServerCnxn　处理客户端通道的读写事件\n\n> 综合 AcceptThread SelectorThread IOWorkRequest 可以看出 zookeeper server 的线程模型为单线程的 Reactor模型;如下图所示:\n\n![](https://i.loli.net/2019/06/21/5d0c7ddf1d29764906.png)\n> 后续相关的 IO 处理及　PrepRequestProcessor 相关的 Processor 流程会在下文分析\n","tags":["zookeeper"]},{"title":"VIM 支持 markdown 预览","url":"/2017/12/12/vim编写markdown实时预览/","content":"### 安装 vim 插件管理器 [vundle](https://github.com/VundleVim/Vundle.vim)\n\n##### 下载 vundle\n\n```\n\tgit clone https://github.com/VundleVim/Vundle.vim ~/.vim/bundle/Vundle.vim\n```\n\n##### 编辑 vim 配置文件 vimrc\n\n> 通过 apt-get install vim 安装的 vim 配置文件路径为 /etc/vim/vimrc\n\n```\n\tvim /etc/vim/vimrc\n```\n<!-- more -->\n> 将以下内容添加到 vimrc 文件中\n\n```xml\nset nocompatible    \" be iMproved, required\nfiletype off \" required\n\n\" 启用vundle来管理vim插件\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\n\" 安装插件写在这之后\n\n\" let Vundle manage Vundle, required\nPlugin 'VundleVim/Vundle.vim'\n\n\" 安装插件写在这之前\ncall vundle#end() \" required\nfiletype plugin on \n\n\" required\" 常用命令\n\" :PluginList - 查看已经安装的插件\n\" :PluginInstall - 安装插件\n\" :PluginUpdate - 更新插件\n\" :PluginSearch - 搜索插件，例如 :PluginSearch xml就能搜到xml相关的插件\n\" :PluginClean - 删除插件，把安装插件对应行删除，然后执行这个命令即可\n\n\" h: vundle - 获取帮助\n```\n\n> 进入 vim 执行 PluginInstall\n\n```\n\tsudo vim\n\n\t:PluginInstall\n```\n\n> 插件安装完成后,　左下角会出现 Done！ 至此 vundle 插件管理器安装完成.\n\n##### 安装 vim-instant-markdown 插件\n\n> 在 vim 配置文件 vimrc 文件中添加以下内容:\n\n```\n Plugin 'suan/vim-instant-markdown'\n```\n\n> 再次进入 vim 执行 PluginInstall; 当出现 Done！即表示插件安装完成.　此时 vim xx.md　即可实时预览 markdown 文件;效果如下图所示.\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4r0kb2sj31go0qijxk.jpg)\n","tags":["vim"]},{"title":"关于","url":"/about/index.html"}]