[{"title":"LeetCode-数组-删除有序数组重复元素","url":"/2019/02/26/LeetCode-数组-删除有序数组重复元素/","content":"\n## 题目描述\n\n给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n```java\n\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n\n```\n\n## 解题思路\n\n> 采用双指针方式处理。\n\n1. 初始指针 i, j 位置为 0\n2. 指针 j 先向右移动\n3. 比较指针 i,j 元素是否相同，若指针i，j元素相同则指针 j 继续向右移动；反之将指针 j 元素复制到指针 i + 1 处元素\n4. 当指针 j 移动到数组末尾时则停止\n\n\n其流程如下图所示：\n\n![](https://user-gold-cdn.xitu.io/2019/2/27/1692f54909db90f0?w=681&h=308&f=gif&s=47731)\n\n\n## 实现\n\n```java\npublic static int solution (int[] nums) {\n    int i = 0, j = 0;\n\n    while (true) {\n    \t// 指针 j 向右移动\n        j++;\n\n        // 指针 j 移动到数组末尾则退出，说明数组元素都判断了去重\n        if (j >= nums.length) {\n            break;\n        }\n\n        if (nums[j] == nums[i]) {\n        \t// 指针 i, j 元素相同，说明重复元素；\n        \t// 指针 j 继续向右移动\n            continue;\n        } else {\n        \t// 指针 i, j 元素不相同；则将指针 j 元素复制到 指针 i 后一位，这样就保证指针 i 后元素不重复\n            nums[i + 1] = nums[j];\n            // 指针 i 向右移动，继续处理\n            i++;\n        }\n    }\n\n    return i + 1;\n}\n```","tags":["leetcode"]},{"title":"LeetCode-数组-三数之和","url":"/2019/02/24/LeetCode-数组-三数之和/","content":"\n## 题目描述\n\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。 [习题原文](https://leetcode-cn.com/problems/3sum/)\n\n## 解题思路\n\n> 求三数之和为 0, nums[i] + nums[j] + nums[k] = 0 可以转换为求两个数之和，也即是 nums[i] + nums[j] = -nums[k]; 那么就可以通过指针移动去查找满足公式的数字，而为了方便控制指针的移动，前提是一组数字是有序的。\n\n那么大概的解题思路如下:\n\n* 对数组排序\n* 定义三个指针 i, left, right; 指针 i 指向的是求和项，指针 left, right 分别指向数组的头部和尾部\n* 当 -nums[i] = nums[left] + nums[right] 时满足公式，指针 left, right 继续向中部移动\n* 当 -nums[i] > nums[left] + nums[right] 时指针 left 向中部移动\n* 当 -nums[i] < nums[left] + nums[right] 时指针 righr 向中部移动\n* 当指针 left，right 交叉时停止移动，指针 i 向下移动，指针 left, right 重置\n\n其流程如下图所示:\n\n![](https://user-gold-cdn.xitu.io/2019/2/25/169233bc2f6c206c?w=813&h=400&f=gif&s=117798)\n\n## 实现\n\n```java\npublic static List<List<Integer>> solution(int[] nums) {\n    // 排序\n    Arrays.sort(nums);\n\n    List<List<Integer>> rs = new ArrayList<>();\n\n    int i = 0, left = 1, right = nums.length - 1;\n\n    while (i < nums.length - 2) {\n        while (true) {\n            // 左右指针交叉退出\n            if (right <= left) {\n                break;\n            }\n\n            if (-nums[i] == nums[left] + nums[right]) {\n                rs.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                // 过滤同一结果内重复的数字\n                // 左右指针继续向中间移动\n                while (true) {\n                    if (left >= nums.length - 1) {\n                        break;\n                    }\n\n                    if (nums[left] != nums[left + 1]) {\n                        left++;\n                        break;\n                    } else {\n                        left++;\n                    }\n                }\n\n                while (true) {\n                    if (right <= 0) {\n                        break;\n                    }\n\n                    if (nums[right] != nums[right - 1]) {\n                        right--;\n                        break;\n                    } else {\n                        right--;\n                    }\n                }\n\n                continue;\n            }\n\n            if (-nums[i] <= nums[left] + nums[right]) {\n                right--;\n                continue;\n            }\n\n            if (-nums[i] > nums[left] + nums[right]) {\n                left++;\n                continue;\n            }\n        }\n\n        // 过滤同一结果值的数字\n        while (true) {\n            if (i >= nums.length - 1) {\n                break;\n            }\n\n            if (nums[i] != nums[i + 1]) {\n                i++;\n                break;\n            } else {\n                i++;\n            }\n        }\n\n        //i++;\n        left = i + 1;\n        right = nums.length - 1;\n    }\n\n    return rs;\n}\n```\n\n\n","tags":["LeetCode"]},{"title":"Thread的中断理解","url":"/2018/12/28/Thread的中断理解/","content":"### Thread 的中断理解\n\n> 首先我们需要明确一个概念 中断并非是终止。 \n\n#### interrupt() \n\n> 线程中断方法, 调用该方法时会将线程的中断标志位标记为 true; (注意你可以理解为只是单纯的改变下标记，并不是使线程停止运行)\n\n#### isInterrupted()\n\n> 获取线程的中断标志位，也就是判断是否被中断过; true 表示被中断过\n\n#### InterruptedException\n\n> 当线程处于阻塞状态时（执行过 wait , sleep 等），此时调用线程的 interrupt() 方法，在抛出 InterruptedException 之前会将中断标志位复位, 也就是说在抛出中断异常之后在调用 isInterrupted 会返回 false 而不是 true \n\n#### interrupted()\n\n> 该方法是 Thread 的静态方法，返回当前线程是否中断过，同时对中断标志进行复位","tags":["多线程"]},{"title":"FutureTask 源码分析","url":"/2018/12/25/FutureTask/","content":"### FutureTask 源码分析\n\n> 基于 JDK 1.7 \n\n#### 成员变量\n\n```java\n\tprivate volatile int state;\n    private static final int NEW          = 0;\n    private static final int COMPLETING   = 1;\n    private static final int NORMAL       = 2;\n    private static final int EXCEPTIONAL  = 3;\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    /** The underlying callable; nulled out after running */\n    private Callable<V> callable;\n    /** The result to return or exception to throw from get() */\n    private Object outcome; // non-volatile, protected by state reads/writes\n    /** The thread running the callable; CASed during run() */\n    private volatile Thread runner;\n    /** Treiber stack of waiting threads */\n    private volatile WaitNode waiters;\n```\n\n变量 state 记录当前任务的状态，其可取值范围如下：\n\n- NEW : 任务初始状态\n- COMPLETING : 任务执行中\n- NORMAL : 任务已完成\n- CANCELLED : 任务取消\n- EXCEPTIONAL : 任务执行异常\n- INTERRUPTING : 任务中断\n- INTERRUPTED : 任务已中断\n\n状态的流转可能会有以下几种情形：\n\n* NEW -> COMPLETING -> NORMAL\n* NEW -> COMPLETING -> EXCEPTIONAL\n* NEW -> CANCELLED\n* NEW -> INTERRUPTING -> INTERRUPTED\n\n变量 callable 存储的是可执行的任务，变量 outcome 存储任务的返回值，变量 runner 指向当前执行该任务的线程，变量 waiters 执行等待链表的头节点。\n\n#### 初始化\n\n```java\n\tpublic FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n\n        this.callable = callable;\n        this.state = NEW;\n    }\n```\nFutureTask 在构造时会设置 state 为初始状态 NEW 。\n\n#### 任务的执行 - run()\n\n```java\n\tpublic void run() {\n\t\t// 只有状态 state 为 NEW， runner 为空的情况下才可以执行\n        if (state != NEW ||\n        \t// 将变量 runner 设置为当前线程，\n        \t// 此处应该是为了保证任务只允许被一个线程处理，也即只允许执行一次\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                \t// 执行 callable\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                \t// 成功执行后，设置结果值\n                    set(result);\n            }\n        } finally {        \n            runner = null;\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\n```java\n\tprotected void set(V v) {\n\t\t// 设置 state 为 COMPLETING\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        \t// 设置返回结果\n            outcome = v;\n            // 设置 state 为 NORMAL\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            // 任务完成唤醒挂起的线程\n            finishCompletion();\n        }\n    }\n```\n\n```java\n\tprivate void finishCompletion() {\n        // assert state > COMPLETING;\n        for (WaitNode q; (q = waiters) != null;) {\n        \t// 将 waiters 重置为空\n            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            \t// 采用死循环的方式唤醒挂起的线程\n                for (;;) {\n                \t// 获取等待节点关联的线程\n                    Thread t = q.thread;\n                    if (t != null) {\n                        q.thread = null;\n                        // 唤醒线程\n                        LockSupport.unpark(t);\n                    }\n\n                    // 获取等待链表的下一个节点继续唤醒\n                    WaitNode next = q.next;\n                    if (next == null)\n                    \t// 节点为空的时候 跳出循环\n                        break;\n                    q.next = null; // unlink to help gc\n                    q = next;\n                }\n                break;\n            }\n        }\n\n        done();\n\n        callable = null;        // to reduce footprint\n    }\n```\n从上述源码中可以看出 callable 只会被执行一次，执行过程如下：\n\n* 设置 runner 为当前线程\n* 回调 callable\n* 设置状态 state 为 COMPLETING \n* 设置返回结果 outcome\n* 设置状态 state 为 NORMAL\n* 唤醒等待链表 waiters 里的线程\n\n> 那么 waiters 等待链表什么时候存在等待的节点呢 ？ \n\n#### 获取任务结果 - get()\n\n```java\n\tpublic V get() throws InterruptedException, ExecutionException {\n        int s = state;\n        if (s <= COMPLETING)\n            s = awaitDone(false, 0L);\n        return report(s);\n    }\n```\n\n```java\n\tprivate int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n        // 等待时长\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        WaitNode q = null;\n        boolean queued = false;\n        // 采用死循环的方式\n        for (;;) {\n            if (Thread.interrupted()) {\n                removeWaiter(q);\n                throw new InterruptedException();\n            }\n\n            int s = state;\n            if (s > COMPLETING) {\n            \t// 此时任务已完成，可退出循环\n                if (q != null)\n                    q.thread = null;\n                return s;\n            }\n            else if (s == COMPLETING) // cannot time out yet\n                Thread.yield();\n            else if (q == null)\n            \t// 创建等待节点\n                q = new WaitNode();\n            else if (!queued)\n            \t// 若未加入等待链表时，将 q 的 next 指向 waiters , 然后将 waiters 移动到 q\n                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                     q.next = waiters, q);\n            else if (timed) {\n                nanos = deadline - System.nanoTime();\n                if (nanos <= 0L) {\n                \t// 超过等待时长 将等待节点移除\n                    removeWaiter(q);\n                    return state;\n                }\n                LockSupport.parkNanos(this, nanos);\n            }\n            else\n            \t// 挂起调用者线程\n            \t// 当任务执行完 执行 finishCompletion 是会被唤醒\n                LockSupport.park(this);\n        }\n    }\n```\n\n```java\n\tprivate V report(int s) throws ExecutionException {\n        Object x = outcome;\n        if (s == NORMAL)\n            return (V)x;\n        if (s >= CANCELLED)\n            throw new CancellationException();\n        throw new ExecutionException((Throwable)x);\n    }\n```\n\n从 get() 操作源码可以看出，当调用者线程执行 futureTask.get() 时首先判断当前 state 是否大于 COMPLETING; 若小于等于 COMPLETING 则调用 awaitDone 方法； 在 awaitDone 方法中采用轮询的方式执行以下逻辑：\n\n* 创建 WaitNode\n* 将调用者线程 WaitNode 的 next 指向 waiters， 然后将 waiters 指向调用者线程 WaitNode\n* 若需要超时等待，则将调用者线程按指定时间挂起，反之将调用者线程挂起等待任务完成唤醒\n* state > COMPLETING 任务完成退出循环\n\n结合上述分析可得 FutureTask 执行活动图如下：\n![](https://user-gold-cdn.xitu.io/2018/11/8/166f31870162c2ff?w=739&h=488&f=png&s=26103)\n\n同时也可以看出，在 FutureTask 中内部维护了一个单向链表 waiters , 在执行 get 的时候会向其中添加节点:\n![](https://user-gold-cdn.xitu.io/2018/11/8/166f3272f092cf9c?w=617&h=412&f=png&s=14063)\n\n#### 任务取消 - cancel()\n\n```java\n\t/**\n\t * mayInterruptIfRunning 是否中断执行线程\n\t */\n\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n        if (!(state == NEW &&\n              UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        \t// 只有 FutureTask 为初始状态的时候 允许取消\n            return false;\n        try {    // in case call to interrupt throws exception\n            if (mayInterruptIfRunning) {\n                try {\n                    Thread t = runner;\n                    if (t != null)\n                    \t// 中断执行线程\n                        t.interrupt();\n                } finally { // final state\n                \t// 设置状态为 INTERRUPTED\n                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n                }\n            }\n        } finally {\n        \t// 唤醒挂起的线程\n            finishCompletion();\n        }\n        return true;\n    }\n```\n\n#### 小结\n\n从上可以看出 FutureTask 可以用于当一个线程需要等待另外一个线程执行完某个任务后才能继续执行的场景下。\n","tags":["jdk","多线程"]},{"title":"DelayQueue 延迟阻塞队列使用及分析","url":"/2018/12/22/DelayQueue 延迟阻塞队列使用及分析/","content":"### 延迟阻塞队列 DelayQueue\n\n> DelayQueue 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 PriorityQueue 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。\n\n### 使用场景\n\n> 因延迟阻塞队列的特性， 我们一般将 DelayQueue 作用于以下场景 ：\n\n* 缓存系统 ： 当能够从 DelayQueue 中获取元素时，说该缓存已过期\n* 定时任务调度 ：\n\n 下面我们以缓存系统的应用，看下 DelayQueue 的使用，代码如下：\n\n```java\npublic class DelayQueueDemo {\n\n    static class Cache implements Runnable {\n\n        private boolean stop = false;\n\n        private Map<String, String> itemMap = new HashMap<>();\n\n        private DelayQueue<CacheItem> delayQueue = new DelayQueue<>();\n\n        public Cache () {\n            // 开启内部线程检测是否过期\n            new Thread(this).start();\n        }\n\n        /**\n         * 添加缓存\n         *\n         * @param key\n         * @param value\n         * @param exprieTime　过期时间,单位秒\n         */\n        public void put (String key, String value, long exprieTime) {\n            CacheItem cacheItem = new CacheItem(key, exprieTime);\n\n            // 此处忽略添加重复 key 的处理\n            delayQueue.add(cacheItem);\n            itemMap.put(key, value);\n        }\n\n        public String get (String key) {\n            return itemMap.get(key);\n        }\n\n        public void shutdown () {\n            stop = true;\n        }\n\n        @Override\n        public void run() {\n            while (!stop) {\n                CacheItem cacheItem = delayQueue.poll();\n                if (cacheItem != null) {\n                    // 元素过期, 从缓存中移除\n                    itemMap.remove(cacheItem.getKey());\n                    System.out.println(\"key : \" + cacheItem.getKey() + \" 过期并移除\");\n                }\n            }\n\n            System.out.println(\"cache stop\");\n        }\n    }\n\n    static class CacheItem implements Delayed {\n\n        private String key;\n\n        /**\n         * 过期时间(单位秒)\n         */\n        private long exprieTime;\n\n        private long currentTime;\n\n        public CacheItem(String key, long exprieTime) {\n            this.key = key;\n            this.exprieTime = exprieTime;\n            this.currentTime = System.currentTimeMillis();\n        }\n\n        @Override\n        public long getDelay(TimeUnit unit) {\n            // 计算剩余的过期时间\n            // 大于 0 说明未过期\n            return exprieTime - TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - currentTime);\n        }\n\n        @Override\n        public int compareTo(Delayed o) {\n            // 过期时间长的放置在队列尾部\n            if (this.getDelay(TimeUnit.MICROSECONDS) > o.getDelay(TimeUnit.MICROSECONDS)) {\n                return 1;\n            }\n            // 过期时间短的放置在队列头\n            if (this.getDelay(TimeUnit.MICROSECONDS) < o.getDelay(TimeUnit.MICROSECONDS)) {\n                return -1;\n            }\n\n            return 0;\n        }\n\n        public String getKey() {\n            return key;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Cache cache = new Cache();\n\n        // 添加缓存元素\n        cache.put(\"a\", \"1\", 5);\n        cache.put(\"b\", \"2\", 4);\n        cache.put(\"c\", \"3\", 3);\n\n        while (true) {\n            String a = cache.get(\"a\");\n            String b = cache.get(\"b\");\n            String c = cache.get(\"c\");\n\n            System.out.println(\"a : \" + a + \", b : \" + b + \", c : \" + c);\n\n            // 元素均过期后退出循环\n            if (StringUtils.isEmpty(a) && StringUtils.isEmpty(b) && StringUtils.isEmpty(c)) {\n                break;\n            }\n\n            TimeUnit.MILLISECONDS.sleep(1000);\n        }\n\n        cache.shutdown();\n    }\n}\n\n```\n\n执行结果如下：\n\n```java\n\na : 1, b : 2, c : 3\na : 1, b : 2, c : 3\na : 1, b : 2, c : 3\nkey : c 过期并移除\na : 1, b : 2, c : null\nkey : b 过期并移除\na : 1, b : null, c : null\nkey : a 过期并移除\na : null, b : null, c : null\ncache stop\n\n```\n\n从执行结果可以看出，因循环内部每次停顿 1 秒，当等待 3 秒后，元素 c 过期并从缓存中清除，等待 4 秒后，元素 b 过期并从缓存中清除，等待 5 秒后，元素 a 过期并从缓存中清除。\n\n### 实现原理\n\n#### 变量\n\n##### 重入锁\n\n```java\nprivate final transient ReentrantLock lock = new ReentrantLock();\n```\n用于保证队列操作的线程安全性\n\n##### 优先队列\n\n```java\nprivate final PriorityQueue<E> q = new PriorityQueue<E>();\n```\n\n存储介质，用于保证延迟低的优先执行\n\n##### leader \n\n> leader 指向的是第一个从队列获取元素阻塞等待的线程，其作用是减少其他线程不必要的等待时间。（这个地方我一直没搞明白 怎么就减少其他线程的等待时间了）\n\n##### condition\n\n```java\nprivate final Condition available = lock.newCondition();\n```\n条件对象，当新元素到达，或新线程可能需要成为leader时被通知\n\n\n下面将主要对队列的入队，出队动作进行分析 ：\n\n##### 入队 - offer\n\n```java\n    public boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            // 入队\n            q.offer(e);\n            if (q.peek() == e) {\n                // 若入队的元素位于队列头部，说明当前元素延迟最小\n                // 将 leader 置空\n                leader = null;\n                // 唤醒阻塞在等待队列的线程\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n##### 出队 - poll\n\n```java\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                E first = q.peek();\n                if (first == null)\n                \t// 等待 add 唤醒\n                    available.await();\n                else {\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0)\n                    \t// 已过期则直接返回队列头节点\n                        return q.poll();\n                    first = null; // don't retain ref while waiting\n                    if (leader != null)\n                    \t// 若 leader 不为空\n                    \t// 说明已经有其他线程调用过 take 操作\n                    \t// 当前调用线程 follower 挂起等待\n                        available.await();\n                    else {\n                    \t// 若 leader 为空\n                    \t// 将 leader 指向当前线程\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        try {\n                        \t// 当前调用线程在指定 delay 时间内挂起等待\n                            available.awaitNanos(delay);\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && q.peek() != null)\n                // leader 处理完之后，唤醒 follower\n                available.signal();\n            lock.unlock();\n        }\n    }\n```\n\n##### Leader-follower 模式\n\n![](https://user-gold-cdn.xitu.io/2017/6/28/9b634edda31c08405212e34840edc61e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n[该图引用自 CSDN 《Leader/Follower多线程网络模型介绍》](https://blog.csdn.net/goldlevi/article/details/7705180)\n\n#### 小结\n\n> 看了 DelayQueue 的实现 我们大概也明白 PriorityQueue 采用小顶堆的原因了。","tags":["jdk","多线程"]},{"title":"ThreadPoolExecutor线程池的实现分析","url":"/2018/12/20/ThreadPoolExecutor-线程池的实现分析/","content":"### ThreadPoolExecutor\n\n> 线程池在 JAVA 中是运用场景最多的并发框架，合理的运用线程池能够带来以下好处：\n\n* 降低资源消耗。\n* 提高响应速度。\n* 提高线程的可管理性\n\n#### 构造\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n参数说明：\n\n* corePoolSize ：核心线程数\n* maximumPoolSize : 最大线程数\n* keepAliveTime : 空闲线程最大存活时间\n* unit : 空闲线程存活时间单位\n* workQueue : 用于保存等待执行的任务的阻塞队列\n* threadFactory : 用于创建线程的工厂\n* RejectedExecutionHandler : 饱和策略，就是当队列和线程池满了之后，采用何种策略处理提交的新任务\n\n#### 线程池状态\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\n// 计算 线程池运行状态\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\n// 计算 工作线程数\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n// 计算 ctl 值\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n* RUNNING : 运行中，接收新的任务并且处理队列中的任务\n* SHUTDOWN : 关闭，停止接收新的任务，但是可以处理队列中的任务\n* STOP : 停止接收新的任务，也不处理队列中的任务；并中断处理中的任务\n\nThreadPoolExecutor 采用一个原子的整形变量按位存储线程池的状态和线程池的当前工作线程数。\n前 3 位为线程池状态，后 29 位为线程池工作线程数\n\n> 为什么采用高 3 位， 因为目前线程池状态值有 5 种，采用 3 位的话正好可以存储\n\n\n\n#### execute\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    // workerCountOf 获取当前工作线程数\n    // 若当前工作线程数小于核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        // 开启线程执行 command\n        // 成功执行则返回 true 退出\n        if (addWorker(command, true))\n            return;\n        // 执行失败\n        // 失败的原因 ：线程池状态变更为 SHUTDOWN 或 其他任务被提交执行导致工作线程数超过了核心线程数\n        c = ctl.get();\n    }\n    // 判断线程池状态是否为 RUNNING\n    // 将任务添加到 workQueue\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 任务被添加到 workQueue 后，再次检查线程池的运行状态\n        // 若线程池状态非 RUNNING, 则将任务从 workQueue 中移除\n        if (! isRunning(recheck) && remove(command))\n            // 按指定的饱和拒绝策略处理任务\n            reject(command);\n        // 当工作线程数为 0 的时候，则开启新的线程从 workQueue 中获取任务并执行\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 若队列满，任务无法加入队列中，则开启线程执行任务\n    else if (!addWorker(command, false))\n        // 若无法开启线程执行任务，说明当前工作线程数超过最大线程数\n        // 按指定饱和策略处理任务\n        reject(command);\n}\n```\n\n##### 创建 Worker\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 此处的判断说明当线程池状态为 SHUTDOWN 的时候，如果工作队列 workQueue 中还有任务的话，将会继续处理；反之不处理 （firstTask == null 说明不是新提交的任务， 也就是新提交的任务不予处理）\n        // 若状态大于 SHUTDOWN 也就是 STOP 时，无论工作队列中 workQueue 是否有任务都不予处理\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            // 获取工作线程数\n            int wc = workerCountOf(c);\n            // 判断当前工作线程数是否超过线程池最大容量\n            // 判断当前工作线程数是否超过核心线程数或者最大线程数\n            // 若超过则退出，也就是开启线程执行任务失败\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            // 工作线程数加一\n            if (compareAndIncrementWorkerCount(c))\n                // 退出循环\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                // 运行状态发生变化 则继续轮询\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 创建 worker 对象\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    // 添加到 workers 工作线程集合中    \n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                // 线程启动\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n如下图所示为线程池创建 Worker 流程：\n\n![](https://user-gold-cdn.xitu.io/2018/12/25/167e466500acfb5c?w=692&h=1221&f=png&s=95611)\n\n> 从 addWorker 的实现可以看出，当线程池状态为 SHUTDOWN, STOP 时，将不会在接收新的任务\n\n##### Worker 执行\n\n> 接下来我们看下 Worker 的构建\n\n```java\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    // 创建线程\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n\n从 Worker 的构建可以看出，当线程启动时，实际上执行的是 Worker 的 run 方法。\n\n```java\npublic void run() {\n    runWorker(this);\n}\n```\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 若能够获取一个待执行的任务\n        // 也即是 firstTask 不为空或者 workQueue 工作队列中有待执行的任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    // 任务执行\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                // 当前 worker 完成的任务数加一\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n    }\n```\n\n> 接下来我们看下如何从 workQueue 中获取待执行的任务\n\n```java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 线程池状态为 SHUTDOWN 并且 workQueue 为空的时候返回 null\n        // 线程池状态为 STOP 返回 null\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        // 获取当前工作线程数\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        // allowCoreThreadTimeOut 该变量是指是否允许核心线程在指定存活时间内未获取到任务后回收;\n        // wc > corePoolSize 说明超过核心线程数的线程将会被回收\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n        // 工作线程数超过最大线程数 可销毁\n        // 工作线程数超过核心线程数且上次等待获取任务超时 可销毁\n        // 若工作线程数等于 1 且 workQueue 队列为空的时候 可销毁\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            // 工作线程数减一\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            // 从队列获取任务\n            // 若 timed 为 true, 则当前 worker 在指定的 keepAliveTime 时间内等待获取任务；若为空，那么 worker 在下次轮询的时候满足条件下将会退出被回收\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n如下图所示为 worker 获取任务及执行任务的流程：\n\n![](https://user-gold-cdn.xitu.io/2018/12/25/167e51ad3aa43d27?w=977&h=606&f=png&s=81057)\n\n从 getTask 的实现可以看出在以下情况下将对 worker 执行退出销毁\n\n* 线程池状态为 STOP\n* 线程池状态为 SHUTDOWN, 且 workQueue 队列为空\n* 线程池工作线程数超过最大线程数\n* 线程池工作线程数大于 1，且允许核心线程回收（allowCoreThreadTimeOut = true）同时 worker 上次从队列获取任务时 timeout\n* 线程池工作线程数大于核心线程数并大于 1，同时 worker 上次从队列获取任务时 timeout\n* 线程池工作线程数等于 1 且 workQueue 为空\n\n> 个人理解 ：当 workQueue 不为空的时候，线程池最少会保留一个 worker 去执行任务\n\n接下来看下当 worker 退出后的逻辑 :\n\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // completedAbruptly 表示 worker 是否正常退出； true 说明用户任务处理过程中出现异常，false 是正常退出 \n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        // 若是异常退出的话，执行工作线程数减一\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        // 累加完成的任务数\n        completedTaskCount += w.completedTasks;\n        // 将 worker 从工作线程集合 workers 中移除\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    // 尝试终止线程池\n    tryTerminate();\n\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            // 计算线程池允许的最小线程数\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                // 若 min = 0，而 workQueue 不为空的话，说明有待处理的任务，则 min = 1，也就是至少有 1 个工作线程\n                min = 1;\n            // 若当前工作线程数 >= min, 则退出；反之创建新的 worker\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        // worker 非正常退出的话，重新创建新的 worker\n        addWorker(null, false);\n    }\n}\n```\n\n#### shutdown\n\n> 关闭线程池，运行状态改为 SHUTDOWN; 并中断空闲的工作线程\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 线程池状态修改为 SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        // 中断空闲 worker\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试终止线程池\n    tryTerminate();\n}\n```\n\n```java\nprivate void advanceRunState(int targetState) {\n    for (;;) {\n        int c = ctl.get();\n        // 当前状态值 小于 SHUTDOWN 的时候，执行更新\n        if (runStateAtLeast(c, targetState) ||\n            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))\n            break;\n    }\n}\n```\n\n```java\nprivate void interruptIdleWorkers() {\n    interruptIdleWorkers(false);\n}\n\n\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            if (!t.isInterrupted() && w.tryLock()) {\n                // worker 对应的线程未被中断过，且能够获取到锁，说明线程空闲（因为 worker 在获取到任务执行的时候，会 lock）\n                try {\n                    // 执行中断\n                    // 此时会唤醒阻塞在 workQueue.take 或 poll 操作上的 worker; 当 worker 在 getTask 继续轮询的时候会退出\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n```java\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        // 线程池状态为 STOP\n        // 线程池状态为 SHUTDOWN 且 workQueue 为空的时候可终止\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))\n            return;\n        // 工作线程数等于 0 的时候可终止\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            // 将工作线线程数改为 0，运行状态改为 TIDYING\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    // 执行终止操作，由子类实现\n                    terminated();\n                } finally {\n                    // 将运行状态改为 TERMINATED\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        // else retry on failed CAS\n    }\n    }\n```\n\n#### shutdownNow\n\n> 关闭线程池，运行状态修改为 STOP, 中断所有线程； 并返回未处理的任务\n\n```java\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 将线程池状态改为 STOP\n        advanceRunState(STOP);\n        // 中断所有的 Worder\n        interruptWorkers();\n        // 清除任务队列，并返回任务列表\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n```\n\n```java\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        // 将所有 worker 执行中断\n        for (Worker w : workers)\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n> 对于线程池的关闭操作 tryTerminate() 方法中的一段逻辑需要重点说明下，如下 \n```java\nif (workerCountOf(c) != 0) { // Eligible to terminate\n    interruptIdleWorkers(ONLY_ONE);\n    return;\n}\n```\n> interruptIdleWorkers(ONLY_ONE)是什么意思呢？中断闲置的Worker，直到回收全部的Worker。这里没有那么暴力，只中断一个，中断之后退出方法，中断了Worker之后，Worker会回收，然后还是会调用tryTerminate方法，如果还有闲置线程，那么继续中断\n\n> 譬如有个场景 ： 线程池在执行 shutdown 操作后，假设工作线程 A, B 还在执行任务，此时假设 workQueue 队列中还有一个任务； 当 A, B 分别在继续执行 getTask 时，有可能 A 先获取到任务，B 被阻塞到 workQueue.task() 操作上，如果不进行 interruptIdleWorkers(ONLY_ONE) 处理，那么工作线程 B 将一直存活而无法回收。\n\n\n","tags":["jdk","多线程"]},{"title":"Semaphore-源码分析","url":"/2018/12/15/Semaphore-的实现分析/","content":"## Semaphore\n\n> Semaphore 信号量：可以用来控制同时访问特定资源的线程数量；通过协调各个线程以保证合理的使用公共资源。\n\n### 构造\n\n```java\n// permits 设置许可证的数量\npublic Semaphore(int permits) {\n    // 默认非公平\n    sync = new NonfairSync(permits);\n}\n// permits 设置许可数量\n// fair 设置是否采用公平模式\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n```\n### 非公平模式\n\n#### acquire()\n\n> 获取许可。只有当获取到可用的许可，或者当前线程被中断；否则该线程被阻塞\n\n```java\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n```\n默认会调用 NonfairSync 下的 tryAcquireShared 方法，继续调用父类的 nonfairTryAcquireShared 方法\n\n```java\nprotected int tryAcquireShared(int acquires) {\n    return nonfairTryAcquireShared(acquires);\n}\n```\n```java\nfinal int nonfairTryAcquireShared(int acquires) {\n    for (;;) {\n        // 获取当前 state 值\n        // 也即是当前可用的许可数\n        int available = getState();\n        // 当前可用许可数减去尝试获取许可的数\n        // 得到剩余许可数\n        int remaining = available - acquires;\n        // remaining < 0 说明当前可用许可数小于尝试获取许可数，也即是获取同步状态失败 直接返回 remaining, 退出循环 当前线程会被添加到同步队列中\n        // remaining > 0 说明当前可用许可数大于尝试获取许可数，\n        // 则执行 compareAndSetState 更新 state , 若更新成功则返回 退出循环 当前线程获取到许可\n        // 若 compareAndSetState 更新失败，说明有其他线程获取到许可，则继续轮询\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n\n#### release\n\n> 释放许可\n\n```java\npublic void release() {\n    sync.releaseShared(1);\n}\n```\n\n```java\nprotected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n        // 获取当前许可数\n        int current = getState();\n        // 当前许可 + 释放的许可数\n        int next = current + releases;\n        if (next < current) // overflow\n            throw new Error(\"Maximum permit count exceeded\");\n        // 更新 state 值, 更新成功则返回 true 退出循环；并唤醒同步队列上阻塞的线程\n        // 更新 state 值失败，说明有其他线程获取许可或释放了许可，则继续轮询\n        if (compareAndSetState(current, next))\n            return true;\n    }\n}\n```\n\n### 公平模式\n\n#### acquire\n\n> 公平模式下获取许可\n\n```java\nprotected int tryAcquireShared(int acquires) {\n    for (;;) {\n        // 判断同步队列上是否有阻塞的线程\n        // 若有的话，返回 -1 表示获取许可失败 退出循环加入同步队列中\n        if (hasQueuedPredecessors())\n            return -1;\n        int available = getState();\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n\n从上述代码中可以看到，公平模式下获取许可和非公平模式下基本类似，只是为了保证 FIFO ，添加了 hasQueuedPredecessors 判断限制。\n\n#### release\n\n> 公平模式下与非公平模式一样\n\n### 小结\n\nSemaphore 可以用来实现限流的作用。\n","tags":["jdk","多线程"]},{"title":"ReentrantReadWriteLock-读写锁源码分析","url":"/2018/12/13/ReentrantReadWriteLock-读写锁/","content":"### ReentrantReadWriteLock 读写锁\n\n> 读写锁不同于 ReentrantLock ，ReentrantLock 是排他锁同一时刻只允许一个线程访问，而读写锁同一时刻允许多个读线程访问，但是在写线程操作时，所有的读写操作均被阻塞。\n\n#### 读写状态实现\n\n> 如何通过一个 int 值记录读状态，写状态呢 ?\n\n在 ReentrantReadWriteLock 中通过对同步状态值进行“按位切割”，因为 int 占 32 位 bit，故一分为二，采用高 16 位表示读状态，低 16 位表示写状态。\n\n##### 如何获取写状态值\n\n我们假设同步状态值转换为二进制如下：\n\n```java\n0000 0000 0000 0010 | 0000 0000 0000 0101\n```\n\n> 上述同步状态值表示：读状态为 2， 写状态为 5\n\n那么我们如何获取状态值呢 ？ 我们思考下位的相关运算 ：\n\n* 位与操作(&) 两个数同为 1 则为 1， 否则为 0\n* 位或操作(|) 两个数有一个为 1 则为 1， 否则为 0\n\n了解了 & ，| 运算规律我们是不是可以这样操作呢，将同步状态值与如下二进制进行 & 运算\n\n```java\n0000 0000 0000 0000 | 1111 1111 1111 1111\n```\n\n结果可得\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0101\n```\n\n也就是写状态的二进制表示，值为 5. 那么\n\n```java\n0000 0000 0000 0000 | 1111 1111 1111 1111\n```\n\n该位与操作数转成十进制也即是 65535 (2^15 + 2^14 + ..... + 2^0)，由`等比数列`可知等于 2^16 - 1, 也等于 (1 << 16) - 1 。 这也是 ReentrantReadWriteLock 内部定义的常量实现 ：\n\n```java\nstatic final int SHARED_SHIFT   = 16;\nstatic final int SHARED_UNIT    = (1 << SHARED_SHIFT);\nstatic final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\nstatic final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n```\n\n![](https://user-gold-cdn.xitu.io/2018/12/3/16773eaff78b68e6?w=1056&h=414&f=png&s=15413)\n\n##### 如何获取读状态值\n\n获取读状态相比写状态来说就比较简单了，只需同步状态值 >> 右移 16 位即可\n\n![](https://user-gold-cdn.xitu.io/2018/12/3/167740000b4b1232?w=1052&h=257&f=png&s=14294)\n\n##### 写状态值加一\n\n当写锁重入的时候，如何更新写状态值呢 ? 我们知道状态值的低 16 位表示写状态，那么每次写状态加一操作相当于下面二进制相加操作（逢二进一）\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0011\n```\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0001\n```\n\n相加可得\n\n```java\n0000 0000 0000 0000 | 0000 0000 0000 0100\n```\n\n也就是写状态值由 3 加一变成 4；那么对于写状态增加一时，也就是同步状态值 `S + 1` 即可。\n\n##### 读状态值加一\n\n读状态增加一，与写状态一样；只不过因为是高 16 位表示读状态，故是同步状态 `S + (1 << 16)`.\n\n#### 构造\n\n```java\npublic ReentrantReadWriteLock() {\n    this(false);\n}\n\npublic ReentrantReadWriteLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n    readerLock = new ReadLock(this);\n    writerLock = new WriteLock(this);\n}\n```\n#### writerLock() - 写锁\n\n```java\npublic ReentrantReadWriteLock.WriteLock writeLock() {\n  return writerLock;\n}\n```\n##### 获取锁\n\n当执行 writeLock.lock() 的时候，实际上调用的是 sync.acquire(), 如下：\n\n```java\npublic void lock() {\n    // 写锁是独占模式\n    sync.acquire(1);\n}\n```\n下面我们看下 sync 的 tryAcquire 实现如下：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n      /*\n       * Walkthrough:\n       * 1. If read count nonzero or write count nonzero\n       *    and owner is a different thread, fail.\n       * 2. If count would saturate, fail. (This can only\n       *    happen if count is already nonzero.)\n       * 3. Otherwise, this thread is eligible for lock if\n       *    it is either a reentrant acquire or\n       *    queue policy allows it. If so, update state\n       *    and set owner.\n       */\n      Thread current = Thread.currentThread();\n      // 获取同步状态值\n      int c = getState();\n      // 获取写状态值\n      int w = exclusiveCount(c);\n      if (c != 0) {\n          // (Note: if c != 0 and w == 0 then shared count != 0)\n          // c != 0 说明此时已经有读或有写或有读写\n          // 若 w == 0 说明此时有读操作，则获取写锁失败\n          // 若 w != 0 说明此时已经有写操作\n          // 若 current != getExclusiveOwnerThread() 说明当前获取写锁的线程并非是写锁对象的持有者, 则重入失败\n          if (w == 0 || current != getExclusiveOwnerThread())\n              return false;\n          // 重入次数超过最大值 抛出异常\n          if (w + exclusiveCount(acquires) > MAX_COUNT)\n              throw new Error(\"Maximum lock count exceeded\");\n          // Reentrant acquire\n          // 设置状态值\n          setState(c + acquires);\n          return true;\n      }\n      if (writerShouldBlock() ||\n          !compareAndSetState(c, c + acquires))\n          return false;\n      // 设置当前线程为写锁的持有者\n      setExclusiveOwnerThread(current);\n      return true;\n  }\n```\n从代码的实现及注释中所描述的内容，可得知以下场景会获取写锁失败 :\n\n* 当前已经有读操作，则获取写锁失败\n* 当前已经有写操作，但当前线程并非写锁对象的持有者，则获取写锁失败（也是重入失败）\n* 当前没有任何操作，CAS 更新状态值失败，则获取写锁失败\n\n##### 释放锁\n\n```java\nprotected final boolean tryRelease(int releases) {\n    // 判断当前线程是否为写锁对象的持有者\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    // 同步状态值释放\n    int nextc = getState() - releases;\n    // 判断写状态是否为 0; 写状态为 0 说明写锁完成释放\n    boolean free = exclusiveCount(nextc) == 0;\n    if (free)\n        // 清空写锁的持有者\n        setExclusiveOwnerThread(null);\n    setState(nextc);\n    return free;\n}\n```\n\n#### readLock() - 读锁\n\n```java\npublic ReentrantReadWriteLock.ReadLock  readLock()  {\n  return readerLock;\n}\n```\n\n##### 获取锁\n\n```java\npublic void lock() {\n    sync.acquireShared(1);\n}\n```\n\n> 因为读写锁是支持同时多个线程获取读锁，所以调用的是 sync 共享式获取同步状态。 这里针对读锁的获取和释放我们简化下实现忽略对读锁计数统计的操作。\n\n```java\nprotected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n   \n    for (;;) {\n        // 获取读状态值\n        int c = getState();\n        // exclusiveCount(c) != 0 说明有写操作\n        // getExclusiveOwnerThread != current 说明当前线程非写锁的对象持有者; 则获取读锁失败\n        // 若 getExclusiveOwnerThread == current 也就是说明线程获取写锁之后是可以继续获取读锁的\n        if (exclusiveCount(c) != 0) {\n            if (getExclusiveOwnerThread() != current)\n                return -1;\n            // else we hold the exclusive lock; blocking here\n            // would cause deadlock.\n        }\n        if (sharedCount(c) == MAX_COUNT)\n            throw new Error(\"Maximum lock count exceeded\");\n        if (compareAndSetState(c, c + SHARED_UNIT)) {\n            // 忽略读锁计数统计的操作 \n            return 1;\n        }\n    }\n}\n```\n\n##### 释放锁\n\n```java\nprotected final boolean tryReleaseShared(int unused) {\n    Thread current = Thread.currentThread();\n    // 忽略读锁计数统计的操作 \n    for (;;) {\n        int c = getState();\n        int nextc = c - SHARED_UNIT;\n        if (compareAndSetState(c, nextc))\n            // Releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            return nextc == 0;\n    }\n}\n```\n\n#### 小结\n\n* 读写锁的实现关键在于如何通过一个 int 值，分别记录读写状态。（采用按位切割，高 16 位为读状态，低 16 位状态）\n* 何时可以获取读锁 ?  获取写锁的线程可以再次获取读锁，获取读锁的线程数未超过 2^16 - 1 时是可以获取读锁。\n* 何时可以获取写锁 ?  已经有读锁在操作则不可用获取写锁\n\n","tags":["jdk","多线程"]},{"title":"ReentrantLock-重入锁源码分析","url":"/2018/12/11/ReentrantLock-重入锁源码分析/","content":"### ReentrantLock\n\n> 重入锁, 表示该锁支持一个线程对资源的重复加锁\n\n#### 类结构\n\n首先让我们先看下 ReentrantLock 的类结构如下图所示：\n\n![](https://user-gold-cdn.xitu.io/2018/12/1/167682dbefa75073?w=303&h=322&f=png&s=14572)\n\n从图中我们可以看出 ReentrantLock 实现 Lock 接口，同时内部类 Sync 是 AQS 的子类；而 Sync 又有两个子类 NonfairSync 和 FairSync 分别对应非公平和公平锁两种策略。\n\n#### 构造\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n```\n```java\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n> ReentrantLock 默认采用非公平的策略，也可以在构造的时候指定是否公平的策略。\n\n#### 非公平锁\n\n> 非公平锁是指在竞争获取锁的过程中，有可能后来者居上\n\n##### lock() 获取锁\n\n```java\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n\n    /**\n     * Performs lock.  Try immediate barge, backing up to normal\n     * acquire on failure.\n     */\n    final void lock() {\n    \t// CAS 设置 state 值为 1\n        if (compareAndSetState(0, 1))\n        \t// CAS 成功则说明获取到锁, 此时将当前线程设置为独占模式下锁对象的持有者\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n        \t// CAS 失败\n        \t// 可能是同一线程再次获取锁\n        \t// 也可能是不同线程获取锁\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n    \t// 调用父类 sync\n        return nonfairTryAcquire(acquires);\n    }\n}\n```\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n      // 此时说明已有线程释放了锁\n      // 有可能是同步队列里阻塞的线程被唤醒时尝试获取锁\n        if (compareAndSetState(0, acquires)) {\n        \t// CAS 成功则说明获取到锁, 此时将当前线程设置为独占模式下锁对象的持有者\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n    \t// 说明同一线程再次获取锁\n    \t// state 加 1\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n获取锁的过程如下 ：\n\n* 通过 CAS 操作， 设置 state = 1\n* 若 CAS 操作成功，则将当前线程设置为独占模式锁对象的持有者\n* 若 CAS 操作失败, 最终会调用 sync 的方法 nonfairTryAcquire; 此时说明可能是同一线程再次尝试获取锁，也有可能是其他线程尝试获取锁\n* 若当前 state == 0, 继续执行前两步操作\n* 若当前 state != 0, 则判断当前线程是否为锁的持有者；若判断成立，则对 state + 1\n\n##### unlock() - 释放锁\n\n> 非公平锁的释放调用的是父类 sync 的 tryRelease 方法\n\n```java\nprotected final boolean tryRelease(int releases) {\n    // state 减一操作\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        // 当前线程不是当前锁的持有者时抛出异常\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        // 只有 state == 0 时 才是真正完成锁的释放\n        free = true;\n        // 将锁的持有者清空\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n从释放锁的实现可以看出，获取锁与释放锁的操作是对等的，譬如下方伪代码：\n\n```java\nReentrantLock lock = new ReentrantLock();\n\npublic void do () {\n  lock.lock();\n\n  try {\n\n    do();\n    // 退出递归\n\n  } finally {\n    lock.unlock();\n  }\n}\n\n```\n\n#### 公平锁\n\n> 公平锁是指获取锁的顺序完全符合请求时间的顺序，也就是先到先得\n\n##### lock() - 获取锁\n\n接下来我们下公平锁与非公平锁在获取锁时有什么不同\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        // 不同于非公平锁操作，公平锁多了个判断条件 hasQueuedPredecessors\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n```java\npublic final boolean hasQueuedPredecessors() {\n    // The correctness of this depends on head being initialized\n    // before tail and on head.next being accurate if the current\n    // thread is first in queue.\n    Node t = tail; // Read fields in reverse initialization order\n    Node h = head;\n    Node s;\n    // h != t 说明同步队列已有等待的节点\n    // s = h.next == null 这个有点没明白; head 的后置为空应该就是 head == tail 吧\n    // s.thread != Thread.currentThread 是判断当前线程是不是同步队列的首个阻塞线程 如果是是允许获取到锁的\n    return h != t &&\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n```\n\n```\nQueries whether any threads have been waiting to acquire longer than the current thread.\n```\n\nhasQueuedPredecessors 方法主要实现的是查找是否有等待时间超过当前线程的其他线程, 公平锁也就是通过该方法保证获取锁的有序性。\n\n##### unlock() - 释放锁\n\n公平锁的释放与非公平锁的释放操作一致\n\n#### 小结\n\n- ReentrantLock 如何实现可重入 ? (通过判断当前线程是否为当前锁对象的持有者)\n- 如何实现公平锁 ? (若当前同步队列中有等待的节点则获取锁失败)\n- 非公平锁和公平锁对性能有什么影响 ? (公平锁会造成大量的线程切换，非公平锁会出现线程“饥饿”现象，但线程切换少提高吞吐量)\n","tags":["jdk","多线程"]},{"title":"CyclicBarrier 同步屏障的源码分析","url":"/2018/12/09/CyclicBarrier-同步屏障的实现分析/","content":"### CyclicBarrier\n\n> CyclicBarrier 是可循环使用的屏障，主要功能是让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开；所有被屏障拦截的线程才会继续执行。\n\n#### 使用示例\n\n```java\npublic class CyclicBarrierTest {\n\n    // 线程个数\n    private int parties = 3;\n\n    private AtomicInteger atomicInteger = new AtomicInteger(parties);\n\n    private CyclicBarrier cyclicBarrier;\n\n    class Protector implements Runnable {\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(Thread.currentThread().getName() + \" - 到达屏障前\");\n\n                TimeUnit.SECONDS.sleep(2);\n\n                cyclicBarrier.await();\n\n                atomicInteger.decrementAndGet();\n\n                System.out.println(Thread.currentThread().getName() + \" - 到达屏障后\");\n\n            } catch (InterruptedException e) {\n                System.out.println(Thread.currentThread().getName() + \" - 等待中断\");\n            } catch (BrokenBarrierException e) {\n                System.out.println(Thread.currentThread().getName() + \" - 屏障被破坏\");\n            }\n        }\n    }\n\n\n    @Before\n    public void init() {\n        cyclicBarrier = new CyclicBarrier(parties);\n    }\n\n    @Test\n    public void allAwait() {\n        for (int i = 0; i < parties; i++) {\n            new Thread(new Protector(), \"Thread-\" + i).start();\n        }\n\n        while (true) {\n            if (atomicInteger.get() == 0) {\n                // 所有线程到达屏障后退出结束\n                System.out.println(\"test over\");\n                break;\n            }\n        }\n    }\n\n    @Test\n    public void oneAwaitInterrupted() throws InterruptedException {\n        Thread threadA = new Thread(new Protector(), \"Thread-A\");\n        Thread threadB = new Thread(new Protector(), \"Thread-B\");\n\n        threadA.start();\n        threadB.start();\n        // 等待 3 秒，避免是 time sleep 触发中断异常\n        TimeUnit.SECONDS.sleep(3);\n\n        threadA.interrupt();\n\n        while (true) {\n            if (atomicInteger.get() == 0) {\n                System.out.println(\"test over\");\n                break;\n            }\n            if (cyclicBarrier.isBroken()) {\n                System.out.println(\"屏障中断退出\");\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\nThread-A - 到达屏障前\nThread-B - 到达屏障前\n屏障中断退出\nThread-A - 等待中断\nThread-B - 屏障被破坏\n\nThread-0 - 到达屏障前\nThread-1 - 到达屏障前\nThread-2 - 到达屏障前\nThread-2 - 到达屏障后\nThread-0 - 到达屏障后\nThread-1 - 到达屏障后\ntest over\n```\n从 oneAwaitInterrupted 方法执行结果可以看出，当一个线程 A 执行中断时，另外一个线程 B 会抛出 BrokenBarrierException\n\n#### 构造\n\n```java\n// 可以指定拦截线程个数\npublic CyclicBarrier(int parties) {\n    this(parties, null);\n}\n\n// 指定拦截线程个数和所有线程到达屏障处后执行的动作\npublic CyclicBarrier(int parties, Runnable barrierAction) {\n    if (parties <= 0) throw new IllegalArgumentException();\n    this.parties = parties;\n    this.count = parties;\n    this.barrierCommand = barrierAction;\n}\n```\n\n#### 实现\n\n##### 概念\n\n* barrier : 屏障\n* parties : 为屏障拦截的线程数\n* tripped : 跳闸，可以理解为打开屏障\n* generation.broken : 屏障是否破损，当屏障被打开或被重置的时候会改变值\n\n> 简单的理解就是，当线程都到达屏障的时候，会打开屏障。\n\n##### await()\n\n> await 说明线程到达屏障\n\n```java\npublic int await() throws InterruptedException, BrokenBarrierException {\n    try {\n        return dowait(false, 0L);\n    } catch (TimeoutException toe) {\n        throw new Error(toe); // cannot happen\n    }\n}\n```\n\n```java\nprivate int dowait(boolean timed, long nanos)\n        throws InterruptedException, BrokenBarrierException,\n               TimeoutException {\n    final ReentrantLock lock = this.lock;\n    // 获取排他锁\n    lock.lock();\n    try {\n        final Generation g = generation;\n        // 屏障被破坏则抛异常\n        if (g.broken)\n            throw new BrokenBarrierException();\n\n        if (Thread.interrupted()) {\n        \t// 线程中断 则退出屏障\n            breakBarrier();\n            throw new InterruptedException();\n        }\n\n        // 到达屏障的计数减一\n        int index = --count;      \n        if (index == 0) {  // tripped\n        \t// index == 0, 说明指定 count 的线程均到达屏障\n        \t// 此时可以打开屏障\n            boolean ranAction = false;\n            try {\n                final Runnable command = barrierCommand;\n                if (command != null)\n                \t// 若指定了 barrierCommand 则执行\n                    command.run();\n                ranAction = true;\n                // 唤醒阻塞在屏障的线程并重置 generation\n                nextGeneration();\n                return 0;\n            } finally {\n                if (!ranAction)\n                    breakBarrier();\n            }\n        }\n\n        // loop until tripped, broken, interrupted, or timed out\n        for (;;) {\n            try {\n                if (!timed)\n                \t// 若未指定阻塞在屏障处的等待时间，则一直等待；直至最后一个线程到达屏障处的时候被唤醒\n                    trip.await();\n                else if (nanos > 0L)\n                \t// 若指定了阻塞在屏障处的等待时间，则在指定时间到达时会返回\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) {\n                if (g == generation && ! g.broken) {\n                \t// 若等待过程中，线程发生了中断，则退出屏障\n                    breakBarrier();\n                    throw ie;\n                } else {\n                    // We're about to finish waiting even if we had not\n                    // been interrupted, so this interrupt is deemed to\n                    // \"belong\" to subsequent execution.\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            // 屏障被破坏 则抛出异常\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            if (g != generation)\n            \t// g != generation 说明所有线程均到达屏障处 可直接返回\n            \t// 因为所有线程到达屏障处的时候，会重置 generation\n            \t// 参考 nextGeneration\n                return index;\n\n            if (timed && nanos <= 0L) {\n            \t// 说明指定时间内，还有线程未到达屏障处，也就是等待超时\n            \t// 退出屏障\n                breakBarrier();\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n```java\nprivate void nextGeneration() {\n    // signal completion of last generation\n    // 唤醒阻塞在等待队列的线程\n    trip.signalAll();\n    // set up next generation\n    // 重置 count\n    count = parties;\n    // 重置 generation\n    generation = new Generation();\n}\n```\n\n```java\nprivate void breakBarrier() {\n\t// broken 设置为 true\n    generation.broken = true;\n    // 重置 count\n    count = parties;\n    // 唤醒等待队列的线程\n    trip.signalAll();\n}\n```\n\n如下图为 CyclicBarrier 实现效果图：\n\n![](https://user-gold-cdn.xitu.io/2018/12/20/167caa9c9ceb36f5?w=624&h=364&f=gif&s=95895)\n\n##### isBroken()\n\n> 返回屏障是否被破坏，也是是否被中断\n\n```java\npublic boolean isBroken() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        return generation.broken;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n##### reset()\n\n```java\npublic void reset() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 唤醒阻塞的线程\n        breakBarrier();   // break the current generation\n        // 重新设置 generation\n        nextGeneration(); // start a new generation\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n##### getNumberWaiting\n\n> 获取阻塞在屏障处的线程数\n\n```java\npublic int getNumberWaiting() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 拦截线程数 - 未到达屏障数\n        return parties - count;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n#### 小结\n\nCyclicBarrier 和 CountDownLatch 功能类似，不同之处在于 CyclicBarrier 支持重复利用，而 CountDownLatch 计数只能使用一次。\n","tags":["jdk","多线程"]},{"title":"CountDownLatch-源码分析","url":"/2018/12/07/CountDownLatch实现分析/","content":"### CountDownLatch\n\n> CountdownLatch 是 JDK 并发包中提供的并发工具类，其允许一个或多个线程等待其他线程完成操作。常用作将一个任务拆分成多个子任务同时执行，只有子任务都执行完毕主线程才往下执行。\n\n#### 使用示例\n\n```java\npublic class App implements Runnable\n{\n    private CountDownLatch countDownLatch;\n\n    public App (CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    public static void main( String[] args )\n    {\n    \t// 指定同时运行3个子任务\n        int count = 3;\n\n        CountDownLatch countDownLatch = new CountDownLatch(count);\n\n        for (int i = 0; i < count; i++) {\n            new Thread(new App(countDownLatch), \"Thread-\" + i).start();\n        }\n\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n        }\n\n        System.out.println(\"count down over !\");\n    }\n\n    @Override\n    public void run() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n\n            System.out.println(Thread.currentThread().getName() + \" - 执行完毕.\" );\n\n        } catch (InterruptedException e) {\n        } finally {\n            countDownLatch.countDown();\n        }\n    }\n}\n\n```\n运行结果如下：\n\n```java\nThread-2 - 执行完毕.\nThread-0 - 执行完毕.\nThread-1 - 执行完毕.\ncount down over !\n```\n从结果中可以看出 main 主线程会在 3 个子线程处理完毕之后才继续执行。\n\n#### 构造\n\n```java\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n```\n\nCountDownLatch 与其他同步组件一样，内部类 Sync 继承了 AQS，构造的时候会指定子任务个数 count , 也即是同步状态初始值。\n\n#### await()\n\n```java\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n```\n\n接下来看下 sync 获取共享同步状态的实现\n\n```java\nprotected int tryAcquireShared(int acquires) {\n\t// state == 0 的时候返回 1，反之返回 -1\n\t// state != 0 说明还有子任务未处理完\n    return (getState() == 0) ? 1 : -1;\n}\n```\n\n从实现可以看出 await() 方法执行时，当子任务未处理完毕时(state ！= 0)，调用线程会被添加到同步队列而阻塞等待。\n\n#### countDown()\n\n```java\npublic void countDown() {\n    sync.releaseShared(1);\n}\n```\n\n接下来看下 sync 的共享同步状态值释放\n\n```java\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    for (;;) {\n        int c = getState();\n        if (c == 0)\n            return false;\n        // 每次释放的时候，也就是子任务完成的时候计数值减一\n        int nextc = c-1;\n        // 更新 state 值\n        if (compareAndSetState(c, nextc))\n        \t// 子任务均处理完毕后，返回 true； 也就是真正的释放\n        \t// 将唤醒阻塞在同步队列的线程\n            return nextc == 0;\n    }\n}\n```\n\n从实现可以看出，每次子任务在调用 countDown 时，会将同步状态值减一，当所有子任务均完成时 (state = 0) 此时会唤醒阻塞在同步队列的节点。\n\n#### 小结\n\n子任务在进行 countDown 操作时，最好是在 finally 块处理； 避免出现子任务处理异常，导致主线程一直阻塞的问题。\n","tags":["jdk","多线程"]},{"title":"AQS 之 Condition-的源码分析","url":"/2018/12/05/AQS 之 Condition/","content":"\n> 在使用 Lock 锁的过程中，我们往往会使用到另外一个对象 Condition ，用于等待/通知模式的处理。\n\n#### Condition 的创建\n\n```java\n\tLock lock = new ReentrantLock();\n\tCondition condition = lock.newCondition();\n```\n\n使用 Condition 的前提是获取锁\n\n```java\nfinal ConditionObject newCondition() {\n    return new ConditionObject();\n}\n```\n\n从 newCondition 方法看出 Condition 对象实际上是 AQS 的内部类 ConditionObject ()。\n\n#### 成员变量\n\n```java\n/** First node of condition queue. */\nprivate transient Node firstWaiter;\n/** Last node of condition queue. */\nprivate transient Node lastWaiter;\n```\n\n从内部定义的变量 firstWaiter, lastWaiter 看出， ConditionObject 对象内部维护了一个同样以 Node 为节点的等待队列。\n\n#### await()\n\n> await 操作会使当前线程释放锁并进入等待模式。\n\n```java\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n    \t// 当前线程中断 抛出中断异常\n        throw new InterruptedException();\n    // 将当前线程构造节点插入等待队列尾部\n    Node node = addConditionWaiter();\n    // 当前线程释放锁，唤醒同步队列 head 的后置节点\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 节点添加到同步队列后 退出循环\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        // 应该是在其他线程释放锁后被唤醒\n        // 检查当前线程是否中断，若未中断则返回 0\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // node 进入自旋过程尝试获取锁\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n\n```java\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // If lastWaiter is cancelled, clean out.\n    if (t != null && t.waitStatus != Node.CONDITION) {\n    \t// 移除等待队列中状态非 CONDITION 的节点\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    // 将当前线程构造节点并设置状态为 CONDITION\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    if (t == null)\n    \t// 等待队列为空的时候将 firstWaiter 指向 node\n        firstWaiter = node;\n    else\n    \t// 等待队列非空时将 lastWaiter 尾节点的 nextWaiter 指向 node\n        t.nextWaiter = node;\n    // 移动尾节点\n    lastWaiter = node;\n    return node;\n}\n```\n\n```java\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        // 当前线程释放锁，并唤醒同步队列中 head 的后置节点\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n```\n\n```java\n// 判断节点是否在同步队列上\nfinal boolean isOnSyncQueue(Node node) {\n\t// 节点状态为 CONDITION 或 节点的前置为空 说明节点还在等待队列上\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    // 如果节点存在后置节点 next 则说明节点在同步队列上\n    if (node.next != null) // If has successor, it must be on queue\n        return true;\n    /*\n     * node.prev can be non-null, but not yet on queue because\n     * the CAS to place it on queue can fail. So we have to\n     * traverse from tail to make sure it actually made it.  It\n     * will always be near the tail in calls to this method, and\n     * unless the CAS failed (which is unlikely), it will be\n     * there, so we hardly ever traverse much.\n     */\n    // 从 tail 尾节点开始遍历同步队列查找 node 节点；若存在返回 true,反之返回 false\n    return findNodeFromTail(node);\n}\n```\n\nawait 操作流程如下 ：\n\n* 将当前线程构造一个新的 node 节点，状态为 CONDITION 添加到等待队列尾部\n* 释放锁，唤醒同步队列 head 的后置节点\n* 判断当前 node 节点是否在同步队列中，若不在同步队列上则挂起当前线程，等待其他线程释放锁时被唤醒\n* 节点 node 被唤醒后若在同步队列上，则进入自旋过程再次尝试获取锁\n\n#### signal()\n\n> signal 操作激活等待队列中节点\n\n```java\npublic final void signal() {\n\t// 判断当前线程是否为锁的持有者\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n```\n\n```java\nprivate void doSignal(Node first) {\n    do {\n    \t// 判断 first 的后置节点是否为空，为空说明等待队列为空\n        if ( (firstWaiter = first.nextWaiter) == null)\n        \t// 等待队列的尾节点置为空\n            lastWaiter = null;\n        // 将 first 的后置节点置为空，也即是将 first 节点从等待队列中移除\n        first.nextWaiter = null;\n\n        // 执行信号转移\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n}\n```\n\n```java\n// 将节点从等待队列 (condition queue) 转移到 同步队列 (sync queue)\nfinal boolean transferForSignal(Node node) {\n\t/*\n\t * If cannot change waitStatus, the node has been cancelled.\n\t */\n\t// 将节点状态设置为 0\n\tif (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n\t    return false;\n\n\t/*\n\t * Splice onto queue and try to set waitStatus of predecessor to\n\t * indicate that thread is (probably) waiting. If cancelled or\n\t * attempt to set waitStatus fails, wake up to resync (in which\n\t * case the waitStatus can be transiently and harmlessly wrong).\n\t */\n\t// 将节点添加到同步队列(sync queue)尾部， 此时 p 应该是 node 的前置节点 ws 为 0\n\tNode p = enq(node);\n\t// \n\tint ws = p.waitStatus;\n\t// 将 node 的前置节点状态改为 SIGNAL; 便于节点 p 释放锁的时候唤醒 node\n\tif (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n\t    LockSupport.unpark(node.thread);\n\treturn true;\n\t}\n```\n\nsignal 操作的流程如下：\n\n* 将等待队列中的节点从队列中移除\n* 将等待队列中的节点状态由 CONDITION 改为 0\n* 将等待队列中的节点添加到 AQS 的同步队列尾部\n\n> signal 的作用 只是将节点从等待队列转移到同步队列中，只有当前线程释放锁后，转移到同步队列的节点才会有机会获取到锁。\n\n如下图所示为 Condition 操作节点的转移过程：\n\n![](https://user-gold-cdn.xitu.io/2018/12/14/167acc5c97a7b8a1?w=1066&h=1113&f=png&s=82729)\n\n### 小结\n\n从 Condition 的 await()、signal() 操作可以看出，其作用等效于 Object 对象的 await(), notify() 方法； ","tags":["jdk","多线程"]},{"title":"AbstractQueuedSynchronizer 队列同步器源码分析-共享锁","url":"/2018/12/04/AbstractQueuedSynchronizer 队列同步器源码分析-共享锁/","content":"### AQS 共享式同步状态获取和释放\n\n> 上一篇文章中主要分析了 AQS 的独占模式对同步状态的获取和释放过程，本文主要分析下共享模式下的同步状态的获取和释放是如何实现的\n\n### 共享锁获取\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n    \t// 获取锁失败\n        doAcquireShared(arg);\n}\n```\n\n```java\nprivate void doAcquireShared(int arg) {\n\t// 不同于独占模式下，创建的节点模式不同\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                \t// 不同独占模式\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n从 doAcquireShared 实现可以看出，共享模式下同步队列的节点在自旋的过程与独占模式基本类似，不同在于自旋过程中成功获取同步状态时的处理 \n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n    \n    // 若 progagate > 0 说明可继续向下传播唤醒节点\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n从 setHeadAndPropagate 的实现我们可以看出在移动 head 节点之后，若满足继续往下传播唤醒的条件时将会调用 doReleaseShared 方法。\n\n#### 共享锁释放\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n    \t// 释放同步状态\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n``\n\n```java\nprivate void doReleaseShared() {   \n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n            \t// 将 head 节点状态重置为 0\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                // CAS 成功则唤醒下个节点\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        // 头节点指向未发生变化的时候 退出循环\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n因共享模式下，会存在多个线程同时释放同步状态的场景， doReleaseShared 通过不断的轮询和 CAS 操作保证节点的唤醒。\n我们还是以图的形式模拟下多线程释放的场景：\n\n![](https://user-gold-cdn.xitu.io/2018/11/29/1675ff1407ce6ed1?w=1089&h=856&f=png&s=60731)\n","tags":["jdk","多线程"]},{"title":"AbstractQueuedSynchronizer 队列同步器源码分析","url":"/2018/12/02/AbstractQueuedSynchronizer-队列同步器源码分析/","content":"### AbstractQueuedSynchronizer 队列同步器（AQS）\n\n> 队列同步器 (AQS), 是用来构建锁或其他同步组件的基础框架，它通过使用 int 变量表示同步状态，通过内置的 FIFO 的队列完成资源获取的排队工作。（摘自《Java并发编程的艺术》）\n\n我们知道获取同步状态有独占和共享两种模式，本文先针对独占模式进行分析。\n\n#### 变量定义\n\n```java\nprivate transient volatile Node head;\n```\n\nhead 同步队列头节点\n\n```java\nprivate transient volatile Node tail;\n```\n\ntail 同步队列尾节点\n\n```java\nprivate volatile int state;\n```\n\nstate 同步状态值\n\n#### Node - 同步队列节点定义\n\n```java\nvolatile int waitStatus;\n```\nwaitStatus 节点的等待状态，可取值如下 :\n\n* 0 : 初始状态\n* -1 : SIGNAL 处于该状态的节点，说明其后置节点处于等待状态； 若当前节点释放了锁可唤醒后置节点\n* -2 : CONDITION 该状态与 Condition 操作有关后续在说明\n* -3 : PROPAGATE 该状态与共享式获取同步状态操作有关后续在说明\n* 1 : CANCELLED 处于该状态的节点会取消等待，从队列中移除\n\n```java\nvolatile Node prev;\n```\n\nprev 指向当前节点的前置节点\n\n```java\nvolatile Node next;\n```\n\nnext 指向当前节点的后置节点\n\n```java\nvolatile Thread thread;\n```\n\nthread 节点对应的线程也是指当前获取锁失败的线程\n\n```java\nNode nextWaiter;\n```\n\n#### acquire()\n\n> 独占模式下获取同步状态， 既是当前只允许一个线程获取到同步状态\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n从 acquire 方法中我们可以大概猜测下，获取锁的过程如下：\n\n* tryAcquire 尝试获取同步状态， 具体如何判定获取到同步状态由子类实现\n* 当获取同步状态失败时，执行 addWaiter 创建独占模式下的 Node 并将其添加到同步队列尾部\n* 加入同步队列之后，再次尝试获取同步状态，当达到某种条件的时候将当前线程挂起等待唤醒\n\n下面具体看下各个阶段如何实现：\n\n```java\nprivate Node addWaiter(Node mode) {\n\t// 绑定当前线程 创建 Node 节点\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    // 判断同步队列尾节点是否为空\n    if (pred != null) {\n    \t// node 的前置节点指向队列尾部\n        node.prev = pred;\n        // 将同步队列的 tail 移动指向 node\n        if (compareAndSetTail(pred, node)) {\n        \t// 将原同步队列的尾部后置节点指向 node\n            pred.next = node;\n            return node;\n        }\n    }\n    // tail 为空说明同步队列还未初始化\n    // 此时调用 enq 完成队列的初始化及 node 入队\n    enq(node);\n    return node;\n}\n```\n\n```java\nprivate Node enq(final Node node) {\n\t// 轮询的方式执行\n\t// 成功入队后退出\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n        \t// 创建 Node, 并将 head 指向该节点\n        \t// 同时将 tail 指向该节点\n        \t// 完成队列的初始化\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n        \t// node 的前置节点指向队列尾部\n            node.prev = t;\n            // 将同步队列的 tail 移动指向 node\n            if (compareAndSetTail(t, node)) {\n            \t// 将原同步队列的尾部后置节点指向 node\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n从代码中可以看出通过 CAS 操作保证节点入队的有序安全，其入队过程中如下图所示：\n\n![AQS节点入队过程](https://user-gold-cdn.xitu.io/2018/11/27/1675413481b66ce2?w=1137&h=256&f=png&s=11932)\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        // \n        for (;;) {\n        \t// 获取当前节点的前置节点\n            final Node p = node.predecessor();\n            // 判断前置节点是否为 head 头节点\n            // 若前置节点为 head 节点，则再次尝试获取同步状态\n            if (p == head && tryAcquire(arg)) {\n            \t// 若获取同步状态成功\n            \t// 则将队列的 head 移动指向当前节点\n                setHead(node);\n                // 将原头部节点的 next 指向为空，便于对象回收\n                p.next = null; // help GC\n                failed = false;\n                // 退出轮询过程\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n    \t// 若前置节点状态为 -1 ，则说明后置节点 node 可以安全挂起了\n        return true;\n    if (ws > 0) {\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do {\n        \t// ws > 0 说明前置节点状态为 CANCELLED , 也就是说前置节点为无效节点\n        \t// 此时从前置节点开始向队列头节点方向寻找有效的前置节点\n        \t// 此操作也即是将 CANCELLED 节点从队列中移除\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        // 若前置节点状态为初始状态 则将其状态设为 -1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n\t// 将当前线程挂起\n    LockSupport.park(this);\n    // 被唤醒后检查当前线程是否被挂起\n    return Thread.interrupted();\n}\n```\n\n从 acquireQueued 的实现可以看出，节点在入队后会采用轮询的方式（自旋）重复执行以下过程：\n\n* 判断前置节点是否为 head， 若为 head 节点则尝试获取同步状态； 若获取同步状态成功则移动 head 指向当前节点并退出循环\n* 若前置节点非 head 节点或者获取同步状态失败，则将前置节点状态修改为 -1， 并挂起当前线程，等待被唤醒重复执行以上过程\n\n如下图所示：\n\n![AQS-节点自旋活动图](https://user-gold-cdn.xitu.io/2018/11/27/167543bc86ada28d?w=420&h=543&f=png&s=17640)\n\n接下来我们看看同步状态释放的实现。\n\n#### release\n\n> 释放同步状态\n\n```java\npublic final boolean release(int arg) {\n\t// 尝试释放同步状态\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n        \t// 唤醒后置节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n```java\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus;\n    if (ws < 0)\n    \t// 将 head 节点状态改为 0\n        compareAndSetWaitStatus(node, ws, 0);\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    // 获取后置节点\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n    \t// 唤醒后置节点上所阻塞的线程\n        LockSupport.unpark(s.thread);\n}\n```\n\n从上述代码，我们可以明白释放同步状态的过程如下：\n\n* 调用 tryRelease 尝试释放同步状态，同样其具体的实现由子类控制\n* 成功释放同步状态后，将 head 节点状态改为 0\n* 唤醒后置节点上阻塞的线程\n\n如下图所示（红色曲线表示节点自旋过程） :\n\n![AQS-释放锁](https://user-gold-cdn.xitu.io/2018/11/27/167544ef85661bdf?w=645&h=652&f=png&s=29604)\n\n\n#### acquireInterruptibly()\n\n> 独占模式下获取同步状态，不同于 acquire 方法，该方法对中断操作敏感； 也就是说当前线程在获取同步状态的过程中，若被中断则会抛出中断异常\n\n```java\npublic final void acquireInterruptibly(int arg)\n            throws InterruptedException {\n    if (Thread.interrupted())\n    \t// 检查线程是否被中断\n    \t// 中断则抛出中断异常由调用方处理\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n```\n\n```java\nprivate void doAcquireInterruptibly(int arg)\n        throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                // 不同于 acquire 的操作，此处在唤醒后检查是否中断，若被中断直接抛出中断异常\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n        \t// 抛出中断异常后最终执行 cancelAcquire\n            cancelAcquire(node);\n    }\n}\n```\n\n```java\nprivate void cancelAcquire(Node node) {\n        // Ignore if node doesn't exist\n    if (node == null)\n        return;\n\n    node.thread = null;\n\n    // Skip cancelled predecessors\n    Node pred = node.prev;\n    while (pred.waitStatus > 0)\n        node.prev = pred = pred.prev;\n\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    Node predNext = pred.next;\n\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    node.waitStatus = Node.CANCELLED;\n\n    // If we are the tail, remove ourselves.\n    // 若当前节点为 tail 节点，则将 tail 移动指向 node 的前置节点\n    if (node == tail && compareAndSetTail(node, pred)) {\n    \t// 同时将node 前置节点的 next 指向 null\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred's next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n            pred.thread != null) {\n        \t// 当前节点位于队列中部    \n            Node next = node.next;\n            if (next != null && next.waitStatus <= 0)\n            \t// 将前置节点的 next 指向 node 的后置节点\n                compareAndSetNext(pred, predNext, next);\n        } else {\n        \t// 若 node 的前置节点为 head 节点则唤醒 node 节点的后置节点\n            unparkSuccessor(node);\n        }\n\n        node.next = node; // help GC\n    }\n}\n```\n\n从 acquireInterruptibly 的实现可以看出，若线程在获取同步状态的过程中出现中断操作，则会将当前线程对应的同步队列等待节点从队列中移除并唤醒可获取同步状态的线程。\n\n#### tryAcquireNanos()\n\n> 独占模式超时获取同步状态，该操作与acquireInterruptibly一样对中断操作敏感，不同在于超过等待时间若未获取到同步状态将会返回\n\n```java\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n            throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    return tryAcquire(arg) ||\n        doAcquireNanos(arg, nanosTimeout);\n}\n```\n```java\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n            throws InterruptedException {\n    if (nanosTimeout <= 0L)\n        return false;\n    // 计算等待到期时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout <= 0L)\n            \t// 超时时间到期直接返回\n                return false;\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                // 按指定时间挂起s\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n\n#### 节点的状态\n\n同步队列中的节点在自旋获取同步状态的过程中，会将前置节点的状态由 0 初始状态改为 -1 SIGNAL, 若是中断敏感的操作则会将状态由 0 改为 1\n\n同步队列中的节点在释放同步状态的过程中会将同步队列的 head 节点的状态改为 0， 也即是由 -1 变为 0；\n\n#### 小结\n\n本文主要分析了独占模式获取同步状态的操作，其大概流程如下：\n\n* 在获取同步状态时，AQS 内部维护了一个同步队列，获取状态失败的线程会被构造一个节点加入到队列中并进行一系列自旋操作\n* 在释放同步状态时，唤醒 head 的后置节点去获取同步状态","tags":["jdk","多线程"]},{"title":"TCP：三次握手、四次握手、backlog及其他","url":"/2018/03/13/TCP：三次握手、四次握手、backlog及其他/","content":"\n参考博客　[TCP：三次握手、四次握手、backlog及其他](https://www.cnblogs.com/xrq730/p/6910719.html)\n"},{"title":"Java内存模型","url":"/2018/03/11/Java内存模型/","content":"\n##### 定义\n\nJava 虚拟机规范中通过定义一种 Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的内存访问效果。\n\n###### 主内存与工作内存\n\n主内存 : 在 Java 内存模型中规定了所有的变量都存储在主内存中。\n工作内存 : 每个线程都有自己的工作内存，在工作内存中保存了该线程使用到的变量的主内存副本拷贝；线程对变量的所有操作必须在工作内存中完成，而不能直接读写主内存的变量；不同线程之间无法直接访问对方的工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n![](http://img.blog.csdn.net/20160921182337904)\n\n```\n此处我们描述的主内存，工作内存与 Java 运行时数据中的堆,栈，方法区并不是同一层次的内存划分；二者基本上是没有关系的，不过也可以理解为主内存对应于 Java 堆中的对象实例，而工作内存对应于虚拟机中的栈。\n```\n\n###### 内存间如何交互\n\n在 Java 内存模型中定义了８中操作用来实现内存间的交互，也即是变量如何从主内存拷贝到工作内存，以及工作内存中的变量如何同步回主内存。\n\n８中操作如下：\n\n* lock : 锁定，作用于主内存的变量，将变量标志为一条线程独占的状态\n* unlock : 解锁，作用于主内存的变量，将处于锁定状态的变量释放，方便其他线程锁定\n* read : 读取，作用于主内存的变量，将一个变量的值从主内存传输到工作内存中\n* load : 载入，作用于工作内存，将read操作从主内存得到的变量放入工作内存的变量副本中\n* use : 使用，作用于工作内存的变量\n* assign : 赋值\n* store : 存储\n* write :\n\n在 Java 模型中还规定了在完成上述操作时必须满足以下规则：\n\n* 变量在工作内存中改变之后必须把该变化同步到主内存\n* 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次；多次 lock 之后，只有执行相同次数的 unlock 操作，变量才会被解锁；也就是可重入锁。\n* 对一个变量执行 lock 操作，将会清空工作内存中此变量的值也就是从主内存重新获取该变量的值更新到工作内存中\n* 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中\n\n\n\n\n\n"},{"title":"Jdk之LinkedHashMap","url":"/2018/03/05/Jdk之LinkedHashMap/","content":"\n##### 概述\n\nLinkedHashMap 与 HashMap 的不同之处在于前者遍历有序，后者遍历无序\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fp29qrz3k1j30900f0mxz.jpg)\n\n从上图中可以看出 LinkedHashMap 继承至 HashMap , 并重写了 init, createEntry, addEntry, iterator 等方法。\n\n同时新增了全局变量 header, 并自定义了 LinkedHashMap.Entry 内部类\n<!-- more -->\n```java\nprivate static class Entry<K,V> extends HashMap.Entry<K,V> {\n        // These fields comprise the doubly linked list used for iteration.\n        Entry<K,V> before, after;\n\n        Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n            super(hash, key, value, next);\n        }\n\n        /**\n         * Removes this entry from the linked list.\n         */\n        private void remove() {\n            before.after = after;\n            after.before = before;\n        }\n\n        /**\n         * Inserts this entry before the specified existing entry in the list.\n         */\n        private void addBefore(Entry<K,V> existingEntry) {\n            after  = existingEntry;\n            before = existingEntry.before;\n            before.after = this;\n            after.before = this;\n        }\n\n    }\n\n```\n\n从代码中可以看出 LinkedHashMap.Entry 继承至 HashMap.Entry ,　新增了变量 before, after; 以及内部方法 addBefore;\n\n那么 LinkedHashMap 如何保证遍历有序的呢？下文将详细说明，首先我们先看下 LinkedHashMap 的初始化操作有何不同。\n\n###### init\n\n```java\n\tvoid init() {\n        header = new Entry<>(-1, null, null, null);\n        header.before = header.after = header;\n    }\n```\n\n在初始化过程中 构建了 header 节点\n\n###### createEntry\n\n```java\n\t/**\n     * This override differs from addEntry in that it doesn't resize the\n     * table or remove the eldest entry.\n     */\n    void createEntry(int hash, K key, V value, int bucketIndex) {\n        HashMap.Entry<K,V> old = table[bucketIndex];\n        Entry<K,V> e = new Entry<>(hash, key, value, old);\n        table[bucketIndex] = e;\n        e.addBefore(header);\n        size++;\n    }\n```\n\n从代码中可以看出与 HashMap 不同之处在于 构建 Entry 实例之后执行了 e.addBefore 方法\n\n```java\n\tprivate void addBefore(Entry<K,V> existingEntry) {\n            // 当前节点的后驱节点指向 existingEntry\n\t\t\tafter  = existingEntry;\n\t\t\t// 当前节点的前驱节点指向 existingEntry 的后驱节点\n            before = existingEntry.before;\n\t\t\t// 当前节点的前驱节点的后驱节点指向当前节点\n            before.after = this;\n\t\t\t// 当前节点的后驱节点的前驱节点指向当前节点\n            after.before = this;\n        }\n```\n\n从init, Entry.addBefore 方法可以看出 LinkedHashMap 内部维护了一个\"双向链表\"，每次添加元素的时候会将该节点添加到链表中；如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fp2baen2gdj30ul0h7qv5.jpg)\n\n###### iterator\n\n```java\nprivate abstract class LinkedHashIterator<T> implements Iterator<T> {\n        Entry<K,V> nextEntry    = header.after;\n        Entry<K,V> lastReturned = null;\n\n        /**\n         * The modCount value that the iterator believes that the backing\n         * List should have.  If this expectation is violated, the iterator\n         * has detected concurrent modification.\n         */\n        int expectedModCount = modCount;\n\n        public boolean hasNext() {\n\t\t\t// 当 nextEntry 不等于 header 的表示还未遍历到链表末尾\n            return nextEntry != header;\n        }\n\n        public void remove() {\n            if (lastReturned == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n\n            LinkedHashMap.this.remove(lastReturned.key);\n            lastReturned = null;\n            expectedModCount = modCount;\n        }\n\n        Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (nextEntry == header)\n                throw new NoSuchElementException();\n\n            Entry<K,V> e = lastReturned = nextEntry;\n\t\t\t// 指向节点的后驱节点\n            nextEntry = e.after;\n            return e;\n        }\n    }\n```\n\n从内部类 LinkedHashIterator 中可以看出 LinkedHashMap 是遍历双向链表，从而保证遍历的时候有序.\n\n同样 LinkedHashSet 内部是调用 LinkedHashMap 实现，同样也保证了遍历有序。\n\n","tags":["数据结构"]},{"title":"Jdk之HashMap","url":"/2018/03/05/Jdk之HashMap/","content":"\n##### 概述\n\nHashMap 是散列表的一种基于拉链法的实现方式。\n\n本文先看下 HashMap 的迭代实现方式\n\n```java\n\tprivate abstract class HashIterator<E> implements Iterator<E> {\n        Entry<K,V> next;        // next entry to return\n        int expectedModCount;   // For fast-fail\n        int index;              // current slot\n        Entry<K,V> current;     // current entry\n\n        HashIterator() {\n            expectedModCount = modCount;\n            if (size > 0) { // advance to first entry\n                Entry[] t = table;\n\t\t\t\t// 遍历数组 直到发现一个不为空的 Entry\n                while (index < t.length && (next = t[index++]) == null)\n                    ;\n            }\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n        final Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            Entry<K,V> e = next;\n            if (e == null)\n                throw new NoSuchElementException();\n\t\t\t// 获取当前 Entry 链表的下一个节点，如果下个节点为空说明当前链表已经遍历结束\n\t\t\t// 此时继续遍历数组 直到发现一个不为空的 Entry\n            if ((next = e.next) == null) {\n                Entry[] t = table;\n                while (index < t.length && (next = t[index++]) == null)\n                    ;\n            }\n            current = e;\n            return e;\n        }\n\n        public void remove() {\n            if (current == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            Object k = current.key;\n            current = null;\n            HashMap.this.removeEntryForKey(k);\n            expectedModCount = modCount;\n        }\n    }\n```\n\n遍历过程如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fp29gi4632j31hc0u04bx.jpg)\n\n"},{"title":"jdk之LinkedList","url":"/2018/02/28/jdk之LinkedList/","content":"\n##### 定义\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n```\n\n从定义可以看出 LinkedList 实现了接口 List, Deque, 表明其支持列表,栈，队列，双端队列的操作。\n\n<!-- more -->\n\n##### 变量\n\n```java\n\ttransient int size = 0;\n\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last;\n```\n\n* size : 链表元素个数\n* first : 指向链表的头节点\n* last : 指向链表的尾节点\n\n###### 内部类\n\n```java\n\tprivate static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n\nNode 是 LinkedList 的内部类，定义了链表的节点结构:\n* item : 节点存储的元素\n* prev : 当前节点的前驱节点\n* next : 当前节点的后驱节点\n\n##### Api\n\n###### add(E)\n\n向链表中添加元素\n\n```java\n\tpublic boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n```\n\n```java\n    void linkLast(E e) {\n        final Node<E> l = last;\n\t\t// 定义插入节点\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n\t\t\t// 链表为空 头尾节点均指向新插入的节点\n            first = newNode;\n        else\n\t\t\t// 链表的尾节点后驱节点指向新插入的节点\n            l.next = newNode;\n\t\t// 元素个数加一\n        size++;\n        modCount++;\n    }\n```\n\n* 首先构建待插入的节点\n* 将尾节点指向待插入的节点\n* 若原尾节点为空，说明队列为空，将头节点也指向待插入的节点\n* 若原尾节点非空，则将原尾节点的后驱节点指向待插入节点\n* 元素个数加一\n\n###### add(index, e)\n\n向链表中指定的位置插入元素\n\n```java\n\tpublic void add(int index, E element) {\n        // 检查位置index 是否在链表范围内\n\t\tcheckPositionIndex(index);\n\n        if (index == size)\n\t\t\t// 表明在链表的末尾插入节点\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n```\n\nnode(index) 方法用于获取链表指定位置的节点\n\n```java\n\tNode<E> node(int index) {\n        // assert isElementIndex(index);\n\t\t// 判断index 是否比链表长度的一半小；size >> 1 相当于 size/2\n\t\t// 如果小于链表的一半，则从头节点开始遍历\n\t\t// 如果大于链表的一半，则从尾节点开始遍历\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n\nlinkBefor(E e, Node succ) 方法用于在指定节点前插入元素\n\n```java\n\tvoid linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n###### set(index, e)\n\n更新链表指定位置节点的元素，并返回老的元素\n\n```java\n\tpublic E set(int index, E element) {\n        checkElementIndex(index);\n        // 获取指定位置的节点\n\t\tNode<E> x = node(index);\n        E oldVal = x.item;\n\t\t// 更新节点元素\n        x.item = element;\n        return oldVal;\n    }\n```\n\n###### get(index)\n\n获取链表指定位置的元素\n\n```java\n\tpublic E get(int index) {\n        checkElementIndex(index);\n\t\t// 获取指定位置的节点　然后返回其存储的元素\n        return node(index).item;\n    }\n```\n\n###### remove(index)\n\n删除链表指定位置的节点并返回该节点存储的元素\n\n```java\n\tpublic E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n```\n\nunlink(node) 该方法从字面上理解即解除节点与链表的链接\n\n```java\n\tE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n\t\t\t// 前驱节点为空，说明删除的节点为头节点\n\t\t\t// 那么将头节点指向删除节点的后驱节点\n            first = next;\n        } else {\n\t\t\t// 前驱节点不为空\n\t\t\t// 将前驱节点的后驱节点指向删除节点的后驱节点\n            prev.next = next;\n\t\t\t// 删除节点的前驱节点指向空\n            x.prev = null;\n        }\n\n        if (next == null) {\n\t\t\t// 删除节点的后驱节点为空，说明删除节点为尾节点\n\t\t\t// 那么将尾节点指向删除节点的前驱节点\n            last = prev;\n        } else {\n\t\t\t// 后驱节点不为空\n\t\t\t// 将后驱节点的前驱节点指向删除节点的前驱节点\n            next.prev = prev;\n\t\t\t// 删除节点的后驱节点指向空\n            x.next = null;\n        }\n\t\t//　存储元素改为空,元素个数减一\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n###### iterator()\n\n链表的迭代, 内部调用的是 listIterator(0) 方法\n\n```java\n\tpublic ListIterator<E> listIterator(int index) {\n        checkPositionIndex(index);\n        return new ListItr(index);\n    }\n```\n\n```java\nprivate class ListItr implements ListIterator<E> {\n        private Node<E> lastReturned = null;\n        private Node<E> next;\n        private int nextIndex;\n        private int expectedModCount = modCount;\n\n        ListItr(int index) {\n            // assert isPositionIndex(index);\n            next = (index == size) ? null : node(index);\n            nextIndex = index;\n        }\n\n        public boolean hasNext() {\n\t\t\t// nextIndex 小于 size 表明还未遍历到链表结尾\n            return nextIndex < size;\n        }\n\n        public E next() {\n            checkForComodification();\n            if (!hasNext())\n                throw new NoSuchElementException();\n\t\t\t\n            lastReturned = next;\n            // next 指向下一个节点\n\t\t\tnext = next.next;\n\t\t\t// nextIndex 加一\n            nextIndex++;\n            return lastReturned.item;\n        }\n\n    }\n\n```\n\n\n\n","tags":["jdk"]},{"title":"数据结构-平衡二叉树","url":"/2018/02/26/数据结构-平衡二叉树/","content":"\n##### 概念\n\n###### 平衡二叉树\n\n平衡二叉树(Self-Balancing Binary Search Tree) 是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于１。\n\n<!-- more -->\n\n###### 平衡因子\n\n平衡因子 BF (Balance Factor) : 我们将二叉树上节点的左子树的深度减去右子树的深度值称为平衡因子；那么平衡二叉树上所有节点的平衡因子只可能是 -1, 0, 1。\n\n```\n只要二叉树上有一个节点的平衡因子的绝对值大于１, 那么该二叉树就是不平衡的\n```\n\n###### 最小不平衡子树\n\n最小不平衡子树: 当我们在执行平衡二叉树插入节点时，距离插入节点最近的，且平衡因子的绝对值大于１的节点为根的子树，我们将其称之为最小不平衡子树。\n\n###### 示例\n\n现通过下图一些样例说明何为平衡二叉树\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fou295n9p2j30fw08s3zu.jpg)\n\n* 图１为平衡二叉树：因为除了根节点的平衡因子为０，其他节点的平衡因子的绝对值均为１，符合平衡二叉树的条件\n* 图２不是平衡二叉树：因为节点５８的左节点为５９，５９ > 58 不符合二叉树的性质左节点小于根节点，所以也不符合平衡二叉树\n* 图３不是平衡二叉树：因为节点５８的左子树的深度为２，而右子树为空；平衡因子为２，所以不符合平衡二叉树的条件\n* 图４为平衡二叉树，满足平衡二叉树的条件\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fou58qvs1fj308i04x0t5.jpg)\n\n同样如上图所示，插入节点３７时，距离它最近的且平衡因子超过１的节点为５８，所以５８节点开始以下的子树为最小不平衡子树。\n\n##### 实现原理\n\n平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点时先检查是否因插入而破坏了树的平衡性；若是则找出最小不平衡子树，在保持二叉排序树特性的前提下调整最小不平衡子树中各节点之间的链接关系进行相应的旋转，使其成为新的平衡子树。\n\n下面以一个数组 a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8} 构建平衡二叉树的过程来说明其实现原理。\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fow3wpwca3j310z0nwe81.jpg)\n\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fow3xwecl3j30zx0qqkjl.jpg)\n\n以上两张图说明了平衡二叉树在构建过程的原理。针对构建过程发现不平衡的处理有如下几个步骤：\n\n* 当最小不平衡子树根节点的平衡因子BF大于１时，右旋；当平衡因子小于-1时左旋\n* 当最小不平衡子树的BF与其子节点BF符号相反时，需要先对子节点进行一次旋转使得符号相同后再进行一次旋转已达到平衡\n\n```\n右旋 : 将旋转节点的左节点指向其左节点的右节点，然后将旋转节点的左节点的右节点指向旋转节点（旋转节点下降，其左节点上浮）\n```\n\n```\n左旋 : 将旋转节点的右节点指向其右节点的左节点，然后将旋转节点的右节点的左节点指向旋转节点（旋转节点下降，其右节点上浮）\n```\n\n\n\n\n"},{"title":"jdk之LinkedBlockingQueue","url":"/2018/01/26/jdk之LinkedBlockingQueue/","content":"\n##### 概述\n\n在上一篇文章中我们分析了 ArrayBlockingQueue ,　今天在看下采用链表结构实现的阻塞队列。\n\n分析前我们同样有以下疑问：\n\n- 如何通过链表实现队列的 FIFO ?\n- 如何保证队列操作的同步 ?\n- 与 ArrayBlockingQueue 相比有如何优势 ?\n\n<!-- more -->\n\n##### 定义\n\n同样首先我们先来看下 LinkedBlockingQueue 的相关属性定义如下：\n\n```java\n \t/**\n     * 定义链表节点\n\t *\n\t * item : 节点存储的元素\n\t * next : 当前节点的后继节点\n     */\n    static class Node<E> {\n        E item;\n\n        Node<E> next;\n\n        Node(E x) { item = x; }\n    }\n\n    /** 定义队列的容量 默认为 Integer.MAX_VALUE */\n    private final int capacity;\n\n    /** 定义当前队列的存储元素个数 */\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    /**\n     * 队列头节点\n     * Invariant: head.item == null\n     */\n    private transient Node<E> head;\n\n    /**\n     * 队列尾节点\n     * Invariant: last.next == null\n     */\n    private transient Node<E> last;\n\n    /** Lock held by take, poll, etc */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** Wait queue for waiting takes */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** Lock held by put, offer, etc */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** Wait queue for waiting puts */\n    private final Condition notFull = putLock.newCondition();\n```\n\n从定义中有以下几个疑问：\n\n- 当前队列元素个数为什么采用原子操作类 AtomicInteger ? int 类型的变量为什么不可以？\n- 队列的头尾节点定义注释中为什么说 head last 都有一个不变性 item 永远为空 ?\n\n##### 构造\n\n```java\n\tpublic LinkedBlockingQueue() {\n\t\t// 队列默认容量为 int 最大值\n        this(Integer.MAX_VALUE);\n    }\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n\t\t// 设置队列容量\n        this.capacity = capacity;\n\t\t// 初始队列头尾节点\n        last = head = new Node<E>(null);\n    }\n```\n\n##### API\n\n###### offer(E e)\n\n```java\n\tpublic boolean offer(E e) {\n        if (e == null) throw new NullPointerException();\n        final AtomicInteger count = this.count;\n        if (count.get() == capacity)\n\t\t\t// 若队列满了 返回 false; 说明插入失败\n            return false;\n        int c = -1;\n\t\t// 定义节点\n        Node<E> node = new Node(e);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock();\n        try {\n            if (count.get() < capacity) {\n\t\t\t\t// 插入队列\n                enqueue(node);\n\t\t\t\t// 队列元素个数加一，并返回原来的个数\n                c = count.getAndIncrement();\n                if (c + 1 < capacity)\n\t\t\t\t\t// 队列未满唤醒因为队列满而阻塞的 put 操作\n                    notFull.signal();\n            }\n        } finally {\n            putLock.unlock();\n        }\n\t\t// c == 0 说明队列曾经为空，那么需要唤醒阻塞在 take poll 操作上的线程\n        if (c == 0)\n            signalNotEmpty();\n        return c >= 0;\n    }\n```\n\n```java\n\tprivate void enqueue(Node<E> node) {\n\t\t// 将原尾节点的后继节点 指向 node\n\t\t// 将尾节点指针指向 node\n        last = last.next = node;\n    }\n```\n\noffer 之后 last 永远指向链表的最近插入的节点，所以 last 节点的 next 永远为空。\n\n###### poll()\n\n```java\n\tpublic E poll() {\n        final AtomicInteger count = this.count;\n        if (count.get() == 0)\n\t\t\t// 队列为空 返回 null\n            return null;\n        E x = null;\n        int c = -1;\n        final ReentrantLock takeLock = this.takeLock;\n        takeLock.lock();\n        try {\n            if (count.get() > 0) {\n\t\t\t\t// 出队 获取队列头部元素\n                x = dequeue();\n\t\t\t\t// 队列元素个数减一 并返回原个数\n                c = count.getAndDecrement();\n                if (c > 1)\n\t\t\t\t\t// 唤醒因队列为空而阻塞的 take poll 操作\n                    notEmpty.signal();\n            }\n        } finally {\n            takeLock.unlock();\n        }\n\t\t// c== capacity 说明队列曾经满了有 offer put 线程阻塞，故需唤醒\n        if (c == capacity)\n            signalNotFull();\n        return x;\n    }\n```\n\n```java\n\tprivate E dequeue() {\n        Node<E> h = head;\n\t\t// 取 head 的后继节点\n        Node<E> first = h.next;\n\t\t// 将 head 节点的 next 指向自己\n        h.next = h; // help GC\n\t\t// 将 head 重新指向头节点\n        head = first;\n\t\t\n        E x = first.item;\n        // 将 item 置为空\n\t\tfirst.item = null;\n        return x;\n    }\n```\n\n此时我们可以看出 LinkedBlockingQueue 中通过移动节点 head last 指针来实现队列的 FIFO; 效果如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnu4l95bqij30xy0bft91.jpg)\n\n\t因为插入和获取头部操作里采用的是两个不同的锁，所以为了保持不同线程不同操作内队列元素个数的一致性所以采用 AtomicInteger 计算而非 int 类型。\n\n\n###### put(E e)\n\n```java\npublic void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        // Note: convention in all put/take/etc is to preset local var\n        // holding count negative to indicate failure unless set.\n        int c = -1;\n        Node<E> node = new Node(e);\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly();\n        try {\n            while (count.get() == capacity) {\n                notFull.await();\n            }\n            enqueue(node);\n            c = count.getAndIncrement();\n            if (c + 1 < capacity)\n                notFull.signal();\n        } finally {\n            putLock.unlock();\n        }\n        if (c == 0)\n            signalNotEmpty();\n    }\n```\n\n###### take()\n\n\n\n\n\n","tags":["jdk"]},{"title":"jdk之ArrayBlockingQueue","url":"/2018/01/24/jdk之ArrayBlockingQueue/","content":"\n##### 概述\n\nArrayBlockingQueue 又称为数组阻塞队列；其基于数组实现的有界阻塞队列，能容纳的元素数量固定，一旦创建就不能再增加其容量。\n\n那么接下来我们会带着以下两个疑问进行分析：\n\n- 如何通过数组实现队列的特性 FIFO ?\n- 如何保证队列插入获取操作的同步 ?\n\n<!-- more -->\n\n##### 定义\n\n首先看下 ArrayBlockingQueue 的属性定义　如下：\n\n```java\n\t/** 固定大小数组用于存储队列元素 */\n    final Object[] items;\n\n    /** 指向下次获取元素的下标 可以理解为指向队列头部 */\n    int takeIndex;\n\n    /** 指向下次插入元素的下标 可以理解为指向队列尾部 */\n    int putIndex;\n\n    /** 当前队列存储元素的个数 */\n    int count;\n\n    /** 定义可重入锁 */\n    final ReentrantLock lock;\n\n    /** 用于控制 take 操作的 condition */\n    private final Condition notEmpty;\n\n    /** 用于控制 put 操作的 condition */\n    private final Condition notFull;\n\n```\n\n##### 构造函数\n\n```java\n\tpublic ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n\n\t/**\n\t * 创建固定容量的阻塞队列并设置访问策略\n\t * @param capacity 队列的最大容量 \n\t * @param fair 队列的访问策略，true为公平锁策略, false为非公平锁；默认为 false\n\t */\n    public ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n\n```\n\n从构造函数可以看出，在创建 ArrayBlockinQueue 实例时，需指定队列最大存储元素的容量并设置内部重入锁的访问策略默认为非公平锁。\n\n##### API\n\n###### add(E e)\n\n```java\n\tpublic boolean add(E e) {\n        return super.add(e);\n    }\n```\n\n从代码可以看出 ArrayBlockingQueue 的 add 方法的实现是基于父类 AbstractQueu 的实现如下：\n\n```java\n\tpublic boolean add(E e) {\n        if (offer(e))\n            return true;\n        else\n            throw new IllegalStateException(\"Queue full\");\n    }\n```\n\n从代码中我们知道 add 方法的主要实现在 offer 方法内（将会在下文分析），如果能够插入成功则返回 true, 否则抛出 IllegalStateException 异常\n\n###### remove()\n\nremove 方法移除队列的头部元素并返回, 其实现是在父类 AbstractQueue 中如下:\n\n```java\n\tpublic E remove() {\n        E x = poll();\n        if (x != null)\n            return x;\n        else\n            throw new NoSuchElementException();\n    }\n```\n\n如上代码知道 remov的主要实现在 poll 方法内；如果获取的头部元素不为空将返回，若为空则抛出 NoSUchElementException 异常。\n\n###### offer(E e)\n\n```java\n\tpublic boolean offer(E e) {\n\t\t// 检查元素是否为空\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n\t\t// 获取锁\n        lock.lock();\n        try {\n\t\t\t// 元素个数达到最大容量时返回 fae\n            if (count == items.length)\n                return false;\n\t\t\t// 执行插入返回 true\n            else {\n                insert(e);\n                return true;\n            }\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n```java\n\tprivate void insert(E x) {\n\t\t// 将元素插入数组指定的位置\n        items[putIndex] = x;\n\t\t// 将 putIndex 移动到下一个位置\n        putIndex = inc(putIndex);\n\t\t// 元素个数加一\n        ++count;\n\t\t// 当前队列非空，唤醒阻塞在获取元素操作上的线程\n        notEmpty.signal();\n    }\n```\n\n从代码可以看出 offer 方法将元素插入队列的逻辑如下：\n\n- 判断元素是否为空\n- 获取锁\n- 判断队列是否已满，若已满则返回 false\n- 通过指针 putIndex 将元素放入数组\n- 移动指针 putIndex 指向下一个位置\n- 队列当前元素个数加一\n- 唤醒阻塞在获取元素操作上的线程\n- 释放锁\n\n###### poll()\n\n```java\n\tpublic E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n\t\t\t// 队列空的时候 返回 null; 非空的时候调用 extract\n            return (count == 0) ? null : extract();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n```java\n\tprivate E extract() {\n        final Object[] items = this.items;\n\t\t// 获取头部的元素\n        E x = this.<E>cast(items[takeIndex]);\n\t\t// 将队列头部置为空\n        items[takeIndex] = null;\n\t\t// 移动头部指针\n        takeIndex = inc(takeIndex);\n\t\t// 队列元素个数减一\n        --count;\n\t\t// 唤醒因队列满而阻塞的插入操作\n        notFull.signal();\n        return x;\n    }\n```\n\npoll 方法获取头部元素逻辑如下：\n\n- 获取锁\n- 判断队列是否为空，若空则返回 null\n- 通过 takeIndex 头部指针获取队列头元素\n- 将队列头部置为空\n- 移动头部指针指向下个位置\n- 队列元素个数减一\n- 唤醒因队列满而阻塞的插入操作\n- 返回头部元素并释放锁\n\n此时我们可以看出 ArrayBlockingQueue 中通过两个指针 takeIndex putIndex 的移动来保证队列的 FIFO,如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnrtuixm5vj30yb09laa5.jpg)\n\n\t我们知道数组有界　在队列中又是如何保证循环利用的呢？\n\n```java\n\tfinal int inc(int i) {\n        return (++i == items.length) ? 0 : i;\n    }\n```\n\n从  inc 方法可以看出在移动 takeindex putindex 指针的时候，当他们到达末尾的时候重新指向头部。\n\n###### offer(E e,long timeout,TimeUnit u)\n\n该方法表示在指定的时间内将元素插入队列中，若失败返回 false 。\n\n```java\n\tpublic boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n\n        checkNotNull(e);\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n\t\t// 获取锁\n        lock.lockInterruptibly();\n        try {\n\t\t\t// 当前元素个数达到队列最大容量时 等待\n            while (count == items.length) {\n                if (nanos <= 0)\n\t\t\t\t\t// 说明已超时 队列满了插入失败 返回 false\n                    return false;\n                nanos = notFull.awaitNanos(nanos);\n            }\n\t\t\t// 执行插入\n            insert(e);\n            return true;\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 offer(e) 实现基本相同，只是在当队列满的情况下会在设置的 timeout 时间内等待。\n\n###### poll(long timeout, TimeUnit unit)\n\n```java\n\tpublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 当队列空的时候等待队列有元素；若等待超时之后还未有元素则返回 false\n            while (count == 0) {\n                if (nanos <= 0)\n                    return null;\n                nanos = notEmpty.awaitNanos(nanos);\n            }\n\t\t\t// 队列非空时　获取头部元素\n            return extract();\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n与 poll() 方法类似，不同之处在于当队列为空的时候等待。\n\n###### put(E e)\n\n```java\n\tpublic void put(E e) throws InterruptedException {\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 队列满的时候\n            while (count == items.length)\n\t\t\t\t// 释放锁当前线程阻塞；等待 take 操作唤醒\n                notFull.await();\n\t\t\t// 队列未满执行插入\n            insert(e);\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 offer 不同之处在于当队列满的时候，当前线程会阻塞直至等待 take 操作唤醒。\n\n###### take()\n\n```java\n\tpublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 队列为空的时候\n            while (count == 0)\n\t\t\t\t// 释放锁当前线程阻塞；等待 put 操作唤醒\n                notEmpty.await();\n\t\t\t// 队列非空　获取头部元素\n            return extract();\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 poll 不同之处在于当队列为空的时候，当前线程会一直阻塞直至等待 put 操作唤醒。\n\n##### 小结\n\n- ArrayBlockingQueue 采用数组作为元素存储，故其为有界队列\n- ArrayBlockingQueue 通过指针 takeIndex putIndex 的移动来实现 FIFO\n- ArrayBlockingQueue 通过定义 ReentrantLock 重入锁来保证插入获取操作的同步。也就是当前若有线程在执行插入操作，则获取操作同样会被阻塞。\n\n\n\n","tags":["jdk"]},{"title":"jdk之BlockingQueue","url":"/2018/01/24/jdk之BlockingQueue/","content":"\n##### 概述\n\n\nBlockingQueue 被称为阻塞队列，除了具备 Queue 的特点外，还支持另外两项重要特性：\n\n```\n\n对于有界队列，当队列满的时候，插入操作会阻塞等待队列可用；\n\n当队列空的时候，获取元素的操作会阻塞等待队列为非空\n\n```\n\n阻塞队列常用于“生产者－消费者”模式的业务场景，生产者就是往阻塞队列中插入元素的线程，消费者就是从阻塞队列中获取元素的线程；当生产者的速度大于消费者的速度，就可能出现有界队列满的情况，此时生产者就会出现阻塞等待状态直到队列中出现空闲；当生产者的速度小于消费者的速度就可能出现空队列的情况，消费者就会出现阻塞等待状态，直到队列中有元素。\n\n<!-- more -->\n\n##### API\n\n###### add(Object o)\n\n该方法是将指定元素插入到队列中，如果队列可插入则返回 true, 否则抛出异常\n\n###### offer(Object o)\n\n该方法将指定元素插入到队列中，如果队列可插入则返回 true, 否则返回 false\n\n###### offer (Object, timeout, timeunit)\n\n该方法在设定的等待时间内如果能将指定元素插入到队列中返回 true, 否则返回 false\n\n###### poll(long timeout,TimeUnit unit)\n\n该方法从队列中取出一个队首的元素，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。超时后，依然没有取得数据则返回NULL\n\n###### put(Object o)\n\n把对象o加入到BlockingQueue里，如果BlockingQueue没有足够空间，则调用此方法的线程会被阻塞等待，直到BlockingQueue里面有空闲空间时再继续执行\n\n###### take( )\n\n取走BlockingQueue里排在首位的对象，如果BlockingQueue为空，则调用此方法的线程会被阻塞等待，直到BlockingQueue里面有新元素被加入后再继续执行\n\n后续将会对 BlockingQueue 的几种实现进行分析.\n\n","tags":["jdk"]},{"title":"Netty客户端链接派发分析","url":"/2018/01/20/Netty客户端链接派发分析/","content":"\n在上篇针对 Netty 的服务端启动过程进行了分析，我们知道服务端包含了两个 NioEventLoopGroup, 一个是 boss 用于接收客户端的请求，一个是 worker 用于处理客户端的读写操作；那么 boss group 是如何将客户端链接通道派发到 worker 呢？本文主要针对这个问题进行分析。\n\n<!-- more -->\n\n##### NioEventLoop\n\n上文中我们知道 netty 主要通过 NioEventLoop 内部的线程处理客户端请求，那么我们接下来详细看下该线程的实现：\n\n```java\nprotected SingleThreadEventExecutor(\n            EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks,\n            RejectedExecutionHandler rejectedHandler) {\n        if (threadFactory == null) {\n            throw new NullPointerException(\"threadFactory\");\n        }\n\n        this.parent = parent;\n        this.addTaskWakesUp = addTaskWakesUp;\n\n        thread = threadFactory.newThread(new Runnable() {\n            @Override\n            public void run() {\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run();\n                    success = true;\n                } catch (Throwable t) {\n                    logger.warn(\"Unexpected exception from an event executor: \", t);\n                } finally {\n                    \n                }\n            }\n        });\n        threadProperties = new DefaultThreadProperties(thread);\n        this.maxPendingTasks = Math.max(16, maxPendingTasks);\n        taskQueue = newTaskQueue();\n        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n    }\n```\n\nNioEventLoop 内部的线程运行时会调用抽象方法 run, 其实现如下：\n\n```java\nprotected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                        // fall through\n                    default:\n                }\n\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\n\n该线程内部以“死循环”的方式 执行 select 后处理 selectedKeys :\n\n```java\nprivate void processSelectedKeys() {\n        if (selectedKeys != null) {\n            processSelectedKeysOptimized();\n        } else {\n            processSelectedKeysPlain(selector.selectedKeys());\n        }\n    }\n```\nselectedKeys 是在NioEventLoop构建时创建的SelectedSelectionKeySet实例，故会调用 processSelectedKeysOptimized 方法如下：\n```java\nprivate void processSelectedKeysOptimized() {\n        for (int i = 0; i < selectedKeys.size; ++i) {\n            final SelectionKey k = selectedKeys.keys[i];\n            // null out entry in the array to allow to have it GC'ed once the Channel close\n            // See https://github.com/netty/netty/issues/2363\n            selectedKeys.keys[i] = null;\n\n            final Object a = k.attachment();\n\n            if (a instanceof AbstractNioChannel) {\n                processSelectedKey(k, (AbstractNioChannel) a);\n            } else {\n                @SuppressWarnings(\"unchecked\")\n                NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;\n                processSelectedKey(k, task);\n            }\n\n            if (needsToSelectAgain) {\n                // null out entries in the array to allow to have it GC'ed once the Channel close\n                // See https://github.com/netty/netty/issues/2363\n                selectedKeys.reset(i + 1);\n\n                selectAgain();\n                i = -1;\n            }\n        }\n    }\n```\n\n其实现是循环遍历 selectedKeys 集合中的 selectedKey 进行处理，那么此时我们会有一个疑惑：\n\n\tselector 选择器中就绪的通道的 selectedKey 是如何添加到 selectedKeys 集合中呢？\n\n让我们回过头在看下 NioEventLoop 开启 selector 的过程：\n\n```java\nprivate SelectorTuple openSelector() {\n        final Selector unwrappedSelector;\n        try {\n\t\t\t// 开启 selector 返回 EpollSelectorImpl 实例\n            unwrappedSelector = provider.openSelector();\n        } catch (IOException e) {\n            throw new ChannelException(\"failed to open a new selector\", e);\n        }\n\n        if (DISABLE_KEYSET_OPTIMIZATION) {\n            return new SelectorTuple(unwrappedSelector);\n        }\n\n        final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();\n\t\t\n\t\t// ......\n\n        final Class<?> selectorImplClass = (Class<?>) maybeSelectorImplClass;\n\n        Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                try {\n                    Field selectedKeysField = selectorImplClass.getDeclaredField(\"selectedKeys\");\n                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(\"publicSelectedKeys\");\n\n                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField);\n                    if (cause != null) {\n                        return cause;\n                    }\n                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField);\n                    if (cause != null) {\n                        return cause;\n                    }\n                    // 将 Selector 实现类的属性 selectedKeys 替换为 netty 自定义的　SelectedSelectionKeySet\n                    // 这样当选择器　有就绪的通道时　就会把 selectKey 添加到　SelectedSelectionKeySet　中\n                    selectedKeysField.set(unwrappedSelector, selectedKeySet);\n                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n                    return null;\n                } catch (NoSuchFieldException e) {\n                    return e;\n                } catch (IllegalAccessException e) {\n                    return e;\n                }\n            }\n        });\n\n        if (maybeException instanceof Exception) {\n            selectedKeys = null;\n            Exception e = (Exception) maybeException;\n            logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, e);\n            return new SelectorTuple(unwrappedSelector);\n        }\n        selectedKeys = selectedKeySet;\n        logger.trace(\"instrumented a special java.util.Set into: {}\", unwrappedSelector);\n        return new SelectorTuple(unwrappedSelector,\n                                 new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));\n    }\n```\n\n从代码中可以看出 NioEventLoop 内部对于 selector 进行了包装，通过反射对 EpollSelectorImpl 实例内字段 selectedKeys publicSelectedKeys 替换为 SelectedSelectionKeySet 实例；这样就保证了当选择器有就绪的通道时就会把 selectKey 添加到 selectedSelectionKeySet 中\n\n我们在回到 processSelectedKeysOptimized 方法中，当集合中有就绪的 selectedKey 时，会获取绑定在该 key 上的附件 attachment 针对服务端来说 也就是 NioServerSocketChannel （注册的时候绑定的)；接下来会调用 processSelectedKey 如下：\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n        final NioUnsafe unsafe = ch.unsafe();\n            try {\n            int readyOps = k.readyOps();\n            // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise\n            // the NIO JDK channel implementation may throw a NotYetConnectedException.\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking\n                // See https://github.com/netty/netty/issues/924\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n\n                unsafe.finishConnect();\n            }\n\n            // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n                // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write\n                ch.unsafe().forceFlush();\n            }\n\n            // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead\n            // to a spin loop\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read();\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n    }\n```\n\n因服务端监听的是 ACCEPT 事件，故当有客户端链接请求就绪的时候会调用 unsafe.read() ,此时 unsafe 实例为 NioMessageSafe:\n\n```java\npublic void read() {\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config();\n            if (!config.isAutoRead() && !isReadPending()) {\n                // ChannelConfig.setAutoRead(false) was called in the meantime\n                removeReadOp();\n                return;\n            }\n\n            final int maxMessagesPerRead = config.getMaxMessagesPerRead();\n            final ChannelPipeline pipeline = pipeline();\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    for (;;) {\n                        int localRead = doReadMessages(readBuf);\n\t\t\t\t\t\t// 当没有客户端通道时退出\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        // stop reading and remove op\n                        if (!config.isAutoRead()) {\n                            break;\n                        }\n\n                        if (readBuf.size() >= maxMessagesPerRead) {\n                            break;\n                        }\n                    }\n                } catch (Throwable t) {\n                    exception = t;\n                }\n                setReadPending(false);\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n\t\t\t\t\t// 触发 pipeline 的 channelRead 事件\n                    pipeline.fireChannelRead(readBuf.get(i));\n                }\n\n                readBuf.clear();\n\t\t\t\t// 触发 pipeline 的 channelReadComplete 事件\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                \n            }\n        }\n```\n\n```java\nprotected int doReadMessages(List<Object> buf) throws Exception {\n\t\t// 获取客户端通道\n        SocketChannel ch = SocketUtils.accept(javaChannel());\n\n        try {\n            if (ch != null) {\n\t\t\t\t// 将 nio socketChannel 封装为 NioSocketChannell 添加到 buf　集合中\n                buf.add(new NioSocketChannel(this, ch));\n                return 1;\n            }\n        } catch (Throwable t) {\n            logger.warn(\"Failed to create a new channel from an accepted socket.\", t);\n\n            try {\n                ch.close();\n            } catch (Throwable t2) {\n                logger.warn(\"Failed to close a socket.\", t2);\n            }\n        }\n\n        return 0;\n    }\n```\n\n其流程为：\n\n- 获取客户端通道 socketChannel 并将其封装为 NioSocketChannel 添加到缓冲中\n- 触发 pipeline 的 channelRead 事件\n- 触发 pipeline 的 channelReadComplete 事件\n\n最终会触发 ServerBootstrapAcceptor handler 的 channelRead 事件如下： \n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n\t\t\t// msg 为 NioSocketChannel 实例\n            final Channel child = (Channel) msg;\n\t\t\t// 将 ServerBootstrap 设置的 childHandler 添加到 NioSocketChannel 的 pipeline 中\n            child.pipeline().addLast(childHandler);\n\n            setChannelOptions(child, childOptions, logger);\n\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n\n            try {\n\t\t\t\t// childGroup 也就是我们所理解的 wrker group\n\t\t\t\t// 执行注册 nioSocketChannel 即将 NioSocektChannel 注册到 worker group 中的 NioEventLoop 的 selector\n                childGroup.register(child).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n                forceClose(child, t);\n            }\n        }\n```\n\nchannelReadComplete 事件在执行过程中最终会调用 NioSocktChannel 的 doBegingRead 方法如下：\n\n```java\nprotected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        if (inputShutdown) {\n            return;\n        }\n\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) {\n\t\t\t// NioSocetChannel 创建的时候 readInterestop 值为 O_READ\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n```java\nprotected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {\n        super(parent, ch, SelectionKey.OP_READ);\n    }\n```\n\n\t至此将 SocketChannel 客户端通道注册到 worker group 中的 NioEventLoop　内的 selector 并监听 OP_READ 事件。\n\n\n此时 netty 内部线程模型如下：\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnn453ozrvj30rh09oq3n.jpg)\n","tags":["netty"]},{"title":"Netty服务端启动源码分析","url":"/2018/01/17/Netty服务端启动源码分析/","content":"\n  Netty 是一个高性能异步事件驱动的 NIO 框架, 因其底层采用的 NIO, 故其启动过程一样可以分为以下几个步骤:\n\n- selector 多路复用选择器开启\n- ServerSocketChannel 通道建立并绑定端口\n- ServerSocketChannel 通道注册到 selector 并监听 accept 事件\n\n在进行服务端启动分析前，我们先看下 netty 的服务端使用示例。\n\n<!-- more -->\n\n##### 示例\n\n```java\n// Configure the server.\nEventLoopGroup bossGroup = new NioEventLoopGroup(1);\nEventLoopGroup workerGroup = new NioEventLoopGroup();\ntry {\n\tServerBootstrap b = new ServerBootstrap();\n\tb.group(bossGroup, workerGroup)\n\t\t.channel(NioServerSocketChannel.class)\n\t \t.handler(new LoggingHandler(LogLevel.INFO))\n\t \t.childHandler(new ChannelInitializer<SocketChannel>() {\n\t\t\t @Override\n\t\t \tpublic void initChannel(SocketChannel ch) throws Exception {\n\t\t\t \tChannelPipeline p = ch.pipeline();\n\t\t\t \tif (sslCtx != null) {\n\t\t\t\t \tp.addLast(sslCtx.newHandler(ch.alloc()));\n\t\t\t \t}\t\n\t\t\t \tp.addLast(new EchoServerHandler());\n\t\t \t}\n\t \t});\n\n\t// Start the server.\n\tChannelFuture f = b.bind(PORT).sync();\n\n\t// Wait until the server socket is closed.\n\tf.channel().closeFuture().sync();\n} finally {\n\t// Shut down all event loops to terminate all threads.\n\tbossGroup.shutdownGracefully();\n\tworkerGroup.shutdownGracefully();\n}\n```\n\n从示例可以看出 netty 服务端通过创建 ServerBootstrap 实例，并对其配置 EventLoopGroup, channel, handler 之后即完成服务端的启动。\n\n##### NioEventLoopGroup - selector的创建\n\n从示例中可以看出 ServerBootstrap 启动的过程中需要两个 EventLoopGroup 实例，从职责上可以将其分为两种 boss 和 worker;前者主要负责客户端链接的接收以及派发到 worker, 后者主要负责客户端链接的读写请求操作。\n\n\n###### NioEventLoopGroup 的创建\n\n```java\n\n\tpublic NioEventLoopGroup(int nThreads) {\n\t\tthis(nThreads, null);\n\t}\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n\t\tthis(nThreads, threadFactory, SelectorProvider.provider());\n\t}\t\t\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider) {\n\t\tthis(nThreads, threadFactory, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);\n\t}\t\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) {\n\t\tsuper(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());\n\t}\n``` \n```java\nstatic {\n        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(\n                \"io.netty.eventLoopThreads\", NettyRuntime.availableProcessors() * 2));\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.eventLoopThreads: {}\", DEFAULT_EVENT_LOOP_THREADS);\n        }\n    }\n```\n```java\n\tprotected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {\n\t\tsuper(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);\n\t}\n```\n\n加载 MultithreadEventLoopGroup 类时，会先计算默认线程数其值为处理器个数的两倍。\n\n在看下父类MultithreadEventExecutorGroup的构造方法：\n\n```java\n\tprotected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) {\n        if (nThreads <= 0) {\n            throw new IllegalArgumentException(String.format(\"nThreads: %d (expected: > 0)\", nThreads));\n        }\n\n        if (threadFactory == null) {\n            threadFactory = newDefaultThreadFactory();\n        }\n\n        children = new SingleThreadEventExecutor[nThreads];\n\t\t// 创建 事件执行器的选择器\n        if (isPowerOfTwo(children.length)) {\n            chooser = new PowerOfTwoEventExecutorChooser();\n        } else {\n            chooser = new GenericEventExecutorChooser();\n        }\n\n        for (int i = 0; i < nThreads; i ++) {\n            boolean success = false;\n            try {\n\t\t\t// 创建 NioEventLoop\n                children[i] = newChild(threadFactory, args);\n                success = true;\n            } catch (Exception e) {\n                // TODO: Think about if this is a good exception type\n                throw new IllegalStateException(\"failed to create a child event loop\", e);\n            } finally {\n          \t\n\t\t\t}\t \n        }\n\t\t// 非核心代码省略\n    }\n```\n\nnewChild 是抽象方法由子类 NioEventLoopGroup 实现\n\n```java\n\tprotected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception {\n        return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0],\n            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);\n    }\n```\n\n从上述代码中可以看出 NioEventLoopGroup 构建过程中会按指定的线程数创建 NioEventLoop 实例并存储在 children 事件执行器数组中；同时创建了 chooser 实例，chooser 用于在新的客户端链接请求到达的时候从 children 数组中选取 eventLoop 的策略。\n\n###### NioEventLoop的创建\n\n先看下 NioEventLoop 的构造\n\n```java\nNioEventLoop(NioEventLoopGroup parent, ThreadFactory threadFactory, SelectorProvider selectorProvider,\n                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {\n        super(parent, threadFactory, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);\n        if (selectorProvider == null) {\n            throw new NullPointerException(\"selectorProvider\");\n        }\n        if (strategy == null) {\n            throw new NullPointerException(\"selectStrategy\");\n        }\n        provider = selectorProvider;\n        final SelectorTuple selectorTuple = openSelector();\n        // 创建 selector 选择器\n\t\tselector = selectorTuple.selector;\n        unwrappedSelector = selectorTuple.unwrappedSelector;\n        selectStrategy = strategy;\n    }\n```\n\n其父类构造如下：\n\n```java\n\tprotected SingleThreadEventExecutor(\n            EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks,\n            RejectedExecutionHandler rejectedHandler) {\n        if (threadFactory == null) {\n            throw new NullPointerException(\"threadFactory\");\n        }\n\n        this.parent = parent;\n        this.addTaskWakesUp = addTaskWakesUp;\n\t\t// 内部线程\n        thread = threadFactory.newThread(new Runnable() {\n            @Override\n            public void run() {\n               // 此处省略线程的具体执行 \n            }\n        });\n        threadProperties = new DefaultThreadProperties(thread);\n        this.maxPendingTasks = Math.max(16, maxPendingTasks);\n\t\t// 任务队列\n        taskQueue = newTaskQueue();\n        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n    }\n```\n\n```java\n\tprotected Queue<Runnable> newTaskQueue() {\n        return newTaskQueue(maxPendingTasks);\n    }\n\n\tprotected Queue<Runnable> newTaskQueue(int maxPendingTasks) {\n        return new LinkedBlockingQueue<Runnable>(maxPendingTasks);\n    }\n```\n\n从 NioEventLoop 的构造方法可以看出,　其内部包含了一个 thread 以及 taskQueue 并且绑定了一个 selector; taskQueue 用于存储内部执行的任务, thread 该线程主要用来执行 taskQueue 中的任务及处理客户端链接的请求。\n\n\t此时完成了 selector 选择器的创建,并将其绑定到 NioEventLoop 实例\n\n在完成了两个 NioEventLoopGroup 实例的创建之后　我们可以看出 Netty 内部线程模型大概如下：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnju1tz4auj30k106h3yg.jpg)\n\n##### NioServerSocketChannel 通道创建\n\nServerBootstrap 在完成 group, channel, handler 的配置之后调用 bind 完成服务端启动，让我们看下其实现:\n\n```java\n \tpublic ChannelFuture bind(int inetPort) {\n        return bind(new InetSocketAddress(inetPort));\n    }\n\n    public ChannelFuture bind(String inetHost, int inetPort) {\n        return bind(SocketUtils.socketAddress(inetHost, inetPort));\n    }\n\n    public ChannelFuture bind(InetAddress inetHost, int inetPort) {\n        return bind(new InetSocketAddress(inetHost, inetPort));\n    }\n\n    public ChannelFuture bind(SocketAddress localAddress) {\n        validate();\n        if (localAddress == null) {\n            throw new NullPointerException(\"localAddress\");\n        }\n        return doBind(localAddress);\n    }\n\n    private ChannelFuture doBind(final SocketAddress localAddress) {\n        final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel();\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n       \t// 暂时省略 \n    }\n```\n\n从上述代码中可以在 bind 过程中，先完成 channel 的注册及初始化其实现在 initAndRegister 方法中如下：\n\n```java\nfinal ChannelFuture initAndRegister() {\n        Channel channel = null;\n        try {\n\t\t\t// 创建 NioServerSocketChannel\n            channel = channelFactory().newChannel();\n\t\t\t// 初始化 channel\n            init(channel);\n        } catch (Throwable t) {\n            if (channel != null) {\n                // channel can be null if newChannel crashed (eg SocketException(\"too many open files\"))\n                channel.unsafe().closeForcibly();\n            }\n            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);\n        }\n\t\t// channel 注册\n        ChannelFuture regFuture = group().register(channel);\n        if (regFuture.cause() != null) {\n            if (channel.isRegistered()) {\n                channel.close();\n            } else {\n                channel.unsafe().closeForcibly();\n            }\n        }\n        return regFuture;\n    }\n```\n\n从 initAndRegister 方法中可以看出，该方法主要完成以下三件事:\n\n- NioServerSocketChannel 实例的创建\n- NioServerSocketChannel 的初始化\n- NioServerSocketChannel 的注册\n\n###### NioServerSocketChannel的创建\n\n先让我们回过头看下 ServerBootstrap 启动时配置 channel 方法：\n\n```java\n\tpublic B channel(Class<? extends C> channelClass) {\n        if (channelClass == null) {\n            throw new NullPointerException(\"channelClass\");\n        }\n        return channelFactory(new BootstrapChannelFactory<C>(channelClass));\n    }\n\n   \tpublic B channelFactory(ChannelFactory<? extends C> channelFactory) {\n        if (channelFactory == null) {\n            throw new NullPointerException(\"channelFactory\");\n        }\n        if (this.channelFactory != null) {\n            throw new IllegalStateException(\"channelFactory set already\");\n        }\n\n        this.channelFactory = channelFactory;\n        return self();\n    }\n```\n\n也就是说此时 channelFactory 实例为 BootstrapChannelFactory, 接下来我们看下其实现：\n\n```java\nprivate static final class BootstrapChannelFactory<T extends Channel> implements ChannelFactory<T> {\n        private final Class<? extends T> clazz;\n\n        BootstrapChannelFactory(Class<? extends T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T newChannel() {\n            try {\n                return clazz.getConstructor().newInstance();\n            } catch (Throwable t) {\n                throw new ChannelException(\"Unable to create Channel from class \" + clazz, t);\n            }\n        }\n    }\n```\n\n故 channelFactory.newChannel() 方法也就是创建指定了 channel class 的实例也就是 NioServerSocketChannel 实例，接下来看下其构造实现：\n\n```java\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) {\n        try {\n            return provider.openServerSocketChannel();\n        } catch (IOException e) {\n            throw new ChannelException(\n                    \"Failed to open a server socket.\", e);\n        }\n    }\n\n    private final ServerSocketChannelConfig config;\n\n    public NioServerSocketChannel() {\n        this(newSocket(DEFAULT_SELECTOR_PROVIDER));\n    }\n\n    public NioServerSocketChannel(SelectorProvider provider) {\n        this(newSocket(provider));\n    }\n\n    public NioServerSocketChannel(ServerSocketChannel channel) {\n        super(null, channel, SelectionKey.OP_ACCEPT);\n        config = new NioServerSocketChannelConfig(this, javaChannel().socket());\n    }\n```\n\n其父类 AbstractNioChannel AbstractChannel 构造方法如下：\n\n```java\nprotected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {\n        super(parent);\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false);\n        } catch (IOException e) {\n        }\n    }\n```\n\n```java\nprotected AbstractChannel(Channel parent) {\n        this.parent = parent;\n        unsafe = newUnsafe();\n        pipeline = newChannelPipeline();\n    }\n```\n\n从 NioServerSocketChannel 的构造方法看出其主要流程如下:\n\n- 通过 newSocket 方法创建了 ServerSocketChannel 实例并设置为非阻塞模式\n- 设置了待监听事件 OP_ACCEPT\n- 创建 unsafe 实例为 NioMessageUnsafe\n- 创建 pipeline 实例为 DefaultChannelPipeline\n\n\n\t此时完成了 nio 中的 ServerSocketChannel 的创建\n\n###### NioServerSocktChannel的初始化\n\ninit 为抽象方法由子类实现\n\n```java\nvoid init(Channel channel) throws Exception {\n        final Map<ChannelOption<?>, Object> options = options();\n        synchronized (options) {\n            setChannelOptions(channel, options, logger);\n        }\n\n        final Map<AttributeKey<?>, Object> attrs = attrs();\n        synchronized (attrs) {\n            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n                @SuppressWarnings(\"unchecked\")\n                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n                channel.attr(key).set(e.getValue());\n            }\n        }\n\n        ChannelPipeline p = channel.pipeline();\n\n        final EventLoopGroup currentChildGroup = childGroup;\n        final ChannelHandler currentChildHandler = childHandler;\n        final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n        synchronized (childOptions) {\n            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));\n        }\n        synchronized (childAttrs) {\n            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));\n        }\n\n        p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(final Channel ch) throws Exception {\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n\n                logger.info(\"ServerBootStrap init channel addLast ChannelInitializer init channel\");\n                ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n    }\n```\n\ninit 主要设置 channel 的 attr 和　options;并在 pipeline 中添加 ChannelInitializer handler\n\n###### NioServerSocketChannel的注册\n\n在完成 channel 的创建及初始化之后即调用 NioEventLoopGroup.register(channel) 方法完成 channel 的注册。\n\n```java\n\t@Override\n    public EventLoop next() {\n        return (EventLoop) super.next();\n    }\n\n    @Override\n    public ChannelFuture register(Channel channel) {\n        return next().register(channel);\n    }\n```\n\nnext() 方法是按照 chooser 选取策略从 NioEventLoopGroup 中获取一个 NioEventLoop 实例;跟踪 register 方法最终调用的是 unsafe.register 方法如下:\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n\t// ......\n\tAbstractChannel.this.eventLoop = eventLoop;\n\n\tif (eventLoop.inEventLoop()) {\n\t\tregister0(promise);\n\t} else {\n\t\ttry {\n\t\t\teventLoop.execute(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tregister0(promise);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (Throwable t) {\n\t   }\n\t}\n}\n\nprivate void register0(ChannelPromise promise) {\n\ttry {\n\t\t// ......\n\t\tboolean firstRegistration = neverRegistered;\n\t\tdoRegister();\n\n\t\tneverRegistered = false;\n\t\tregistered = true;\n\n\t\tpipeline.invokeHandlerAddedIfNeeded();\n\n\t\tsafeSetSuccess(promise);\n\t\tpipeline.fireChannelRegistered();\n\t\t\n\t\t// ......                \n\t} catch (Throwable t) {\n\t}\n}\n```\n\n调用了由子类实现的 doRegister() 方法如下：\n\n```java\n@Override\nprotected void doRegister() throws Exception {\n\tboolean selected = false;\n\tfor (;;) {\n\ttry {\n\t\t// ServerSocketChannel 注册到 selector\n\t\tselectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n\t\treturn;\n\t} catch (CancelledKeyException e) {\n\t\tif (!selected) {\n\t\t\t// Force the Selector to select now as the \"canceled\" SelectionKey may still be\n\t\t\t// cached and not removed because no Select.select(..) operation was called yet.\n\t\t\teventLoop().selectNow();\n\t\t\tselected = true;\n\t\t} else {\n\t\t\t// We forced a select operation on the selector before but the SelectionKey is still cached\n\t\t\t// for whatever reason. JDK bug ?\n\t\t\tthrow e;\n\t\t}\n\t}\n\t}\t\n}\n```\n\n其实现就是将 ServerSocketChannel 注册到 selector 上，并以自身NioServerSocketChannel 作为附件；\n\n\t注意：此时注册的时候　监听的事件　并不是 ACCEPT; 而是 0\n\n##### NioServerSocketChannel 端口绑定\n\n上文中在完成了 channel 的注册之后，我们在回头看 doBind 的实现:\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n        final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel();\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        promise.setFailure(cause);\n                    } else {\n                        promise.executor = channel.eventLoop();\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n    }\n```\n\n在 channel 注册完成后会执行 doBind0 \n\n```java\nprivate static void doBind0(\n            final ChannelFuture regFuture, final Channel channel,\n            final SocketAddress localAddress, final ChannelPromise promise) {\n        channel.eventLoop().execute(new Runnable() {\n            @Override\n            public void run() {\n                if (regFuture.isSuccess()) {\n                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n                } else {\n                    promise.setFailure(regFuture.cause());\n                }\n            }\n        });\n    }\n```\n\n会调用 channel.bind()　跟踪发现最终会调用 unsafe.bind() 方法如下：\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n            assertEventLoop();\n\t\t\t// ......\n            boolean wasActive = isActive();\n            try {\n\t\t\t// 绑定地址端口\n                doBind(localAddress);\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n\n            if (!wasActive && isActive()) {\n\t\t\t// 绑定端口成功之后　触发 pipeline handler 的 channel active 事件\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive();\n                    }\n                });\n            }\n\n            safeSetSuccess(promise);\n        }\n```\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n        if (PlatformDependent.javaVersion() >= 7) {\n            javaChannel().bind(localAddress, config.getBacklog());\n        } else {\n            javaChannel().socket().bind(localAddress, config.getBacklog());\n        }\n    }\n```\n\n\t此时完成了 ServerSocketChannel 的服务端地址绑定\n\n##### NioServerSocketChannel 注册 ACCEPT 事件\n\n上文中在完成 bind 操作之后，会触发 channelPipeline 的 channel active 事件　最终调用了 channel 的 doBeginRead 方法\n\n```java\nprotected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        if (inputShutdown) {\n            return;\n        }\n\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) {\n\t\t\t// 将 selectionKey 添加 ACCEPT 事件的监听\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n\t至此完成了 ServerSocketChannel 注册到 selector 并让其监听 ACCEPT　事件；服务端也启动完毕。\n\n##### 小结\n\n对Netty的服务端启动分析完之后，大概认识了其包含的一些组件以及各组件的作用\n\n- ServerBootstrap ：该类是服务端启动的引导类，其主要用于配置 Netty 的各个组件\n- NioEventLoopGroup : 该类用于管理 NioEventLoop , 并提供了 Selector 选择器创建的入口并将其绑定到 NioEventLoop 实例\n- NioEventLoop : 该类内部绑定了一个线程以及一个任务队列用于处理 register bind的相关任务及客户端处理（后续会详细分析）\n- NioServerSocketChannel : 该类是对 ServerSocketChannel 的一个包装其内部包含了 unsafe channelPipeline 实例\n- Unsafe : 该类提供了底层的 register bind write read 等操作\n- DefaultChannelPipeline : 该类是个双向链表结构，其主要作用是在通道注册链接　读写的操作之后会触发相应的事件\n\n\n\n\n","tags":["netty"]},{"title":"Jdk之ReentrantLock源码分析","url":"/2018/01/08/Jdk之ReentrantLock源码分析/","content":"\n##### 概述\n\nReentrantLock 是重入锁，也就是说支持重新进入的锁，也表示同一线程在获取锁之后可以再次获取锁。\n\n> synchronizer 关键字是隐式的支持重进入的，比如说采用 synchronizer 修饰的递归方法，在方法执行时，执行线程在获取锁之后依然可以连续多次获得锁。\n\nReentrantLock 支持获取锁时的公平和非公平性的选择，默认为非公平性锁。\n\n<!-- more -->\n\n##### 非公平锁\n\n\t非公平锁是指在获取锁的过程中，新进入的线程有机率比同步队列中线程优先获取锁。\n\n###### 锁的获取\n\n```java\nstatic final class NonfairSync extends Sync {\n        private static final long serialVersionUID = 7316153563782823691L;\n\t\t\n        final void lock() {\n\t\t\tif (compareAndSetState(0, 1))\n\t\t\t\t// 获取锁成功并绑定当前线程\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n\t\t\t\t// 再次获取锁\n                acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            return nonfairTryAcquire(acquires);\n        }\n    }\n```\n\n```java\n\tfinal boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (compareAndSetState(0, acquires)) {\n                    // 获取锁成功 绑定当前线程\n\t\t\t\t\tsetExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n\t\t\t\t// 当前线程为获取锁的线程 则累加同步状态值\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n```\n\n从代码中可以看出，重入锁新增了多次获取锁的处理逻辑：通过判断当前线程是否为获取锁的线程，如果时获取锁的线程则将同步状态值累加。\n\n###### 锁的释放\n\n```java\n\tprotected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) {\n\t\t\t\t// 只有同步状态值为0 才完成真正的释放\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n\n从 tryRelease 方法中可以看出，只有在同步状态值为0 才完成真正的释放返回 true;也就是说 若线程获取锁了 n 次，那么前 n-1 次均是释放失败也就是返回 false.\n\n##### 公平锁\n\n\t公平锁可以理解为在绝对时间上，先对锁进行获取的线程一定先被满足，也可以理解为等待时间最长的线程最优先获取锁。\n\n###### 锁的获取\n\n```java\n\tstatic final class FairSync extends Sync {\n        private static final long serialVersionUID = -3000897897090466540L;\n\n        final void lock() {\n            acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n从代码中可以看出公平锁在获取锁的过程多了一个判断条件 hasQueuedPredecessors(), 实现如下：\n\n```java\npublic final boolean hasQueuedPredecessors() {\n        // The correctness of this depends on head being initialized\n        // before tail and on head.next being accurate if the current\n        // thread is first in queue.\n        Node t = tail; // Read fields in reverse initialization order\n        Node h = head;\n        Node s;\n        return h != t &&\n            ((s = h.next) == null || s.thread != Thread.currentThread());\n    }\n```\n\nhasQueuedPredecessors 主要判断是否有其他线程等待获取锁的时间要比当前线程长，也即是当前同步队列的头节点的后驱节点所绑定的线程是否为当前线程；也可以理解为新进入的线程只有在同步队列上的等待线程均处理完毕才可以获取锁，否则会加入到同步队列中。\n\n###### 锁的释放\n\n与公平锁的释放一样。\n\n##### 公平锁与非公平锁对性能的影响\n\n- 公平锁保证了锁的获取按照 FIFO 原则，但会造成大量线程的切换\n- 非公平锁可能会造成线程\"饥饿\"的现象（也就是线程长时间获取不到锁　一直处于阻塞状态），但极少的线程切换会保证更大的吞吐量。\n","tags":["jdk"]},{"title":"zookeeper源码阅读之watch","url":"/2017/12/22/zookeeper源码阅读之watch/","content":"#### watcher 流程概述\n\n\twatcher 用来客户端监听某一节点的特性变化，执行对应的操作. 从下图可以看出 watcher 的流程主要包括:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmpmv1leuxj30tn0gjwff.jpg)\n\n> - watcher 注册, 包括客户端注册, 服务端的注册\n> - watcher 触发\n> - watcher 执行\n\n<!-- more -->\n\n#### watcher 注册\n\n\t本文我们以 zookeeper.getData 操作为例，对 watcher 的注册流程就行说明。\n\n##### watcher 客户端注册\n\t\n\tgetData api　如下:\n\n```java\npublic byte[] getData(final String path, Watcher watcher, Stat stat)\n\t\tthrows KeeperException, InterruptedException\n{\n\t\tfinal String clientPath = path;\n\t\tPathUtils.validatePath(clientPath);\n\n\t\t// the watch contains the un-chroot path\n\t\tWatchRegistration wcb = null;\n\t\tif (watcher != null) {\n\t\t\t\t// 定义 watcher 注册\n\t\t\t\twcb = new DataWatchRegistration(watcher, clientPath);\n\t\t}\n\n\t\tfinal String serverPath = prependChroot(clientPath);\n\n\t\tRequestHeader h = new RequestHeader();\n\t\th.setType(ZooDefs.OpCode.getData);\n\t\tGetDataRequest request = new GetDataRequest();\n\t\trequest.setPath(serverPath);\n\t\t// watcher 不为空的时候　设置为 true\n\t\trequest.setWatch(watcher != null);\n\t\tGetDataResponse response = new GetDataResponse();\n\t\tReplyHeader r = cnxn.submitRequest(h, request, response, wcb);\n\t\tif (r.getErr() != 0) {\n\t\t\t\tthrow KeeperException.create(KeeperException.Code.get(r.getErr()),\n\t\t\t\t\t\t\t\tclientPath);\n\t\t}\n\t\tif (stat != null) {\n\t\t\t\tDataTree.copyStat(response.getStat(), stat);\n\t\t}\n\t\treturn response.getData();\n}\n\n```\n\t在完成本次请求，处理返回 packet 的时候, 会调用 ClinetCnxn.finishPacket(packet) 方法\n\n```java\nprivate void finishPacket(Packet p) {\n\tint err = p.replyHeader.getErr();\n\tif (p.watchRegistration != null) {\n\t\t\t// 调用 wwatcher　register; 处理正常的时候 err 值为 0; 可参考类 FinalRequestProcessor\n\t\t\tp.watchRegistration.register(err);\n\t}\n\t// 省略\n}\n```\n\t以下为 watchRegistration.register 源码:\n\n```java\npublic void register(int rc) {\n\tif (shouldAddWatch(rc)) {\n\t\t// client　下允许对多个路径设置监听\n\t\tMap<String, Set<Watcher>> watches = getWatches(rc);\n\t\tsynchronized(watches) {\n\t\t\t\tSet<Watcher> watchers = watches.get(clientPath);\n\t\t\t\tif (watchers == null) {\n\t\t\t\t\t\t//　同一路径下允许有多个 watcher　\n\t\t\t\t\t\twatchers = new HashSet<Watcher>();\n\t\t\t\t\t\twatches.put(clientPath, watchers);\n\t\t\t\t}\n\t\t\t\twatchers.add(watcher);\n\t\t}\n\t}\n}\n\nprotected boolean shouldAddWatch(int rc) {\n\t\treturn rc == 0;\n}\n\nprotected Map<String, Set<Watcher>> getWatches(int rc) {\n\t\treturn watchManager.dataWatches;\n}\n```\n\n> 从以上代码中可以看出, 客户端在定义 watcher 之后会将其与 path 绑定添加到 ZKWatchManager.dataWatches; 从而完成 watcher 的注册。\n\n##### watcher 服务端注册\n\nserver 在接收到客户端请求执行 FinalRequestProcessor.processRequest 方法过程中，会执行对 watcher　的注册，这里同样以 getData 操作的代码进行分析:\n\n```java\n\tcase OpCode.getData: {\n\t \tlastOp = \"GETD\";\n\t \tGetDataRequest getDataRequest = new GetDataRequest();\n\t \tByteBufferInputStream.byteBuffer2Record(request.request,\n\t\t\t\t\t getDataRequest);\n\t \tDataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());\n\t\tif (n == null) {\n\t\t\t throw new KeeperException.NoNodeException();\n\t \t}\n\t \tPrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),\n\t\t\t\t\t ZooDefs.Perms.READ,\n\t\t\t\t\t request.authInfo);\n\t \tStat stat = new Stat();\n\t\t// 若 client 请求的时候 watch 为 true,　则将 cnxn　作为参数\n\t\t// cnxn 为每个客户端请求链接的时候　针对 selectorKey 绑定的 NIOServerCnxn 实例\n\t \tbyte b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,\n\t\t\t\t\t getDataRequest.getWatch() ? cnxn : null);\n\t \trsp = new GetDataResponse(b, stat);\n\t \tbreak;\n\t}\n\n```\n\n从上面代码中  zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDataRequest.getWatch() ? cnxn : null); 跟踪发现其最后调用了 WatchManager.addWatch(path, watcher) 方法.\n\n```java\n// 注意 : 此时传递的参数 watcher 并不是客户端定义的 watcher 实例，而是服务端存储的与客户端绑定的\n// NIOServerCnxn 实例；因为 NIOServerCnxn 实现了 watcher 接口;\n// watchTable 用来存储 path　与　watcher　的关系; 也可以表示为 多个客户端监听了同一节点\n// watch2Paths　用来存储 watcher 与 path 的关系; 也可以表示为 每个客户端下监听了哪些节点\nsynchronized void addWatch(String path, Watcher watcher) {\n\t\tHashSet<Watcher> list = watchTable.get(path);\n\t\tif (list == null) {\n\t\t\t\t// don't waste memory if there are few watches on a node\n\t\t\t\t// rehash when the 4th entry is added, doubling size thereafter\n\t\t\t\t// seems like a good compromise\n\t\t\t\tlist = new HashSet<Watcher>(4);\n\t\t\t\twatchTable.put(path, list);\n\t\t}\n\t\tlist.add(watcher);\n\n\t\tHashSet<String> paths = watch2Paths.get(watcher);\n\t\tif (paths == null) {\n\t\t\t\t// cnxns typically have many watches, so use default cap here\n\t\t\t\tpaths = new HashSet<String>();\n\t\t\t\twatch2Paths.put(watcher, paths);\n\t\t}\n\t\tpaths.add(path);\n}\n\n```\n> 从上面代码中可以看出,服务端在处理完客户端请求的时候　若客户端设置了 watcher 则会将其添加到 watchmanager 的 watchTable 中；至此服务端针对 watcher 的注册完毕.\n\n#### watcher 触发\n\n针对 watcher 触发的操作，这里以 setData api 为例说明。此时假设某个客户端执行了 setData 操作, 服务端在处理客户端请求的时候, 在调用 FinalRequestProcessor.processRequest　方法的时候会调用 \n```java\n\tzookeeperServer.processTxn(request);\n```\n\n最终会调用 DataTree.processTxn() 方法，此处摘取针对 setData 的操作如下　：\n```java\ncase OpCode.setData:\n\tSetDataTxn setDataTxn = (SetDataTxn) txn;\n\trc.path = setDataTxn.getPath();\n\trc.stat = setData(setDataTxn.getPath(), setDataTxn\n\t\t\t\t.getData(), setDataTxn.getVersion(), header\n\t\t\t\t.getZxid(), header.getTime());\n\tbreak;\n```\n\n```java\npublic Stat setData(String path, byte data[], int version, long zxid,\n\t\t\t\tlong time) throws KeeperException.NoNodeException {\n\t\tStat s = new Stat();\n\t\tDataNode n = nodes.get(path);\n\t\tif (n == null) {\n\t\t\t\tthrow new KeeperException.NoNodeException();\n\t\t}\n\t\tbyte lastdata[] = null;\n\t\tsynchronized (n) {\n\t\t\t\tlastdata = n.data;\n\t\t\t\tn.data = data;\n\t\t\t\tn.stat.setMtime(time);\n\t\t\t\tn.stat.setMzxid(zxid);\n\t\t\t\tn.stat.setVersion(version);\n\t\t\t\tn.copyStat(s);\n\t\t}\n\t\t// now update if the path is in a quota subtree.\n\t\tString lastPrefix = getMaxPrefixWithQuota(path);\n\t\tif(lastPrefix != null) {\n\t\t\t\t// 更新节点数据\n\t\t\t\tthis.updateBytes(lastPrefix, (data == null ? 0 : data.length)\n\t\t\t\t\t\t\t\t- (lastdata == null ? 0 : lastdata.length));\n\t\t}\n\t\t// 触发该节点下的 watcher\n\t\tdataWatches.triggerWatch(path, EventType.NodeDataChanged);\n\t\treturn s;\n}\n\n```\n\n从上述代码中可以看出, 服务端在完成对节点数据更新之后调用了 watcher.triggerWatch(); 该方法接收两个参数一个为节点path, 一个为事件类型\n\n```java\nSet<Watcher> triggerWatch(String path, EventType type, Set<Watcher> supress) {\n\t\tWatchedEvent e = new WatchedEvent(type,\n\t\t\t\t\t\tKeeperState.SyncConnected, path);\n\t\tHashSet<Watcher> watchers;\n\t\tsynchronized (this) {\n\t\t\t\twatchers = watchTable.remove(path);\n\t\t\t\tif (watchers == null || watchers.isEmpty()) {\n\t\t\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tZooTrace.logTraceMessage(LOG,\n\t\t\t\t\t\t\t\t\t\t\t\tZooTrace.EVENT_DELIVERY_TRACE_MASK,\n\t\t\t\t\t\t\t\t\t\t\t\t\"No watchers for \" + path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfor (Watcher w : watchers) {\n\t\t\t\t\t\tHashSet<String> paths = watch2Paths.get(w);\n\t\t\t\t\t\tif (paths != null) {\n\t\t\t\t\t\t\t\tpaths.remove(path);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tfor (Watcher w : watchers) {\n\t\t\t\tif (supress != null && supress.contains(w)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tw.process(e);\n\t\t}\n\t\treturn watchers;\n}\n\n```\n\n从以上代码中看出在触发 watcher 的时候，会先从 watchManager 中的 watchTable 获取指定 path 的 watcher 并将其从集合中移除（从此处我们可以看出客户端定义的 watcher　若未作处理的话　将只会监听一次）。在查找到 watcher 之后将会调用 watcher.process 即执行 watcher.\n\n#### watcher 执行\n\n在服务端触发 watcher　之后，会调用 watcher.process　方法，此时 watcher 的实例为 NIOServerCnxn;接下来我们看下 NIOSserverCnxn 的 process　方法:\n\n```java \npublic void process(WatchedEvent event) {\n\t\tReplyHeader h = new ReplyHeader(-1, -1L, 0);\n\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\tZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n\t\t\t\t\t\t\t\t\"Deliver event \" + event + \" to 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(this.sessionId)\n\t\t\t\t\t\t\t\t+ \" through \" + this);\n\t\t}\n\n\t\t// Convert WatchedEvent to a type that can be sent over the wire\n\t\tWatcherEvent e = event.getWrapper();\n\n\t\tsendResponse(h, e, \"notification\");\n}\n\n```\n\n从上面代码中可以看出服务端向客户端发出了 tag 为 \"notification\" 的响应；　接下来我们看下客户端如何处理该响应:\n在 ClientCnxn 下的 SendThread.readResponse 方法中我们可以看到针对 watcher　的处理如下：\n```java\nif (replyHdr.getXid() == -1) {\n\t\t// -1 means notification\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Got notification sessionid:0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId));\n\t\t}\n\t\t// 从 response 中反序列化\n\t\tWatcherEvent event = new WatcherEvent();\n\t\tevent.deserialize(bbia, \"response\");\n\n\t\t// convert from a server path to a client path\n\t\tif (chrootPath != null) {\n\t\t\t\tString serverPath = event.getPath();\n\t\t\t\tif(serverPath.compareTo(chrootPath)==0)\n\t\t\t\t\t\tevent.setPath(\"/\");\n\t\t\t\telse if (serverPath.length() > chrootPath.length())\n\t\t\t\t\t\tevent.setPath(serverPath.substring(chrootPath.length()));\n\t\t\t\telse {\n\t\t\t\t\t\tLOG.warn(\"Got server path \" + event.getPath()\n\t\t\t\t\t\t\t\t\t\t+ \" which is too short for chroot path \"\n\t\t\t\t\t\t\t\t\t\t+ chrootPath);\n\t\t\t\t}\n\t\t}\n\n\t\tWatchedEvent we = new WatchedEvent(event);\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Got \" + we + \" for sessionid 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId));\n\t\t}\n\t\t// 将 watchedEvent 交由 eventThread　处理\n\t\teventThread.queueEvent( we );\n\t\treturn;\n}\n\n```\n```java\nprivate void queueEvent(WatchedEvent event,\n\t\t\t\tSet<Watcher> materializedWatchers) {\n\t\tif (event.getType() == EventType.None\n\t\t\t\t\t\t&& sessionState == event.getState()) {\n\t\t\t\treturn;\n\t\t}\n\t\tsessionState = event.getState();\n\t\tfinal Set<Watcher> watchers;\n\t\tif (materializedWatchers == null) {\n\t\t\t\t// materialize the watchers based on the event\n\t\t\t\t// 从 ZKWatchManager 中获取 path　的 watcher\n\t\t\t\twatchers = watcher.materialize(event.getState(),\n\t\t\t\t\t\t\t\tevent.getType(), event.getPath());\n\t\t} else {\n\t\t\t\twatchers = new HashSet<Watcher>();\n\t\t\t\twatchers.addAll(materializedWatchers);\n\t\t}\n\t\tWatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);\n\t\t// queue the pair (watch set & event) for later processing\n\t\twaitingEvents.add(pair);\n}\n\n```\n\n从上面代码看出 客户端在处理 watcher　通知的时候会将其封装为 WatcherSetEventPair 对象并添加到 waitingEvents　队列中此时会唤醒阻塞在队列的操作，也即 eventThread 的 run 方法，如下：\n\n```java\npublic void run() {\n\t\ttry {\n\t\tisRunning = true;\n\t\twhile (true) {\n\t\t\t\tObject event = waitingEvents.take();\n\t\t\t\tif (event == eventOfDeath) {\n\t\t\t\t\t\twasKilled = true;\n\t\t\t\t} else {\n\t\t\t\t\t\tprocessEvent(event);\n\t\t\t\t}\n\t\t\t\tif (wasKilled)\n\t\t\t\t\t\tsynchronized (waitingEvents) {\n\t\t\t\t\t\t\t\tif (waitingEvents.isEmpty()) {\n\t\t\t\t\t\t\t\t\t\tisRunning = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\t\tLOG.error(\"Event thread exiting due to interruption\", e);\n\t\t}\n\n\t\tLOG.info(\"EventThread shut down for session: 0x{}\",\n\t\t\t\t\t\tLong.toHexString(getSessionId()));\n}\n\n```\n截取 processEvent 方法中针对 watcher 的处理\n```java \nf (event instanceof WatcherSetEventPair) {\n\t\t// each watcher will process the event\n\t\tWatcherSetEventPair pair = (WatcherSetEventPair) event;\n\t\tfor (Watcher watcher : pair.watchers) {\n\t\t\t\ttry {\n\t\t\t\t\t\t// 执行 watcher\n\t\t\t\t\t\twatcher.process(pair.event);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLOG.error(\"Error while calling watcher \", t);\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n从上面代码看出当 waitingEvents　队列中存在待处理的 watcher 时将会依次调用；至此完成 watcher的执行；到此完成对 zookeeper　watcher　的分析.\n\n","tags":["zookeeper"]},{"title":"NIO selector的wakeup","url":"/2017/12/21/NIO-selector的wakeup/","content":"\n###### wakeUp\n\n> 某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。\n如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。\n\n引用至 http://ifeve.com/selectors/\n<!-- more -->\n###### 测试\n\n```java\npublic class App \n{\n\t\tprivate Selector selector;\n\n\t\tpublic void start () throws IOException {\n\t\t\t\t// 开启选择器 selector\n\t\t\t\tselector = Selector.open();\n\n\t\t\t\t// 开启服务端 socket 通道\n\t\t\t\tServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\t\t\t\t// 设置为非阻塞\n\t\t\t\tserverSocketChannel.configureBlocking(false);\n\t\t\t\t// 绑定服务端端口\n\t\t\t\tserverSocketChannel.socket().bind(new InetSocketAddress(8888));\n\t\t\t\t// 通道注册到选择器上　并监听　接收客户端事件\n\t\t\t\tserverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\t\t\t\t// 因 selector.select 会阻塞当前线程　故异步处理\n\t\t\t\tnew Thread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tSystem.out.println(\"select 前执行\");\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tselector.select();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSystem.out.println(\"select 后执行\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}).start();\n\n\t\t}\n\n\t\tpublic void wakeup () {\n\t\t\t\tSystem.out.println(\"开始唤醒\");\n\t\t\t\tselector.wakeup();\n\t\t}\n\n\t\tpublic static void main( String[] args ) throws IOException, InterruptedException {\n\t\t\t\tfinal App app = new App();\n\t\t\t\tapp.start();\n\n\t\t\t\tThread thread = new Thread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapp.wakeup();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthread.start();\n\n\t\t\t\tthread.join();\n\t\t}\n}\n\n```\n\n\n```java\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\n```\n\n从执行结果可以看出 在调用了 wakeup() 方法之后，即可唤醒阻塞在 select() 上的操作　也即 select() 方法会立马返回.\n\n","tags":["NIO"]},{"title":"zookeeper源码阅读之client","url":"/2017/12/15/zookeeper源码阅读之client/","content":"\n#### zookeeper client 启动流程\n> 先看下 zookeeper client 相关类图\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4gu34pbj30vp0g1t9p.jpg)\n\n##### 执行 zkCli.sh 脚本时, 会运行 org.apache.zookeeper.ZookeeperMain 类主方法.\n```java\npublic static void main(String args[])\n\t\tthrows KeeperException, IOException, InterruptedException\n{\n\tZooKeeperMain main = new ZooKeeperMain(args);\n\tmain.run();\n}\n\n```\n```java\npublic ZooKeeperMain(String args[]) throws IOException, InterruptedException {\n\t// 启动参数解析\n\tcl.parseOptions(args);\n\tSystem.out.println(\"Connecting to \" + cl.getOption(\"server\"));\n\t// 链接 zookeeper server\n\tconnectToZK(cl.getOption(\"server\"));\n}\n```\n\n> 从代码中可以看出 client 启动时首先构造 ZookeeperMain　对象实例,构造过程中会先解析 client 的启动参数（若未指定任何参数将会默认链接本机 2181 端口 zookeeper server）\n<!-- more -->\n##### 通过调用 connectToZK 链接 zookeeper server\n```java\nprotected void connectToZK(String newHost) throws InterruptedException, IOException {\n\tif (zk != null && zk.getState().isAlive()) {\n\t\t// 若已创建 zookeeper 对象并且状态为激活　则关闭重新创建\n\t\tzk.close();\n\t}\n\thost = newHost;\n\tboolean readOnly = cl.getOption(\"readonly\") != null;\n\tif (cl.getOption(\"secure\") != null) {\n\t\tSystem.setProperty(ZKClientConfig.SECURE_CLIENT, \"true\");\n\t\tSystem.out.println(\"Secure connection is enabled\");\n\t}\n\t// 构造 Zookeeper 对象实例\n\tzk = new ZooKeeper(host,Integer.parseInt(cl.getOption(\"timeout\")),\n\t\t\t\tnew MyWatcher(), readOnly);\n}\n\n```\n##### 创建 Zookeeper 对象实例\n```java\n// connectString 是形如 host:port,host:port 的字符串片段\npublic ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,\n\t\t\t\tboolean canBeReadOnly, HostProvider aHostProvider,\n\t\t\t\tZKClientConfig clientConfig) throws IOException {\n\n\tif (clientConfig == null) {\n\t\t// 创建 ZKClient Config 对象\n\t\tclientConfig = new ZKClientConfig();\n\t}\n\tthis.clientConfig = clientConfig;\n\twatchManager = defaultWatchManager();\n\twatchManager.defaultWatcher = watcher;\n\tConnectStringParser connectStringParser = new ConnectStringParser(\n\t\t\t\tconnectString);\n\thostProvider = aHostProvider;\n\t// 创建 ClientCnxn 对象\n\tcnxn = new ClientCnxn(connectStringParser.getChrootPath(),\n\t\t\t\thostProvider, sessionTimeout, this, watchManager,\n\t\t\t\tgetClientCnxnSocket(), canBeReadOnly);\n\tcnxn.start();\n}\n// 创建 ClientCnxnSocket对象 默认为 ClientCnxnSocketNIO 对象\nprivate ClientCnxnSocket getClientCnxnSocket() throws IOException {\n\t\tString clientCnxnSocketName = getClientConfig().getProperty(\n\t\t\t\t\t\tZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);\n\t\tif (clientCnxnSocketName == null) {\n\t\t\t\tclientCnxnSocketName = ClientCnxnSocketNIO.class.getName();\n\t\t}\n\t\ttry {\n\t\t\t\tConstructor<?> clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);\n\t\t\t\tClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());\n\t\t\t\treturn clientCxnSocket;\n\t\t} catch (Exception e) {\n\t\t\t\tIOException ioe = new IOException(\"Couldn't instantiate \"\n\t\t\t\t\t\t\t\t+ clientCnxnSocketName);\n\t\t\t\tioe.initCause(e);\n\t\t\t\tthrow ioe;\n\t\t}\n}\n```\n> 从代码中看出 Zookeeper 关联了 ClientCnxn 对象, 在创建了 ClientCnxn 对象实例之后调用了 cnxn.start() 方法。\n##### 创建 ClientCnxn 对象实例\n\n```java\npublic ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,\n\t\t\t\tClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,\n\t\t\t\tlong sessionId, byte[] sessionPasswd, boolean canBeReadOnly) {\n\t\tthis.zooKeeper = zooKeeper;\n\t\tthis.watcher = watcher;\n\t\tthis.sessionId = sessionId;\n\t\tthis.sessionPasswd = sessionPasswd;\n\t\tthis.sessionTimeout = sessionTimeout;\n\t\tthis.hostProvider = hostProvider;\n\t\tthis.chrootPath = chrootPath;\n\t\t// 计算连接超时时间　读数据超时时间\n\t\tconnectTimeout = sessionTimeout / hostProvider.size();\n\t\treadTimeout = sessionTimeout * 2 / 3;\n\t\treadOnly = canBeReadOnly;\n\t\t// 创建了 SendThread EventThread　线程实例\n\t\tsendThread = new SendThread(clientCnxnSocket);\n\t\teventThread = new EventThread();\n\t\tthis.clientConfig=zooKeeper.getClientConfig();\n}\n\npublic void start() {\n\t\tsendThread.start();\n\t\teventThread.start();\n}\n```\n> 从 start 方法中可以看出分别启动了 sendThread eventThread　两个线程。\n\n##### SendThread 线程的构造及启动\n```java\nSendThread(ClientCnxnSocket clientCnxnSocket) {\n\t\tsuper(makeThreadName(\"-SendThread()\"));\n\t\tstate = States.CONNECTING;\n\t\tthis.clientCnxnSocket = clientCnxnSocket;\n\t\tsetDaemon(true);\n}\n\n```\n> SendThread 是 ClientCnxn 的内部类, 创建该线程实例时会将 ClientCnxn 的状态由默认状态(未连接)改为连接中,并赋值 clientCnxnSocket。\n\n###### ClientCnxn 的主要成员变量说明\n> 在了解 sendThread 线程的启动过程有必要先了解一下关于 SendThread 和 ClientCnxn 的相关成员变量。\n\n| 变量名 | 描述 |\n|--------|------|\n| state  | 客户端连接状态 |\n| outgoingQueue | 存储需要被发送出去的报文的队列 |\n| pendingQueue | 存储已经发送等待响应结果的队列 |\n\n##### SendThread 线程启动\n```java\npublic void run() {\n\t// 将 sendThread sessionId outgoingQueue 绑定到的 clientCnxnSocketNIO\n\tclientCnxnSocket.introduce(this, sessionId, outgoingQueue);\n\tclientCnxnSocket.updateNow();\n\tclientCnxnSocket.updateLastSendAndHeard();\n\tint to;\n\tlong lastPingRwServer = Time.currentElapsedTime();\n\tfinal int MAX_SEND_PING_INTERVAL = 10000; //10 seconds\n\twhile (state.isAlive()) {\n\t\ttry {\n\t\t\tif (!clientCnxnSocket.isConnected()) {\n\t\t\t\t// don't re-establish connection if we are closing\n\t\t\t\tif (closing) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 如果 clientCnxnSocketNIO 未连接　则开始连接\n\t\t\t\tstartConnect();\n\t\t\t\tclientCnxnSocket.updateLastSendAndHeard();\n\t\t\t}\t\n\n\t\t\t\tif (state.isConnected()) {\n\t\t\t\t\t\t// determine whether we need to send an AuthFailed event.\n\t\t\t\t\t\tif (zooKeeperSaslClient != null) {\n\t\t\t\t\t\t\t// ssl client　的处理此处省略\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = readTimeout - clientCnxnSocket.getIdleRecv();\n\t\t\t\t} else {\n\t\t\t\t\t\tto = connectTimeout - clientCnxnSocket.getIdleRecv();\n\t\t\t\t}\n\n\t\t\t\tif (to <= 0) {\n\t\t\t\t\t\tString warnInfo;\n\t\t\t\t\t\twarnInfo = \"Client session timed out, have not heard from server in \"\n\t\t\t\t\t\t\t\t+ clientCnxnSocket.getIdleRecv()\n\t\t\t\t\t\t\t\t+ \"ms\"\n\t\t\t\t\t\t\t\t+ \" for sessionid 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId);\n\t\t\t\t\t\tLOG.warn(warnInfo);\n\t\t\t\t\t\tthrow new SessionTimeoutException(warnInfo);\n\t\t\t\t}\n\t\t\t\tif (state.isConnected()) {\n\t\t\t\t\t\t//1000(1 second) is to prevent race condition missing to send the second ping\n\t\t\t\t\t\t//also make sure not to send too many pings when readTimeout is small \n\t\t\t\t\t\tint timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - \n\t\t\t\t\t\t\t\t((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n\t\t\t\t\t\t//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n\t\t\t\t\t\tif (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n\t\t\t\t\t\t\t\t// 发送心跳\n\t\t\t\t\t\t\t\tsendPing();\n\t\t\t\t\t\t\t\tclientCnxnSocket.updateLastSend();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (timeToNextPing < to) {\n\t\t\t\t\t\t\t\t\t\tto = timeToNextPing;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we are in read-only mode, seek for read/write server\n\t\t\t\tif (state == States.CONNECTEDREADONLY) {\n\t\t\t\t\t\tlong now = Time.currentElapsedTime();\n\t\t\t\t\t\tint idlePingRwServer = (int) (now - lastPingRwServer);\n\t\t\t\t\t\tif (idlePingRwServer >= pingRwTimeout) {\n\t\t\t\t\t\t\t\tlastPingRwServer = now;\n\t\t\t\t\t\t\t\tidlePingRwServer = 0;\n\t\t\t\t\t\t\t\tpingRwTimeout =\n\t\t\t\t\t\t\t\t\t\tMath.min(2*pingRwTimeout, maxPingRwTimeout);\n\t\t\t\t\t\t\t\tpingRwServer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = Math.min(to, pingRwTimeout - idlePingRwServer);\n\t\t\t\t}\n\n\t\t\t\tclientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n\t\t} catch (Throwable e) {\n\t\t\t// 异常处理的部分省略...\t\n\t\t}\n\t\t}\n\t\tsynchronized (state) {\n\t\t\t\t// When it comes to this point, it guarantees that later queued\n\t\t\t\t// packet to outgoingQueue will be notified of death.\n\t\t\t\tcleanup();\n\t\t}\n\t\tclientCnxnSocket.close();\n\t\tif (state.isAlive()) {\n\t\t\t\teventThread.queueEvent(new WatchedEvent(Event.EventType.None,\n\t\t\t\t\t\t\t\t\t\tEvent.KeeperState.Disconnected, null));\n\t\t}\n\t\tZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),\n\t\t\t\t\t\t\"SendThread exited loop for session: 0x\"\n\t\t\t\t\t\t+ Long.toHexString(getSessionId()));\n}\n```\n>  从代码中可以看出 sendThread 主要做以下事情\n> - 创建客户端连接\n> - 发送心跳\n> - 发送消息 (终端输入的指令)\n\n> 下面将针对上面三种流程分析\n\n###### 客户端连接创建流程\n\n> 先大概看下此流程活动图　如下:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4i5lp6zj30yg0oa77g.jpg)\n\n> - sendThread 轮询过程中　先判断 clientCnxnSocket 是否已连接；若未连接则调用 sendThread.startConnect() 将 ClientCnxn.state 的状态改为 \"连接中\", 接下来同步调用 clientCnxnSocket.connect 完成客户端 socket 的创建及注册到 selector 并监听连接事件\n> - 上述操作完成后会调用 clientCnxnSocket.doTransport (), 该方法主要处理 selector 选择器上就绪的通道事件.\n> - 当客户端 socket 连接就绪的时候会调用 sendThread.primeConnection() 准备连接方法，该方法 ConnectionRequet　的 Packet　并将其添加到 outgoingQueue　对列中，接下来调用 clientCnxnSocket.connectionPrimed 该方法主要告知 socket　准备好连接了 此时客户端在 selector 上注册读写事件 (此时会触发通道的写就绪事件)\n> - 当客户端 socket 写就绪的时候会调用 clientCnxnSocket.findSendablePacket 该方法从 outgoingQueue 队列中获取待发送的 Packet , 最后执行 socket.write() 发送消息(此时会触发通道的读就绪事件)\n> - 当客户端 socket 读就绪的时候判断 initialized 是否为 true，若为 false 说明执行连接初始化会调用 sendThread.onConnected 更改客户端状态为 \"已连接\"，　继续注册监听客户端的读写事件\n\n###### 客户端心跳流程\n> 心跳流程如下：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4jaf9ooj30ro0l640z.jpg)\n\n> - sendThread 轮询过程中　判断 state 是否为 \"已连接\"; 若已连接判断是否满足心跳条件, 调用 sendPing 创建心跳 packet　header xid = -2; 接下来将 packet　添加到 outgoingQueue　队列中并调用 clientCnxnSocket.packetAddedd　最后唤醒阻塞在 selector.select 上的操作\n> - 当客户端 socket 写就绪的时候调用 findSendablePacket 获取待发送的 packet 最后调用 socket.write 执行发送\n> - 当客户端 socket 读就绪的时候调用 sendThread.readResponse 解析服务端的响应结果, 通过获取 response heaher xid 判断 xid == -2 ;　若为 -2 则打印心跳返回日志返回，　此时一次心跳结束\n\n###### 客户端终端发送指令流程\n\n> 发送指令流程图如下:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4k6ka0bj30ts0h8gn8.jpg)\n\n> - ZookeeperMain 构建完成后会调用 run　方法，等待用户输入\n> - 输入指令后会相应调用 executeLine, processCmd, processZKCmd 通过解析参数获取相应的 CliCommand\n> - 此处采用了命令模式 内置了各种 CliCommand 对应客户端相应的操作，包括(CreateCommand, GetCommand, SetCommand ....）; 获取对应的命令后，调用 parse, exec　方法执行命令\n> - 执行命令会调用 zookeeper 对应的操作(create, getData, setData)，在内部会调用 ClientCnxn.submitRequest 方法\n> - 在 clientCnxn.submitRequest　方法中会调用 queuePacket　创建 packet　并将其添加到队列中，接着唤醒 clientCnxnSocketNIO 的 selector.select 操作；后续操作就是读写就绪事件的处理与心跳流程类似。\n\n\n至此 zookeeper client 的相关流程介绍完毕　细节的地方后续在处理.\n\n\n"},{"title":"NIO之粘包拆包处理","url":"/2017/12/14/NIO之粘包拆包处理/","content":"\n#### 概述\n\n> 我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。\n\n#### 粘包拆包的原因\n\n> 关于 tcp 传输过程中，发生粘包拆包的原因及表现形式可参考网上的一篇[博客](https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/); 这里就不在说明.\n\n#### 粘包拆包的解决方法\n\n> 本文给出针对自定义消息报文格式，通过在消息头部添加消息载体长度来处理\n<!-- more -->\n##### 实现方式\n\n###### 消息内容包装\n\n```java\npublic class PacketWrapper {\n\n\t\t// 消息有效长度\n\t\tprivate int length;\n\t\t// 消息的有效载体\n\t\tprivate byte[] payload;\n\n\t\tpublic PacketWrapper(String payload) {\n\t\t\t\tthis.payload = payload.getBytes();\n\t\t\t\tthis.length = this.payload.length;\n\t\t}\n\n\t\tpublic PacketWrapper(byte[] payload) {\n\t\t\t\tthis.payload = payload;\n\t\t\t\tthis.length = this.payload.length;\n\t\t}\n\n\t\t// 返回包装后的字节数组\n\t\tpublic byte[] getBytes() {\n\t\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(this.length + 4);\n\t\t\t\tbyteBuffer.putInt(this.length);\n\t\t\t\tbyteBuffer.put(payload);\n\t\t\t\treturn byteBuffer.array();\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor (byte b : getBytes()) {\n\t\t\t\t\t\tsb.append(String.format(\"0x%02X \", b));\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t}\n}\n\n```\n\n###### 消息报文的解码\n\n```java\n\npublic class NioDecodeHandler {\n\n    private static Logger log = Logger.getLogger(NioDecodeHandler.class);\n\n    private final int HEAD_LENGTH = 4;\n\n    protected ByteBuffer lastReadBuffer = null;\n\n    public void decode (SocketChannel socketChannel) {\n        // 从通道中读取内容\n\t\tByteBuffer readByteBuffer = ByteBuffer.allocate(128);\n        try {\n            int read = socketChannel.read(readByteBuffer);\n            if (read < 0) {\n                throw new RuntimeException(\"\");\n            }\n        } catch (IOException e) {\n\n        }\n\n        ByteBuffer newByteBuffer = readByteBuffer;\n        if (newByteBuffer == null) {\n            return;\n        }\n        // 切换到读模式\n        newByteBuffer.flip();\n\n        if (lastReadBuffer != null) {\n            // 将上次遗留的数据与本次已读的数据合并\n            newByteBuffer = ByteBufferUtil.composite(lastReadBuffer, newByteBuffer);\n        }\n\n        decode : while (true) {\n            if (newByteBuffer.remaining() <= HEAD_LENGTH) {\n\t\t\t\t// 报文字节数达不到报文长度退出\n                lastReadBuffer = ByteBuffer.wrap(ByteBufferUtil.readBuffer(newByteBuffer, newByteBuffer.remaining()));\n                return;\n            }\n\n            // 获取报文头部, 即报文有效长度\n            int payloadLength = newByteBuffer.getInt();\n            if (newByteBuffer.remaining() < payloadLength) {\n                // 拆包 : 后续字节不够一个完整报文\n                // 因上一操作 getInt 读取了 4　字节, 故需将　position 退回移动 4　字节\n                newByteBuffer.position(newByteBuffer.position() - HEAD_LENGTH);\n                lastReadBuffer = ByteBuffer.wrap(ByteBufferUtil.readBuffer(newByteBuffer, newByteBuffer.remaining()));\n                return;\n            }\n\n            // 获取有效报文\n            handlerPacket(socketChannel, ByteBufferUtil.readBuffer(newByteBuffer, payloadLength));\n\n            if (newByteBuffer.remaining() > 0) {\n                // 剩下的报文 可能是有效报文,　继续解码\n                continue decode;\n            }\n\n            return;\n        }\n    }\n\n\n\n    private void handlerPacket (SocketChannel socketChannel, byte[] packet) {\n        ServiceLoader<PacketHandler> packetHandlers = ServiceLoader.load(PacketHandler.class);\n        Iterator<PacketHandler> packetHandlerIterator = packetHandlers.iterator();\n\n        while (packetHandlerIterator.hasNext()) {\n            packetHandlerIterator.next().handler(socketChannel, packet);\n        }\n    }\n\n}\n\n```\n\n依赖的工具方法如下：\n\n```java\n\npublic class ByteBufferUtil {\n\n    private ByteBufferUtil () {}\n\n    /**\n     * 将两个 bytebuffer 合并\n     *\n     * @param byteBuffer1\n     * @param byteBuffer2\n     * @return\n     */\n    public static ByteBuffer composite(ByteBuffer byteBuffer1, ByteBuffer byteBuffer2) {\n        int capacity = byteBuffer1.limit() - byteBuffer1.position() + byteBuffer2.limit() - byteBuffer2.position();\n        ByteBuffer ret = ByteBuffer.allocate(capacity);\n\n        ret.put(byteBuffer1);\n        ret.put(byteBuffer2);\n\n        ret.position(0);\n        ret.limit(ret.capacity());\n        return ret;\n    }\n\n    /**\n     * 获取 bytebuffer 中可读的内容\n     *\n     * @param byteBuffer\n     * @param size\n     * @return\n     */\n    public static byte[] readBuffer(ByteBuffer byteBuffer, int size) {\n        byte[] bytes = new byte[size];\n\n        byteBuffer.get(bytes);\n\n        return bytes;\n    }\n}\n\n```\n","tags":["NIO"]},{"title":"NIO之ByteBuffer","url":"/2017/12/13/NIO之ByteBuffer/","content":"\n### ByteBuffer\n\n###### 字段说明\n> * Capacity : Buffer 固定的容量大小\n* Position : 表示当前的位置， 初始值为0；当为写模式时，当写入一个字节的时候，position会向前移动到下一个可插入数据的buffer单元；当为读模式时，position会重置为0，每读取一个字节的时候，position会向前移动下一个可读取的位置。\n* Limit : 表示buffer最多可写或可读的数量。写模式下limit = capacity; 读模式下limit = position\n\n###### 初始化\n\n> 采用jvm堆内存初始\n\n```java\n  /**\n   * 定义初始容量10字节的缓冲区 capacity=10, limit=10, position=0\n   */\n  ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n```\n<!-- more -->\n> 采用堆外内存初始\n\n```java\n  /**\n   * 定义初始容量10字节的缓冲区 capacity=10, limit=10, position=0\n   */\n  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(10);\n\n```\n\n###### put(byte byte)\n\n> 写入数据时，每写入一个字节的时候 会检验 position >= limit, 之后执行position++ 自增操作；\n\n```java\n  public Bytebuffer put (byte x) {\n    hb[ix(nextPutIndex())] = x;\n    return this;\n  }\n\n  int nextPutIndex () {\n    if (position >= limit) {\n      throw new BufferOverflowException();\n    }\n    return position++;\n  }\n```\n\n![put](https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1505116488784&di=a0dd847eedd460ace788f23a94157178&imgtype=jpg&src=http%3A%2F%2Fh.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F4610b912c8fcc3ce6443e4179945d688d43f2016.jpg)\n\n###### flip()\n\n> buffer 由写模式切换到读模式; limit 值为position， position会重置为0\n\n```java\n\n  public final Buffer flip() {\n    limit = position;\n    position = 0;\n    mark = -1;\n    return this;\n  }\n\n```\n![flip](https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1505118021655&di=bb23319c2e5d519a3da9d2961127c26b&imgtype=jpg&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11df5590ab07682762d0f703c255.jpg)\n\n###### get()\n\n> buffer 读取数据的时候，检验position>=limit; 之后执行position++\n\n```java\n  public byte get() {\n    return hb[ix(nextGetIndex())];\n  }\n\n  int nextGetIndex () {\n    if (position >= limit){\n      throw new BufferUnderflowException();\n    }\n    return position++;\n  }\n```\n\n![](https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1505118511420&di=86d6d65d0d9d00faa5be956ddaa08ec7&imgtype=jpg&src=http%3A%2F%2Fg.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F77c6a7efce1b9d16a3e08a45f8deb48f8c5464ea.jpg)\n","tags":["NIO","bytebuffer"]},{"title":"zookeeper源码阅读之server","url":"/2017/12/12/zookeeper源码阅读之server/","content":"\n#### zookeeper server 启动流程概述\n\n> 此次只针对单机模式对 server 端的启动流程分析, 首先看下 zookeeper server 启动时序图，如下：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm47wn25cj30ys0jlt9k.jpg)\n\n> 其启动流程如下：\n> - 执行 zkServer.sh start 脚本, 会调用 QuorumPeerMain.main(); 执行 initializeAndRun 方法\n> - 调用 QuorumPeerConfig.parse() 方法，该方法主要是对启动参数的解析并加载相应的配置文件\n> - 通过上文解析的配置, 判断当前启动模式是否为集群或单机模式\n> - 单机模式下调用 ZookeeperServerMain.main() 方法\n> - 执行 ZookeeperServerMain.initializeAndRun 方法\n> - 调用 ServerConfig.parse 再次解析启动参数加载配置文件\n> - 调用 runFromConfig , 在该方法中依次启动 JettyAdminServer.start(), NIOServerCnxnFactory.startup()\n\n> 至此 zookeeper server 完成单机模式下启动，接下来将详细看下 NIOServerCnxnFactory.startup 的启动过程。\n<!-- more -->\n#### zookeeper server 线程模型\n\n> 在 NIOServerCnxnFactory.startup() 启动前, 我们先看下针对 NIOServerCnxnFactory 的对象的创建及相关配置:\n\n###### NIOServerCnxnFactory 的创建\n\n> 通过 ServerCnxnFactory.createFactory 完成 ServerCnxnFactory 的创建\n```java\n\tstatic public ServerCnxnFactory createFactory() throws IOException {\n\t\t// 获取系统变量 zookeeper.serverCnxnFactory\n\t\tString serverCnxnFactoryName =\n\t\t\t\tSystem.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);\n\t\tif (serverCnxnFactoryName == null) {\n\t\t\t// 若未指定该变量值 则默认返回 NIOServerCnxnFactory; 同时支持 NettyServerCnxnFactory\n\t\t\t\tserverCnxnFactoryName = NIOServerCnxnFactory.class.getName();\n\t\t}\n\t\ttry {\n\t\t\t\treturn (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)\n\t\t\t\t\t\t.newInstance();\n\t\t} catch (Exception e) {\n\t\t\t\tIOException ioe = new IOException(\"Couldn't instantiate \"\n\t\t\t\t\t\t\t\t+ serverCnxnFactoryName);\n\t\t\t\tioe.initCause(e);\n\t\t\t\tthrow ioe;\n\t\t}\n\t}\n```\n\n###### NIOServerCnxnFactory 的配置\n\n> 在执行 startup 前会调用 configure 方法执行相关参数的初始化并绑定 serverSocket \n\n```java\npublic void configure(InetSocketAddress addr, int maxcc, boolean secure) throws IOException {\n\t\tif (secure) {\n\t\t\t\tthrow new UnsupportedOperationException(\"SSL isn't supported in NIOServerCnxn\");\n\t\t}\n\t\tconfigureSaslLogin();\n\n\t\tmaxClientCnxns = maxcc;\n\t\tsessionlessCnxnTimeout = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);\n\t\t\n\t\tcnxnExpiryQueue =\n\t\t\t\tnew ExpiryQueue<NIOServerCnxn>(sessionlessCnxnTimeout);\n\t\texpirerThread = new ConnectionExpirerThread();\n\t\t// 返回虚拟机的可用处理器数量　也可认为 cpu 核数\n\t\tint numCores = Runtime.getRuntime().availableProcessors();\n\t\t// 32 cores sweet spot seems to be 4 selector threads\n\t\t// 计算 selectorThread 线程个数\n\t\tnumSelectorThreads = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_NUM_SELECTOR_THREADS,\n\t\t\t\t\t\tMath.max((int) Math.sqrt((float) numCores/2), 1));\n\t\tif (numSelectorThreads < 1) {\n\t\t\t\tthrow new IOException(\"numSelectorThreads must be at least 1\");\n\t\t}\n\n\t\t// 工作线程　workerThread　数; 默认为　2*numCores\n\t\tnumWorkerThreads = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);\n\t\tworkerShutdownTimeoutMS = Long.getLong(\n\t\t\t\t\t\tZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);\n\t\t// 创建 selectorThread 线程集合\n\t\tfor(int i=0; i<numSelectorThreads; ++i) {\n\t\t\t\tselectorThreads.add(new SelectorThread(i));\n\t\t}\n\n\t\t// 开启服务端链接通道并绑定端口\n\t\tthis.ss = ServerSocketChannel.open();\n\t\tss.socket().setReuseAddress(true);\n\t\tLOG.info(\"binding to port \" + addr);\n\t\tss.socket().bind(addr);\n\t\tss.configureBlocking(false);\n\n\t\t// 创建 AcceptThread 并绑定 ServerSocketChannel selecorThreads　\n\t\tacceptThread = new AcceptThread(ss, addr, selectorThreads);\n}\n```\n\n###### NIOServerCnxnFactory 的启动\n> 启动过程包括 NIOServerCnxnFactory 的启动和 ZookeeperServer 的启动\n```java\n\t\t@Override\n\tpublic void startup(ZooKeeperServer zks, boolean startServer)\n\t\tthrows IOException, InterruptedException {\n\t\tstart();\n\t\tsetZooKeeperServer(zks);\n\t\tif (startServer) {\n\t\t\t\tzks.startdata();\n\t\t\t\tzks.startup();\n\t\t}\n\t}\n\n```\n\n```java\npublic void start() {\n\t\tstopped = false;\n\t\tif (workerPool == null) {\n\t\t\t\tworkerPool = new WorkerService(\n\t\t\t\t\t\t\t\t\"NIOWorker\", numWorkerThreads, false);\n\t\t}\n\t\tfor(SelectorThread thread : selectorThreads) {\n\t\t\t\tif (thread.getState() == Thread.State.NEW) {\n\t\t\t\t\t\tthread.start();\n\t\t\t\t}\n\t\t}\n\t\t// ensure thread is started once and only once\n\t\tif (acceptThread.getState() == Thread.State.NEW) {\n\t\t\t\tacceptThread.start();\n\t\t}\n\t\tif (expirerThread.getState() == Thread.State.NEW) {\n\t\t\t\texpirerThread.start();\n\t\t}\n}\n```\n> 从代码中可以看出 NIOServerCnxnFactory 启动的时候开启了 AcceptThread SelectorThread ExpirerThread workerPool\n\n###### AcceptThread \n\n```java\npublic void run() {\n\ttry {\n\t\t// 当 server 未停止　并且 serverSocket 未关闭的时候一直轮询执行select()\n\t\twhile (!stopped && !acceptSocket.socket().isClosed()) {\n\t\t\t\ttry {\n\t\t\t\t\t\tselect();\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected runtime exception\", e);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected exception\", e);\n\t\t\t\t}\n\t\t}\n\t} finally {\n\t\tcloseSelector();\n\t\t// This will wake up the selector threads, and tell the\n\t\t// worker thread pool to begin shutdown.\n\t\tif (!reconfiguring) {                    \n\t\t\t\tNIOServerCnxnFactory.this.stop();\n\t\t}\n\t\tLOG.info(\"accept thread exitted run method\");\n\t}\n}\n```\n\n```java\nprivate void select() {\n\ttry {\n\t\tselector.select();\n\n\t\tIterator<SelectionKey> selectedKeys =\n\t\t\t\tselector.selectedKeys().iterator();\n\t\twhile (!stopped && selectedKeys.hasNext()) {\n\t\t\t\tSelectionKey key = selectedKeys.next();\n\t\t\t\tselectedKeys.remove();\n\n\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (key.isAcceptable()) {\n\t\t\t\t\t\tif (!doAccept()) {\n\t\t\t\t\t\t\tpauseAccept(10);\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Unexpected ops in accept select \"\n\t\t\t\t\t\t\t\t\t\t+ key.readyOps());\n\t\t\t\t}\n\t\t}\n\t} catch (IOException e) {\n\t\tLOG.warn(\"Ignoring IOException while selecting\", e);\n\t}\n}\n```\n\n```java\nprivate boolean doAccept() {\n\t\tboolean accepted = false;\n\t\tSocketChannel sc = null;\n\t\ttry {\n\t\t\t\t// 获取客户端链接\n\t\t\t\tsc = acceptSocket.accept();\n\t\t\t\taccepted = true;\n\t\t\t\tInetAddress ia = sc.socket().getInetAddress();\n\t\t\t\tint cnxncount = getClientCnxnCount(ia);\n\t\t\t\t// 判断该客户端连接数是否超过最大值\n\t\t\t\tif (maxClientCnxns > 0 && cnxncount >= maxClientCnxns){\n\t\t\t\t\t\tthrow new IOException(\"Too many connections from \" + ia\n\t\t\t\t\t\t\t\t\t\t+ \" - max is \" + maxClientCnxns );\n\t\t\t\t}\n\n\t\t\t\tLOG.info(\"Accepted socket connection from \"\n\t\t\t\t\t\t\t\t+ sc.socket().getRemoteSocketAddress());\n\t\t\t\tsc.configureBlocking(false);\n\n\t\t\t\t// Round-robin assign this connection to a selector thread\n\t\t\t\t// 选取一个 selectorThread\n\t\t\t\tif (!selectorIterator.hasNext()) {\n\t\t\t\t\t\tselectorIterator = selectorThreads.iterator();\n\t\t\t\t}\n\t\t\t\tSelectorThread selectorThread = selectorIterator.next();\n\t\t\t\t// 将接收到的链接　添加到　selector thread 的接收队列中\n\t\t\t\tif (!selectorThread.addAcceptedConnection(sc)) {\n\t\t\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\t\t\t\t\"Unable to add connection to selector queue\"\n\t\t\t\t\t\t\t\t\t\t+ (stopped ? \" (shutdown in progress)\" : \"\"));\n\t\t\t\t}\n\t\t\t\tacceptErrorLogger.flush();\n\t\t} catch (IOException e) {\n\t\t\t\t// accept, maxClientCnxns, configureBlocking\n\t\t\t\tacceptErrorLogger.rateLimitLog(\n\t\t\t\t\t\t\t\t\"Error accepting new connection: \" + e.getMessage());\n\t\t\t\tfastCloseSock(sc);\n\t\t}\n\t\treturn accepted;\n}\n```\n>  从代码中可以看出 AcceptThread 主要用来接收客户端的链接，并将就绪的客户端链接添加到 selectorThread线程对象的 acceptQueue 中\n\n###### SelectorThread\n\n```java\npublic boolean addAcceptedConnection(SocketChannel accepted) {\n\t\tif (stopped || !acceptedQueue.offer(accepted)) {\n\t\t\t\treturn false;\n\t\t}\n\t\t// 当接收到一个链接的时候, 唤醒阻塞在 selector.select(）操作上的线程\n\t\twakeupSelector();\n\t\treturn true;\n}\n```\n> 当 AcceptThread 将就绪的客户端链接添加到 selectorThread 对象的 acceptQueue 队列中的时候，同时会唤醒阻塞在 acceptQueue.poll() , selector.select() 操作的实例\n\n```java\npublic void run() {\n\t\ttry {\n\t\t\t\twhile (!stopped) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tselect();\n\t\t\t\t\t\t\t\t// 处理 acceptedQueue 队列里面的客户端链接\n\t\t\t\t\t\t\t\tprocessAcceptedConnections();\n\t\t\t\t\t\t\t\tprocessInterestOpsUpdateRequests();\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected runtime exception\", e);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected exception\", e);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Close connections still pending on the selector. Any others\n\t\t\t\t// with in-flight work, let drain out of the work queue.\n\t\t\t\tfor (SelectionKey key : selector.keys()) {\n\t\t\t\t\t\tNIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\t\t\t\t\t\tif (cnxn.isSelectable()) {\n\t\t\t\t\t\t\t\tcnxn.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t}\n\t\t\t\tSocketChannel accepted;\n\t\t\t\twhile ((accepted = acceptedQueue.poll()) != null) {\n\t\t\t\t\t\tfastCloseSock(accepted);\n\t\t\t\t}\n\t\t\t\tupdateQueue.clear();\n\t\t} finally {\n\t\t\t\tcloseSelector();\n\t\t\t\t// This will wake up the accept thread and the other selector\n\t\t\t\t// threads, and tell the worker thread pool to begin shutdown.\n\t\t\t\tNIOServerCnxnFactory.this.stop();\n\t\t\t\tLOG.info(\"selector thread exitted run method\");\n\t\t}\n}\n```\n\n```java\nprivate void select() {\n\t\ttry {\n\t\t\t\tselector.select();\n\n\t\t\t\tSet<SelectionKey> selected = selector.selectedKeys();\n\t\t\t\tArrayList<SelectionKey> selectedList =\n\t\t\t\t\t\tnew ArrayList<SelectionKey>(selected);\n\t\t\t\tCollections.shuffle(selectedList);\n\t\t\t\tIterator<SelectionKey> selectedKeys = selectedList.iterator();\n\t\t\t\twhile(!stopped && selectedKeys.hasNext()) {\n\t\t\t\t\t\tSelectionKey key = selectedKeys.next();\n\t\t\t\t\t\tselected.remove(key);\n\n\t\t\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (key.isReadable() || key.isWritable()) {\n\t\t\t\t\t\t\t\thandleIO(key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOG.warn(\"Unexpected ops in select \" + key.readyOps());\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(\"Ignoring IOException while selecting\", e);\n\t\t}\n}\n\n```\n\n```java\nprivate void handleIO(SelectionKey key) {\n\t\tIOWorkRequest workRequest = new IOWorkRequest(this, key);\n\t\tNIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\n\t\t// Stop selecting this key while processing on its\n\t\t// connection\n\t\tcnxn.disableSelectable();\n\t\tkey.interestOps(0);\n\t\ttouchCnxn(cnxn);\n\n\t\tLOG.info(\"Selector THread 开始处理　io\");\n\t\tworkerPool.schedule(workRequest);\n}\n```\n\n```java\nprivate void processAcceptedConnections() {\n\t\tSocketChannel accepted;\n\t\twhile (!stopped && (accepted = acceptedQueue.poll()) != null) {\n\t\t\t\tSelectionKey key = null;\n\t\t\t\ttry {\n\t\t\t\t\t\t// 将　acceptQueue 中的　socketChannel 注册到 selector　并监听读事件\n\t\t\t\t\t\tkey = accepted.register(selector, SelectionKey.OP_READ);\n\t\t\t\t\t\t// 新建　nioServerCnxn 并以附加信息的方式绑定到 selectkey\n\t\t\t\t\t\tNIOServerCnxn cnxn = createConnection(accepted, key, this);\n\t\t\t\t\t\tkey.attach(cnxn);\n\t\t\t\t\t\taddCnxn(cnxn);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// register, createConnection\n\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t\t\tfastCloseSock(accepted);\n\t\t\t\t}\n\t\t}\n}\n```\n\n从以上代码可以看出 selectorThread 流程如下:\n> - 轮询 selector 选择器上是否有就绪的客户端通道\n> - 当有就绪 Read 事件的客户端通道时　将该客户端派发到 wokerPool 去执行\n> - 当 acceptQueue 队列中有新接收的到客户通道的时候 将其注册到 selector 上并监听 READ 事件；同时并创建一个 NIOServerCnxn 对象绑定到 key 上（待执行 handleIO 时用到）\n\n接下来看下 wokerPool 如何处理 workRequest\n\n```java\npublic void schedule(WorkRequest workRequest, long id) {\n\t\tif (stopped) {\n\t\t\t\tworkRequest.cleanup();\n\t\t\t\treturn;\n\t\t}\n\n\t\tScheduledWorkRequest scheduledWorkRequest =\n\t\t\t\tnew ScheduledWorkRequest(workRequest);\n\n\t\t// If we have a worker thread pool, use that; otherwise, do the work\n\t\t// directly.\n\t\t// 如果　workers 数量大于 0, 则通过　ExecutorService 执行　scheduledWorkRequest；　反之直接调用　ScheduledWorkRequest\n\t\tint size = workers.size();\n\t\tif (size > 0) {\n\t\t\t\ttry {\n\t\t\t\t\t\t// make sure to map negative ids as well to [0, size-1]\n\t\t\t\t\t\tint workerNum = ((int) (id % size) + size) % size;\n\t\t\t\t\t\tExecutorService worker = workers.get(workerNum);\n\t\t\t\t\t\tworker.execute(scheduledWorkRequest);\n\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\tLOG.warn(\"ExecutorService rejected execution\", e);\n\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t}\n\t\t} else {\n\t\t\t\t// When there is no worker thread pool, do the work directly\n\t\t\t\t// and wait for its completion\n\t\t\t\tscheduledWorkRequest.start();\n\t\t\t\ttry {\n\t\t\t\t\t\tscheduledWorkRequest.join();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tLOG.warn(\"Unexpected exception\", e);\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n```java\nprivate class ScheduledWorkRequest extends ZooKeeperThread {\n\t\tprivate final WorkRequest workRequest;\n\n\t\tScheduledWorkRequest(WorkRequest workRequest) {\n\t\t\t\tsuper(\"ScheduledWorkRequest\");\n\t\t\t\tthis.workRequest = workRequest;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\t\t// Check if stopped while request was on queue\n\t\t\t\t\t\tif (stopped) {\n\t\t\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tworkRequest.doWork();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLOG.warn(\"Unexpected exception\", e);\n\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n```java\nprivate class IOWorkRequest extends WorkerService.WorkRequest {\n\t\tprivate final SelectorThread selectorThread;\n\t\tprivate final SelectionKey key;\n\t\tprivate final NIOServerCnxn cnxn;\n\n\t\tIOWorkRequest(SelectorThread selectorThread, SelectionKey key) {\n\t\t\t\tthis.selectorThread = selectorThread;\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.cnxn = (NIOServerCnxn) key.attachment();\n\t\t}\n\n\t\tpublic void doWork() throws InterruptedException {\n\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\tselectorThread.cleanupSelectionKey(key);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key.isReadable() || key.isWritable()) {\n\n\t\t\t\t\t\tLOG.info(\"IOWorker Request do work \");\n\t\t\t\t\t\tcnxn.doIO(key);\n\n\t\t\t\t\t\t// Check if we shutdown or doIO() closed this connection\n\t\t\t\t\t\tif (stopped) {\n\t\t\t\t\t\t\t\tcnxn.close();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\t\t\tselectorThread.cleanupSelectionKey(key);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttouchCnxn(cnxn);\n\t\t\t\t}\n\n\t\t\t\t// Mark this connection as once again ready for selection\n\t\t\t\tcnxn.enableSelectable();\n\t\t\t\t// Push an update request on the queue to resume selecting\n\t\t\t\t// on the current set of interest ops, which may have changed\n\t\t\t\t// as a result of the I/O operations we just performed.\n\t\t\t\tif (!selectorThread.addInterestOpsUpdateRequest(key)) {\n\t\t\t\t\t\tcnxn.close();\n\t\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t\t\tpublic void cleanup() {\n\t\t\t\t\t\tcnxn.close();\n\t\t\t\t}\n}\n```\n\n> 从上面代码可以看出在执行 IOWorkRequest 时会选择由线程池执行还是单线程执行；最终会由 NIOServerCnxn　处理客户端通道的读写事件\n\n> 综合 AcceptThread SelectorThread IOWorkRequest 可以看出 zookeeper server 的线程模型为单线程的 Reactor模型;如下图所示:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm40t5nc2j30m90axdgd.jpg)\n> 后续相关的 IO 处理及　PrepRequestProcessor 相关的 Processor 流程会在下文分析\n","tags":["zookeeper"]},{"title":"VIM 支持 markdown 预览","url":"/2017/12/12/vim编写markdown实时预览/","content":"### 安装 vim 插件管理器 [vundle](https://github.com/VundleVim/Vundle.vim)\n\n##### 下载 vundle\n\n```\n\tgit clone https://github.com/VundleVim/Vundle.vim ~/.vim/bundle/Vundle.vim\n```\n\n##### 编辑 vim 配置文件 vimrc\n\n> 通过 apt-get install vim 安装的 vim 配置文件路径为 /etc/vim/vimrc\n\n```\n\tvim /etc/vim/vimrc\n```\n<!-- more -->\n> 将以下内容添加到 vimrc 文件中\n\n```xml\nset nocompatible    \" be iMproved, required\nfiletype off \" required\n\n\" 启用vundle来管理vim插件\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\n\" 安装插件写在这之后\n\n\" let Vundle manage Vundle, required\nPlugin 'VundleVim/Vundle.vim'\n\n\" 安装插件写在这之前\ncall vundle#end() \" required\nfiletype plugin on \n\n\" required\" 常用命令\n\" :PluginList - 查看已经安装的插件\n\" :PluginInstall - 安装插件\n\" :PluginUpdate - 更新插件\n\" :PluginSearch - 搜索插件，例如 :PluginSearch xml就能搜到xml相关的插件\n\" :PluginClean - 删除插件，把安装插件对应行删除，然后执行这个命令即可\n\n\" h: vundle - 获取帮助\n```\n\n> 进入 vim 执行 PluginInstall\n\n```\n\tsudo vim\n\n\t:PluginInstall\n```\n\n> 插件安装完成后,　左下角会出现 Done！ 至此 vundle 插件管理器安装完成.\n\n##### 安装 vim-instant-markdown 插件\n\n> 在 vim 配置文件 vimrc 文件中添加以下内容:\n\n```\n Plugin 'suan/vim-instant-markdown'\n```\n\n> 再次进入 vim 执行 PluginInstall; 当出现 Done！即表示插件安装完成.　此时 vim xx.md　即可实时预览 markdown 文件;效果如下图所示.\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4r0kb2sj31go0qijxk.jpg)\n","tags":["vim"]},{"title":"关于","url":"/about/index.html"}]