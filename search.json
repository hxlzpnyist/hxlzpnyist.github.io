[{"title":"Hello World","url":"/2019/02/22/hello-world (2)/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"测试文章","url":"/2019/02/22/测试文章/","content":"\n### 测试标题\n\n> 这是测试内容\n","tags":["java","后端"]},{"title":"Hello World","url":"/2019/02/21/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"TCP：三次握手、四次握手、backlog及其他","url":"/2018/03/13/TCP：三次握手、四次握手、backlog及其他/","content":"\n参考博客　[TCP：三次握手、四次握手、backlog及其他](https://www.cnblogs.com/xrq730/p/6910719.html)\n"},{"title":"Java内存模型","url":"/2018/03/11/Java内存模型/","content":"\n##### 定义\n\nJava 虚拟机规范中通过定义一种 Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的内存访问效果。\n\n###### 主内存与工作内存\n\n主内存 : 在 Java 内存模型中规定了所有的变量都存储在主内存中。\n工作内存 : 每个线程都有自己的工作内存，在工作内存中保存了该线程使用到的变量的主内存副本拷贝；线程对变量的所有操作必须在工作内存中完成，而不能直接读写主内存的变量；不同线程之间无法直接访问对方的工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n![](http://img.blog.csdn.net/20160921182337904)\n\n```\n此处我们描述的主内存，工作内存与 Java 运行时数据中的堆,栈，方法区并不是同一层次的内存划分；二者基本上是没有关系的，不过也可以理解为主内存对应于 Java 堆中的对象实例，而工作内存对应于虚拟机中的栈。\n```\n\n###### 内存间如何交互\n\n在 Java 内存模型中定义了８中操作用来实现内存间的交互，也即是变量如何从主内存拷贝到工作内存，以及工作内存中的变量如何同步回主内存。\n\n８中操作如下：\n\n* lock : 锁定，作用于主内存的变量，将变量标志为一条线程独占的状态\n* unlock : 解锁，作用于主内存的变量，将处于锁定状态的变量释放，方便其他线程锁定\n* read : 读取，作用于主内存的变量，将一个变量的值从主内存传输到工作内存中\n* load : 载入，作用于工作内存，将read操作从主内存得到的变量放入工作内存的变量副本中\n* use : 使用，作用于工作内存的变量\n* assign : 赋值\n* store : 存储\n* write :\n\n在 Java 模型中还规定了在完成上述操作时必须满足以下规则：\n\n* 变量在工作内存中改变之后必须把该变化同步到主内存\n* 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次；多次 lock 之后，只有执行相同次数的 unlock 操作，变量才会被解锁；也就是可重入锁。\n* 对一个变量执行 lock 操作，将会清空工作内存中此变量的值也就是从主内存重新获取该变量的值更新到工作内存中\n* 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中\n\n\n\n\n\n"},{"title":"Jdk之LinkedHashMap","url":"/2018/03/05/Jdk之LinkedHashMap/","content":"\n##### 概述\n\nLinkedHashMap 与 HashMap 的不同之处在于前者遍历有序，后者遍历无序\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fp29qrz3k1j30900f0mxz.jpg)\n\n从上图中可以看出 LinkedHashMap 继承至 HashMap , 并重写了 init, createEntry, addEntry, iterator 等方法。\n\n同时新增了全局变量 header, 并自定义了 LinkedHashMap.Entry 内部类\n<!-- more -->\n```java\nprivate static class Entry<K,V> extends HashMap.Entry<K,V> {\n        // These fields comprise the doubly linked list used for iteration.\n        Entry<K,V> before, after;\n\n        Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n            super(hash, key, value, next);\n        }\n\n        /**\n         * Removes this entry from the linked list.\n         */\n        private void remove() {\n            before.after = after;\n            after.before = before;\n        }\n\n        /**\n         * Inserts this entry before the specified existing entry in the list.\n         */\n        private void addBefore(Entry<K,V> existingEntry) {\n            after  = existingEntry;\n            before = existingEntry.before;\n            before.after = this;\n            after.before = this;\n        }\n\n    }\n\n```\n\n从代码中可以看出 LinkedHashMap.Entry 继承至 HashMap.Entry ,　新增了变量 before, after; 以及内部方法 addBefore;\n\n那么 LinkedHashMap 如何保证遍历有序的呢？下文将详细说明，首先我们先看下 LinkedHashMap 的初始化操作有何不同。\n\n###### init\n\n```java\n\tvoid init() {\n        header = new Entry<>(-1, null, null, null);\n        header.before = header.after = header;\n    }\n```\n\n在初始化过程中 构建了 header 节点\n\n###### createEntry\n\n```java\n\t/**\n     * This override differs from addEntry in that it doesn't resize the\n     * table or remove the eldest entry.\n     */\n    void createEntry(int hash, K key, V value, int bucketIndex) {\n        HashMap.Entry<K,V> old = table[bucketIndex];\n        Entry<K,V> e = new Entry<>(hash, key, value, old);\n        table[bucketIndex] = e;\n        e.addBefore(header);\n        size++;\n    }\n```\n\n从代码中可以看出与 HashMap 不同之处在于 构建 Entry 实例之后执行了 e.addBefore 方法\n\n```java\n\tprivate void addBefore(Entry<K,V> existingEntry) {\n            // 当前节点的后驱节点指向 existingEntry\n\t\t\tafter  = existingEntry;\n\t\t\t// 当前节点的前驱节点指向 existingEntry 的后驱节点\n            before = existingEntry.before;\n\t\t\t// 当前节点的前驱节点的后驱节点指向当前节点\n            before.after = this;\n\t\t\t// 当前节点的后驱节点的前驱节点指向当前节点\n            after.before = this;\n        }\n```\n\n从init, Entry.addBefore 方法可以看出 LinkedHashMap 内部维护了一个\"双向链表\"，每次添加元素的时候会将该节点添加到链表中；如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fp2baen2gdj30ul0h7qv5.jpg)\n\n###### iterator\n\n```java\nprivate abstract class LinkedHashIterator<T> implements Iterator<T> {\n        Entry<K,V> nextEntry    = header.after;\n        Entry<K,V> lastReturned = null;\n\n        /**\n         * The modCount value that the iterator believes that the backing\n         * List should have.  If this expectation is violated, the iterator\n         * has detected concurrent modification.\n         */\n        int expectedModCount = modCount;\n\n        public boolean hasNext() {\n\t\t\t// 当 nextEntry 不等于 header 的表示还未遍历到链表末尾\n            return nextEntry != header;\n        }\n\n        public void remove() {\n            if (lastReturned == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n\n            LinkedHashMap.this.remove(lastReturned.key);\n            lastReturned = null;\n            expectedModCount = modCount;\n        }\n\n        Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (nextEntry == header)\n                throw new NoSuchElementException();\n\n            Entry<K,V> e = lastReturned = nextEntry;\n\t\t\t// 指向节点的后驱节点\n            nextEntry = e.after;\n            return e;\n        }\n    }\n```\n\n从内部类 LinkedHashIterator 中可以看出 LinkedHashMap 是遍历双向链表，从而保证遍历的时候有序.\n\n同样 LinkedHashSet 内部是调用 LinkedHashMap 实现，同样也保证了遍历有序。\n\n"},{"title":"Jdk之HashMap","url":"/2018/03/05/Jdk之HashMap/","content":"\n##### 概述\n\nHashMap 是散列表的一种基于拉链法的实现方式。\n\n本文先看下 HashMap 的迭代实现方式\n\n```java\n\tprivate abstract class HashIterator<E> implements Iterator<E> {\n        Entry<K,V> next;        // next entry to return\n        int expectedModCount;   // For fast-fail\n        int index;              // current slot\n        Entry<K,V> current;     // current entry\n\n        HashIterator() {\n            expectedModCount = modCount;\n            if (size > 0) { // advance to first entry\n                Entry[] t = table;\n\t\t\t\t// 遍历数组 直到发现一个不为空的 Entry\n                while (index < t.length && (next = t[index++]) == null)\n                    ;\n            }\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n        final Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            Entry<K,V> e = next;\n            if (e == null)\n                throw new NoSuchElementException();\n\t\t\t// 获取当前 Entry 链表的下一个节点，如果下个节点为空说明当前链表已经遍历结束\n\t\t\t// 此时继续遍历数组 直到发现一个不为空的 Entry\n            if ((next = e.next) == null) {\n                Entry[] t = table;\n                while (index < t.length && (next = t[index++]) == null)\n                    ;\n            }\n            current = e;\n            return e;\n        }\n\n        public void remove() {\n            if (current == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            Object k = current.key;\n            current = null;\n            HashMap.this.removeEntryForKey(k);\n            expectedModCount = modCount;\n        }\n    }\n```\n\n遍历过程如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fp29gi4632j31hc0u04bx.jpg)\n\n"},{"title":"jdk之TreeMap","url":"/2018/03/01/jdk之TreeMap/","content":"\n##### 定义\n\nTreeMap 基于红黑树实现\n"},{"title":"jdk之LinkedList","url":"/2018/02/28/jdk之LinkedList/","content":"\n##### 定义\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n```\n\n从定义可以看出 LinkedList 实现了接口 List, Deque, 表明其支持列表,栈，队列，双端队列的操作。\n\n<!-- more -->\n\n##### 变量\n\n```java\n\ttransient int size = 0;\n\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last;\n```\n\n* size : 链表元素个数\n* first : 指向链表的头节点\n* last : 指向链表的尾节点\n\n###### 内部类\n\n```java\n\tprivate static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n\nNode 是 LinkedList 的内部类，定义了链表的节点结构:\n* item : 节点存储的元素\n* prev : 当前节点的前驱节点\n* next : 当前节点的后驱节点\n\n##### Api\n\n###### add(E)\n\n向链表中添加元素\n\n```java\n\tpublic boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n```\n\n```java\n    void linkLast(E e) {\n        final Node<E> l = last;\n\t\t// 定义插入节点\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n\t\t\t// 链表为空 头尾节点均指向新插入的节点\n            first = newNode;\n        else\n\t\t\t// 链表的尾节点后驱节点指向新插入的节点\n            l.next = newNode;\n\t\t// 元素个数加一\n        size++;\n        modCount++;\n    }\n```\n\n* 首先构建待插入的节点\n* 将尾节点指向待插入的节点\n* 若原尾节点为空，说明队列为空，将头节点也指向待插入的节点\n* 若原尾节点非空，则将原尾节点的后驱节点指向待插入节点\n* 元素个数加一\n\n###### add(index, e)\n\n向链表中指定的位置插入元素\n\n```java\n\tpublic void add(int index, E element) {\n        // 检查位置index 是否在链表范围内\n\t\tcheckPositionIndex(index);\n\n        if (index == size)\n\t\t\t// 表明在链表的末尾插入节点\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n```\n\nnode(index) 方法用于获取链表指定位置的节点\n\n```java\n\tNode<E> node(int index) {\n        // assert isElementIndex(index);\n\t\t// 判断index 是否比链表长度的一半小；size >> 1 相当于 size/2\n\t\t// 如果小于链表的一半，则从头节点开始遍历\n\t\t// 如果大于链表的一半，则从尾节点开始遍历\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n\nlinkBefor(E e, Node succ) 方法用于在指定节点前插入元素\n\n```java\n\tvoid linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n###### set(index, e)\n\n更新链表指定位置节点的元素，并返回老的元素\n\n```java\n\tpublic E set(int index, E element) {\n        checkElementIndex(index);\n        // 获取指定位置的节点\n\t\tNode<E> x = node(index);\n        E oldVal = x.item;\n\t\t// 更新节点元素\n        x.item = element;\n        return oldVal;\n    }\n```\n\n###### get(index)\n\n获取链表指定位置的元素\n\n```java\n\tpublic E get(int index) {\n        checkElementIndex(index);\n\t\t// 获取指定位置的节点　然后返回其存储的元素\n        return node(index).item;\n    }\n```\n\n###### remove(index)\n\n删除链表指定位置的节点并返回该节点存储的元素\n\n```java\n\tpublic E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n```\n\nunlink(node) 该方法从字面上理解即解除节点与链表的链接\n\n```java\n\tE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n\t\t\t// 前驱节点为空，说明删除的节点为头节点\n\t\t\t// 那么将头节点指向删除节点的后驱节点\n            first = next;\n        } else {\n\t\t\t// 前驱节点不为空\n\t\t\t// 将前驱节点的后驱节点指向删除节点的后驱节点\n            prev.next = next;\n\t\t\t// 删除节点的前驱节点指向空\n            x.prev = null;\n        }\n\n        if (next == null) {\n\t\t\t// 删除节点的后驱节点为空，说明删除节点为尾节点\n\t\t\t// 那么将尾节点指向删除节点的前驱节点\n            last = prev;\n        } else {\n\t\t\t// 后驱节点不为空\n\t\t\t// 将后驱节点的前驱节点指向删除节点的前驱节点\n            next.prev = prev;\n\t\t\t// 删除节点的后驱节点指向空\n            x.next = null;\n        }\n\t\t//　存储元素改为空,元素个数减一\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n###### iterator()\n\n链表的迭代, 内部调用的是 listIterator(0) 方法\n\n```java\n\tpublic ListIterator<E> listIterator(int index) {\n        checkPositionIndex(index);\n        return new ListItr(index);\n    }\n```\n\n```java\nprivate class ListItr implements ListIterator<E> {\n        private Node<E> lastReturned = null;\n        private Node<E> next;\n        private int nextIndex;\n        private int expectedModCount = modCount;\n\n        ListItr(int index) {\n            // assert isPositionIndex(index);\n            next = (index == size) ? null : node(index);\n            nextIndex = index;\n        }\n\n        public boolean hasNext() {\n\t\t\t// nextIndex 小于 size 表明还未遍历到链表结尾\n            return nextIndex < size;\n        }\n\n        public E next() {\n            checkForComodification();\n            if (!hasNext())\n                throw new NoSuchElementException();\n\t\t\t\n            lastReturned = next;\n            // next 指向下一个节点\n\t\t\tnext = next.next;\n\t\t\t// nextIndex 加一\n            nextIndex++;\n            return lastReturned.item;\n        }\n\n    }\n\n```\n\n\n\n","tags":["jdk"]},{"title":"数据结构-平衡二叉树","url":"/2018/02/26/数据结构-平衡二叉树/","content":"\n##### 概念\n\n###### 平衡二叉树\n\n平衡二叉树(Self-Balancing Binary Search Tree) 是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于１。\n\n<!-- more -->\n\n###### 平衡因子\n\n平衡因子 BF (Balance Factor) : 我们将二叉树上节点的左子树的深度减去右子树的深度值称为平衡因子；那么平衡二叉树上所有节点的平衡因子只可能是 -1, 0, 1。\n\n```\n只要二叉树上有一个节点的平衡因子的绝对值大于１, 那么该二叉树就是不平衡的\n```\n\n###### 最小不平衡子树\n\n最小不平衡子树: 当我们在执行平衡二叉树插入节点时，距离插入节点最近的，且平衡因子的绝对值大于１的节点为根的子树，我们将其称之为最小不平衡子树。\n\n###### 示例\n\n现通过下图一些样例说明何为平衡二叉树\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fou295n9p2j30fw08s3zu.jpg)\n\n* 图１为平衡二叉树：因为除了根节点的平衡因子为０，其他节点的平衡因子的绝对值均为１，符合平衡二叉树的条件\n* 图２不是平衡二叉树：因为节点５８的左节点为５９，５９ > 58 不符合二叉树的性质左节点小于根节点，所以也不符合平衡二叉树\n* 图３不是平衡二叉树：因为节点５８的左子树的深度为２，而右子树为空；平衡因子为２，所以不符合平衡二叉树的条件\n* 图４为平衡二叉树，满足平衡二叉树的条件\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fou58qvs1fj308i04x0t5.jpg)\n\n同样如上图所示，插入节点３７时，距离它最近的且平衡因子超过１的节点为５８，所以５８节点开始以下的子树为最小不平衡子树。\n\n##### 实现原理\n\n平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点时先检查是否因插入而破坏了树的平衡性；若是则找出最小不平衡子树，在保持二叉排序树特性的前提下调整最小不平衡子树中各节点之间的链接关系进行相应的旋转，使其成为新的平衡子树。\n\n下面以一个数组 a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8} 构建平衡二叉树的过程来说明其实现原理。\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fow3wpwca3j310z0nwe81.jpg)\n\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fow3xwecl3j30zx0qqkjl.jpg)\n\n以上两张图说明了平衡二叉树在构建过程的原理。针对构建过程发现不平衡的处理有如下几个步骤：\n\n* 当最小不平衡子树根节点的平衡因子BF大于１时，右旋；当平衡因子小于-1时左旋\n* 当最小不平衡子树的BF与其子节点BF符号相反时，需要先对子节点进行一次旋转使得符号相同后再进行一次旋转已达到平衡\n\n```\n右旋 : 将旋转节点的左节点指向其左节点的右节点，然后将旋转节点的左节点的右节点指向旋转节点（旋转节点下降，其左节点上浮）\n```\n\n```\n左旋 : 将旋转节点的右节点指向其右节点的左节点，然后将旋转节点的右节点的左节点指向旋转节点（旋转节点下降，其右节点上浮）\n```\n\n\n\n\n"},{"title":"java-泛型","url":"/2018/01/29/java-泛型/","content":"\n##### 类型擦除\n\n\n###### 泛型和方法重载\n\n\n\n","tags":["java"]},{"title":"jdk之LinkedBlockingQueue","url":"/2018/01/26/jdk之LinkedBlockingQueue/","content":"\n##### 概述\n\n在上一篇文章中我们分析了 ArrayBlockingQueue ,　今天在看下采用链表结构实现的阻塞队列。\n\n分析前我们同样有以下疑问：\n\n- 如何通过链表实现队列的 FIFO ?\n- 如何保证队列操作的同步 ?\n- 与 ArrayBlockingQueue 相比有如何优势 ?\n\n<!-- more -->\n\n##### 定义\n\n同样首先我们先来看下 LinkedBlockingQueue 的相关属性定义如下：\n\n```java\n \t/**\n     * 定义链表节点\n\t *\n\t * item : 节点存储的元素\n\t * next : 当前节点的后继节点\n     */\n    static class Node<E> {\n        E item;\n\n        Node<E> next;\n\n        Node(E x) { item = x; }\n    }\n\n    /** 定义队列的容量 默认为 Integer.MAX_VALUE */\n    private final int capacity;\n\n    /** 定义当前队列的存储元素个数 */\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    /**\n     * 队列头节点\n     * Invariant: head.item == null\n     */\n    private transient Node<E> head;\n\n    /**\n     * 队列尾节点\n     * Invariant: last.next == null\n     */\n    private transient Node<E> last;\n\n    /** Lock held by take, poll, etc */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** Wait queue for waiting takes */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** Lock held by put, offer, etc */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** Wait queue for waiting puts */\n    private final Condition notFull = putLock.newCondition();\n```\n\n从定义中有以下几个疑问：\n\n- 当前队列元素个数为什么采用原子操作类 AtomicInteger ? int 类型的变量为什么不可以？\n- 队列的头尾节点定义注释中为什么说 head last 都有一个不变性 item 永远为空 ?\n\n##### 构造\n\n```java\n\tpublic LinkedBlockingQueue() {\n\t\t// 队列默认容量为 int 最大值\n        this(Integer.MAX_VALUE);\n    }\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n\t\t// 设置队列容量\n        this.capacity = capacity;\n\t\t// 初始队列头尾节点\n        last = head = new Node<E>(null);\n    }\n```\n\n##### API\n\n###### offer(E e)\n\n```java\n\tpublic boolean offer(E e) {\n        if (e == null) throw new NullPointerException();\n        final AtomicInteger count = this.count;\n        if (count.get() == capacity)\n\t\t\t// 若队列满了 返回 false; 说明插入失败\n            return false;\n        int c = -1;\n\t\t// 定义节点\n        Node<E> node = new Node(e);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock();\n        try {\n            if (count.get() < capacity) {\n\t\t\t\t// 插入队列\n                enqueue(node);\n\t\t\t\t// 队列元素个数加一，并返回原来的个数\n                c = count.getAndIncrement();\n                if (c + 1 < capacity)\n\t\t\t\t\t// 队列未满唤醒因为队列满而阻塞的 put 操作\n                    notFull.signal();\n            }\n        } finally {\n            putLock.unlock();\n        }\n\t\t// c == 0 说明队列曾经为空，那么需要唤醒阻塞在 take poll 操作上的线程\n        if (c == 0)\n            signalNotEmpty();\n        return c >= 0;\n    }\n```\n\n```java\n\tprivate void enqueue(Node<E> node) {\n\t\t// 将原尾节点的后继节点 指向 node\n\t\t// 将尾节点指针指向 node\n        last = last.next = node;\n    }\n```\n\noffer 之后 last 永远指向链表的最近插入的节点，所以 last 节点的 next 永远为空。\n\n###### poll()\n\n```java\n\tpublic E poll() {\n        final AtomicInteger count = this.count;\n        if (count.get() == 0)\n\t\t\t// 队列为空 返回 null\n            return null;\n        E x = null;\n        int c = -1;\n        final ReentrantLock takeLock = this.takeLock;\n        takeLock.lock();\n        try {\n            if (count.get() > 0) {\n\t\t\t\t// 出队 获取队列头部元素\n                x = dequeue();\n\t\t\t\t// 队列元素个数减一 并返回原个数\n                c = count.getAndDecrement();\n                if (c > 1)\n\t\t\t\t\t// 唤醒因队列为空而阻塞的 take poll 操作\n                    notEmpty.signal();\n            }\n        } finally {\n            takeLock.unlock();\n        }\n\t\t// c== capacity 说明队列曾经满了有 offer put 线程阻塞，故需唤醒\n        if (c == capacity)\n            signalNotFull();\n        return x;\n    }\n```\n\n```java\n\tprivate E dequeue() {\n        Node<E> h = head;\n\t\t// 取 head 的后继节点\n        Node<E> first = h.next;\n\t\t// 将 head 节点的 next 指向自己\n        h.next = h; // help GC\n\t\t// 将 head 重新指向头节点\n        head = first;\n\t\t\n        E x = first.item;\n        // 将 item 置为空\n\t\tfirst.item = null;\n        return x;\n    }\n```\n\n此时我们可以看出 LinkedBlockingQueue 中通过移动节点 head last 指针来实现队列的 FIFO; 效果如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnu4l95bqij30xy0bft91.jpg)\n\n\t因为插入和获取头部操作里采用的是两个不同的锁，所以为了保持不同线程不同操作内队列元素个数的一致性所以采用 AtomicInteger 计算而非 int 类型。\n\n\n###### put(E e)\n\n```java\npublic void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        // Note: convention in all put/take/etc is to preset local var\n        // holding count negative to indicate failure unless set.\n        int c = -1;\n        Node<E> node = new Node(e);\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly();\n        try {\n            while (count.get() == capacity) {\n                notFull.await();\n            }\n            enqueue(node);\n            c = count.getAndIncrement();\n            if (c + 1 < capacity)\n                notFull.signal();\n        } finally {\n            putLock.unlock();\n        }\n        if (c == 0)\n            signalNotEmpty();\n    }\n```\n\n###### take()\n\n\n\n\n\n","tags":["jdk"]},{"title":"jdk之ArrayBlockingQueue","url":"/2018/01/24/jdk之ArrayBlockingQueue/","content":"\n##### 概述\n\nArrayBlockingQueue 又称为数组阻塞队列；其基于数组实现的有界阻塞队列，能容纳的元素数量固定，一旦创建就不能再增加其容量。\n\n那么接下来我们会带着以下两个疑问进行分析：\n\n- 如何通过数组实现队列的特性 FIFO ?\n- 如何保证队列插入获取操作的同步 ?\n\n<!-- more -->\n\n##### 定义\n\n首先看下 ArrayBlockingQueue 的属性定义　如下：\n\n```java\n\t/** 固定大小数组用于存储队列元素 */\n    final Object[] items;\n\n    /** 指向下次获取元素的下标 可以理解为指向队列头部 */\n    int takeIndex;\n\n    /** 指向下次插入元素的下标 可以理解为指向队列尾部 */\n    int putIndex;\n\n    /** 当前队列存储元素的个数 */\n    int count;\n\n    /** 定义可重入锁 */\n    final ReentrantLock lock;\n\n    /** 用于控制 take 操作的 condition */\n    private final Condition notEmpty;\n\n    /** 用于控制 put 操作的 condition */\n    private final Condition notFull;\n\n```\n\n##### 构造函数\n\n```java\n\tpublic ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n\n\t/**\n\t * 创建固定容量的阻塞队列并设置访问策略\n\t * @param capacity 队列的最大容量 \n\t * @param fair 队列的访问策略，true为公平锁策略, false为非公平锁；默认为 false\n\t */\n    public ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n\n```\n\n从构造函数可以看出，在创建 ArrayBlockinQueue 实例时，需指定队列最大存储元素的容量并设置内部重入锁的访问策略默认为非公平锁。\n\n##### API\n\n###### add(E e)\n\n```java\n\tpublic boolean add(E e) {\n        return super.add(e);\n    }\n```\n\n从代码可以看出 ArrayBlockingQueue 的 add 方法的实现是基于父类 AbstractQueu 的实现如下：\n\n```java\n\tpublic boolean add(E e) {\n        if (offer(e))\n            return true;\n        else\n            throw new IllegalStateException(\"Queue full\");\n    }\n```\n\n从代码中我们知道 add 方法的主要实现在 offer 方法内（将会在下文分析），如果能够插入成功则返回 true, 否则抛出 IllegalStateException 异常\n\n###### remove()\n\nremove 方法移除队列的头部元素并返回, 其实现是在父类 AbstractQueue 中如下:\n\n```java\n\tpublic E remove() {\n        E x = poll();\n        if (x != null)\n            return x;\n        else\n            throw new NoSuchElementException();\n    }\n```\n\n如上代码知道 remov的主要实现在 poll 方法内；如果获取的头部元素不为空将返回，若为空则抛出 NoSUchElementException 异常。\n\n###### offer(E e)\n\n```java\n\tpublic boolean offer(E e) {\n\t\t// 检查元素是否为空\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n\t\t// 获取锁\n        lock.lock();\n        try {\n\t\t\t// 元素个数达到最大容量时返回 fae\n            if (count == items.length)\n                return false;\n\t\t\t// 执行插入返回 true\n            else {\n                insert(e);\n                return true;\n            }\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n```java\n\tprivate void insert(E x) {\n\t\t// 将元素插入数组指定的位置\n        items[putIndex] = x;\n\t\t// 将 putIndex 移动到下一个位置\n        putIndex = inc(putIndex);\n\t\t// 元素个数加一\n        ++count;\n\t\t// 当前队列非空，唤醒阻塞在获取元素操作上的线程\n        notEmpty.signal();\n    }\n```\n\n从代码可以看出 offer 方法将元素插入队列的逻辑如下：\n\n- 判断元素是否为空\n- 获取锁\n- 判断队列是否已满，若已满则返回 false\n- 通过指针 putIndex 将元素放入数组\n- 移动指针 putIndex 指向下一个位置\n- 队列当前元素个数加一\n- 唤醒阻塞在获取元素操作上的线程\n- 释放锁\n\n###### poll()\n\n```java\n\tpublic E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n\t\t\t// 队列空的时候 返回 null; 非空的时候调用 extract\n            return (count == 0) ? null : extract();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n```java\n\tprivate E extract() {\n        final Object[] items = this.items;\n\t\t// 获取头部的元素\n        E x = this.<E>cast(items[takeIndex]);\n\t\t// 将队列头部置为空\n        items[takeIndex] = null;\n\t\t// 移动头部指针\n        takeIndex = inc(takeIndex);\n\t\t// 队列元素个数减一\n        --count;\n\t\t// 唤醒因队列满而阻塞的插入操作\n        notFull.signal();\n        return x;\n    }\n```\n\npoll 方法获取头部元素逻辑如下：\n\n- 获取锁\n- 判断队列是否为空，若空则返回 null\n- 通过 takeIndex 头部指针获取队列头元素\n- 将队列头部置为空\n- 移动头部指针指向下个位置\n- 队列元素个数减一\n- 唤醒因队列满而阻塞的插入操作\n- 返回头部元素并释放锁\n\n此时我们可以看出 ArrayBlockingQueue 中通过两个指针 takeIndex putIndex 的移动来保证队列的 FIFO,如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnrtuixm5vj30yb09laa5.jpg)\n\n\t我们知道数组有界　在队列中又是如何保证循环利用的呢？\n\n```java\n\tfinal int inc(int i) {\n        return (++i == items.length) ? 0 : i;\n    }\n```\n\n从  inc 方法可以看出在移动 takeindex putindex 指针的时候，当他们到达末尾的时候重新指向头部。\n\n###### offer(E e,long timeout,TimeUnit u)\n\n该方法表示在指定的时间内将元素插入队列中，若失败返回 false 。\n\n```java\n\tpublic boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n\n        checkNotNull(e);\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n\t\t// 获取锁\n        lock.lockInterruptibly();\n        try {\n\t\t\t// 当前元素个数达到队列最大容量时 等待\n            while (count == items.length) {\n                if (nanos <= 0)\n\t\t\t\t\t// 说明已超时 队列满了插入失败 返回 false\n                    return false;\n                nanos = notFull.awaitNanos(nanos);\n            }\n\t\t\t// 执行插入\n            insert(e);\n            return true;\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 offer(e) 实现基本相同，只是在当队列满的情况下会在设置的 timeout 时间内等待。\n\n###### poll(long timeout, TimeUnit unit)\n\n```java\n\tpublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 当队列空的时候等待队列有元素；若等待超时之后还未有元素则返回 false\n            while (count == 0) {\n                if (nanos <= 0)\n                    return null;\n                nanos = notEmpty.awaitNanos(nanos);\n            }\n\t\t\t// 队列非空时　获取头部元素\n            return extract();\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n与 poll() 方法类似，不同之处在于当队列为空的时候等待。\n\n###### put(E e)\n\n```java\n\tpublic void put(E e) throws InterruptedException {\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 队列满的时候\n            while (count == items.length)\n\t\t\t\t// 释放锁当前线程阻塞；等待 take 操作唤醒\n                notFull.await();\n\t\t\t// 队列未满执行插入\n            insert(e);\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 offer 不同之处在于当队列满的时候，当前线程会阻塞直至等待 take 操作唤醒。\n\n###### take()\n\n```java\n\tpublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        // 获取锁\n\t\tlock.lockInterruptibly();\n        try {\n\t\t\t// 队列为空的时候\n            while (count == 0)\n\t\t\t\t// 释放锁当前线程阻塞；等待 put 操作唤醒\n                notEmpty.await();\n\t\t\t// 队列非空　获取头部元素\n            return extract();\n        } finally {\n\t\t\t// 释放锁\n            lock.unlock();\n        }\n    }\n```\n\n该方法与 poll 不同之处在于当队列为空的时候，当前线程会一直阻塞直至等待 put 操作唤醒。\n\n##### 小结\n\n- ArrayBlockingQueue 采用数组作为元素存储，故其为有界队列\n- ArrayBlockingQueue 通过指针 takeIndex putIndex 的移动来实现 FIFO\n- ArrayBlockingQueue 通过定义 ReentrantLock 重入锁来保证插入获取操作的同步。也就是当前若有线程在执行插入操作，则获取操作同样会被阻塞。\n\n\n\n","tags":["jdk"]},{"title":"jdk之BlockingQueue","url":"/2018/01/24/jdk之BlockingQueue/","content":"\n##### 概述\n\n\nBlockingQueue 被称为阻塞队列，除了具备 Queue 的特点外，还支持另外两项重要特性：\n\n```\n\n对于有界队列，当队列满的时候，插入操作会阻塞等待队列可用；\n\n当队列空的时候，获取元素的操作会阻塞等待队列为非空\n\n```\n\n阻塞队列常用于“生产者－消费者”模式的业务场景，生产者就是往阻塞队列中插入元素的线程，消费者就是从阻塞队列中获取元素的线程；当生产者的速度大于消费者的速度，就可能出现有界队列满的情况，此时生产者就会出现阻塞等待状态直到队列中出现空闲；当生产者的速度小于消费者的速度就可能出现空队列的情况，消费者就会出现阻塞等待状态，直到队列中有元素。\n\n<!-- more -->\n\n##### API\n\n###### add(Object o)\n\n该方法是将指定元素插入到队列中，如果队列可插入则返回 true, 否则抛出异常\n\n###### offer(Object o)\n\n该方法将指定元素插入到队列中，如果队列可插入则返回 true, 否则返回 false\n\n###### offer (Object, timeout, timeunit)\n\n该方法在设定的等待时间内如果能将指定元素插入到队列中返回 true, 否则返回 false\n\n###### poll(long timeout,TimeUnit unit)\n\n该方法从队列中取出一个队首的元素，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。超时后，依然没有取得数据则返回NULL\n\n###### put(Object o)\n\n把对象o加入到BlockingQueue里，如果BlockingQueue没有足够空间，则调用此方法的线程会被阻塞等待，直到BlockingQueue里面有空闲空间时再继续执行\n\n###### take( )\n\n取走BlockingQueue里排在首位的对象，如果BlockingQueue为空，则调用此方法的线程会被阻塞等待，直到BlockingQueue里面有新元素被加入后再继续执行\n\n后续将会对 BlockingQueue 的几种实现进行分析.\n\n","tags":["jdk"]},{"title":"Netty客户端链接派发分析","url":"/2018/01/20/Netty客户端链接派发分析/","content":"\n在上篇针对 Netty 的服务端启动过程进行了分析，我们知道服务端包含了两个 NioEventLoopGroup, 一个是 boss 用于接收客户端的请求，一个是 worker 用于处理客户端的读写操作；那么 boss group 是如何将客户端链接通道派发到 worker 呢？本文主要针对这个问题进行分析。\n\n<!-- more -->\n\n##### NioEventLoop\n\n上文中我们知道 netty 主要通过 NioEventLoop 内部的线程处理客户端请求，那么我们接下来详细看下该线程的实现：\n\n```java\nprotected SingleThreadEventExecutor(\n            EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks,\n            RejectedExecutionHandler rejectedHandler) {\n        if (threadFactory == null) {\n            throw new NullPointerException(\"threadFactory\");\n        }\n\n        this.parent = parent;\n        this.addTaskWakesUp = addTaskWakesUp;\n\n        thread = threadFactory.newThread(new Runnable() {\n            @Override\n            public void run() {\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run();\n                    success = true;\n                } catch (Throwable t) {\n                    logger.warn(\"Unexpected exception from an event executor: \", t);\n                } finally {\n                    \n                }\n            }\n        });\n        threadProperties = new DefaultThreadProperties(thread);\n        this.maxPendingTasks = Math.max(16, maxPendingTasks);\n        taskQueue = newTaskQueue();\n        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n    }\n```\n\nNioEventLoop 内部的线程运行时会调用抽象方法 run, 其实现如下：\n\n```java\nprotected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                        // fall through\n                    default:\n                }\n\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\n\n该线程内部以“死循环”的方式 执行 select 后处理 selectedKeys :\n\n```java\nprivate void processSelectedKeys() {\n        if (selectedKeys != null) {\n            processSelectedKeysOptimized();\n        } else {\n            processSelectedKeysPlain(selector.selectedKeys());\n        }\n    }\n```\nselectedKeys 是在NioEventLoop构建时创建的SelectedSelectionKeySet实例，故会调用 processSelectedKeysOptimized 方法如下：\n```java\nprivate void processSelectedKeysOptimized() {\n        for (int i = 0; i < selectedKeys.size; ++i) {\n            final SelectionKey k = selectedKeys.keys[i];\n            // null out entry in the array to allow to have it GC'ed once the Channel close\n            // See https://github.com/netty/netty/issues/2363\n            selectedKeys.keys[i] = null;\n\n            final Object a = k.attachment();\n\n            if (a instanceof AbstractNioChannel) {\n                processSelectedKey(k, (AbstractNioChannel) a);\n            } else {\n                @SuppressWarnings(\"unchecked\")\n                NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;\n                processSelectedKey(k, task);\n            }\n\n            if (needsToSelectAgain) {\n                // null out entries in the array to allow to have it GC'ed once the Channel close\n                // See https://github.com/netty/netty/issues/2363\n                selectedKeys.reset(i + 1);\n\n                selectAgain();\n                i = -1;\n            }\n        }\n    }\n```\n\n其实现是循环遍历 selectedKeys 集合中的 selectedKey 进行处理，那么此时我们会有一个疑惑：\n\n\tselector 选择器中就绪的通道的 selectedKey 是如何添加到 selectedKeys 集合中呢？\n\n让我们回过头在看下 NioEventLoop 开启 selector 的过程：\n\n```java\nprivate SelectorTuple openSelector() {\n        final Selector unwrappedSelector;\n        try {\n\t\t\t// 开启 selector 返回 EpollSelectorImpl 实例\n            unwrappedSelector = provider.openSelector();\n        } catch (IOException e) {\n            throw new ChannelException(\"failed to open a new selector\", e);\n        }\n\n        if (DISABLE_KEYSET_OPTIMIZATION) {\n            return new SelectorTuple(unwrappedSelector);\n        }\n\n        final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();\n\t\t\n\t\t// ......\n\n        final Class<?> selectorImplClass = (Class<?>) maybeSelectorImplClass;\n\n        Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                try {\n                    Field selectedKeysField = selectorImplClass.getDeclaredField(\"selectedKeys\");\n                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(\"publicSelectedKeys\");\n\n                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField);\n                    if (cause != null) {\n                        return cause;\n                    }\n                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField);\n                    if (cause != null) {\n                        return cause;\n                    }\n                    // 将 Selector 实现类的属性 selectedKeys 替换为 netty 自定义的　SelectedSelectionKeySet\n                    // 这样当选择器　有就绪的通道时　就会把 selectKey 添加到　SelectedSelectionKeySet　中\n                    selectedKeysField.set(unwrappedSelector, selectedKeySet);\n                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n                    return null;\n                } catch (NoSuchFieldException e) {\n                    return e;\n                } catch (IllegalAccessException e) {\n                    return e;\n                }\n            }\n        });\n\n        if (maybeException instanceof Exception) {\n            selectedKeys = null;\n            Exception e = (Exception) maybeException;\n            logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, e);\n            return new SelectorTuple(unwrappedSelector);\n        }\n        selectedKeys = selectedKeySet;\n        logger.trace(\"instrumented a special java.util.Set into: {}\", unwrappedSelector);\n        return new SelectorTuple(unwrappedSelector,\n                                 new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));\n    }\n```\n\n从代码中可以看出 NioEventLoop 内部对于 selector 进行了包装，通过反射对 EpollSelectorImpl 实例内字段 selectedKeys publicSelectedKeys 替换为 SelectedSelectionKeySet 实例；这样就保证了当选择器有就绪的通道时就会把 selectKey 添加到 selectedSelectionKeySet 中\n\n我们在回到 processSelectedKeysOptimized 方法中，当集合中有就绪的 selectedKey 时，会获取绑定在该 key 上的附件 attachment 针对服务端来说 也就是 NioServerSocketChannel （注册的时候绑定的)；接下来会调用 processSelectedKey 如下：\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n        final NioUnsafe unsafe = ch.unsafe();\n            try {\n            int readyOps = k.readyOps();\n            // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise\n            // the NIO JDK channel implementation may throw a NotYetConnectedException.\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking\n                // See https://github.com/netty/netty/issues/924\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n\n                unsafe.finishConnect();\n            }\n\n            // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n                // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write\n                ch.unsafe().forceFlush();\n            }\n\n            // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead\n            // to a spin loop\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read();\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n    }\n```\n\n因服务端监听的是 ACCEPT 事件，故当有客户端链接请求就绪的时候会调用 unsafe.read() ,此时 unsafe 实例为 NioMessageSafe:\n\n```java\npublic void read() {\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config();\n            if (!config.isAutoRead() && !isReadPending()) {\n                // ChannelConfig.setAutoRead(false) was called in the meantime\n                removeReadOp();\n                return;\n            }\n\n            final int maxMessagesPerRead = config.getMaxMessagesPerRead();\n            final ChannelPipeline pipeline = pipeline();\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    for (;;) {\n                        int localRead = doReadMessages(readBuf);\n\t\t\t\t\t\t// 当没有客户端通道时退出\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        // stop reading and remove op\n                        if (!config.isAutoRead()) {\n                            break;\n                        }\n\n                        if (readBuf.size() >= maxMessagesPerRead) {\n                            break;\n                        }\n                    }\n                } catch (Throwable t) {\n                    exception = t;\n                }\n                setReadPending(false);\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n\t\t\t\t\t// 触发 pipeline 的 channelRead 事件\n                    pipeline.fireChannelRead(readBuf.get(i));\n                }\n\n                readBuf.clear();\n\t\t\t\t// 触发 pipeline 的 channelReadComplete 事件\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                \n            }\n        }\n```\n\n```java\nprotected int doReadMessages(List<Object> buf) throws Exception {\n\t\t// 获取客户端通道\n        SocketChannel ch = SocketUtils.accept(javaChannel());\n\n        try {\n            if (ch != null) {\n\t\t\t\t// 将 nio socketChannel 封装为 NioSocketChannell 添加到 buf　集合中\n                buf.add(new NioSocketChannel(this, ch));\n                return 1;\n            }\n        } catch (Throwable t) {\n            logger.warn(\"Failed to create a new channel from an accepted socket.\", t);\n\n            try {\n                ch.close();\n            } catch (Throwable t2) {\n                logger.warn(\"Failed to close a socket.\", t2);\n            }\n        }\n\n        return 0;\n    }\n```\n\n其流程为：\n\n- 获取客户端通道 socketChannel 并将其封装为 NioSocketChannel 添加到缓冲中\n- 触发 pipeline 的 channelRead 事件\n- 触发 pipeline 的 channelReadComplete 事件\n\n最终会触发 ServerBootstrapAcceptor handler 的 channelRead 事件如下： \n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n\t\t\t// msg 为 NioSocketChannel 实例\n            final Channel child = (Channel) msg;\n\t\t\t// 将 ServerBootstrap 设置的 childHandler 添加到 NioSocketChannel 的 pipeline 中\n            child.pipeline().addLast(childHandler);\n\n            setChannelOptions(child, childOptions, logger);\n\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n\n            try {\n\t\t\t\t// childGroup 也就是我们所理解的 wrker group\n\t\t\t\t// 执行注册 nioSocketChannel 即将 NioSocektChannel 注册到 worker group 中的 NioEventLoop 的 selector\n                childGroup.register(child).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n                forceClose(child, t);\n            }\n        }\n```\n\nchannelReadComplete 事件在执行过程中最终会调用 NioSocktChannel 的 doBegingRead 方法如下：\n\n```java\nprotected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        if (inputShutdown) {\n            return;\n        }\n\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) {\n\t\t\t// NioSocetChannel 创建的时候 readInterestop 值为 O_READ\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n```java\nprotected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {\n        super(parent, ch, SelectionKey.OP_READ);\n    }\n```\n\n\t至此将 SocketChannel 客户端通道注册到 worker group 中的 NioEventLoop　内的 selector 并监听 OP_READ 事件。\n\n\n此时 netty 内部线程模型如下：\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnn453ozrvj30rh09oq3n.jpg)\n","tags":["netty"]},{"title":"Netty服务端启动源码分析","url":"/2018/01/17/Netty服务端启动源码分析/","content":"\n  Netty 是一个高性能异步事件驱动的 NIO 框架, 因其底层采用的 NIO, 故其启动过程一样可以分为以下几个步骤:\n\n- selector 多路复用选择器开启\n- ServerSocketChannel 通道建立并绑定端口\n- ServerSocketChannel 通道注册到 selector 并监听 accept 事件\n\n在进行服务端启动分析前，我们先看下 netty 的服务端使用示例。\n\n<!-- more -->\n\n##### 示例\n\n```java\n// Configure the server.\nEventLoopGroup bossGroup = new NioEventLoopGroup(1);\nEventLoopGroup workerGroup = new NioEventLoopGroup();\ntry {\n\tServerBootstrap b = new ServerBootstrap();\n\tb.group(bossGroup, workerGroup)\n\t\t.channel(NioServerSocketChannel.class)\n\t \t.handler(new LoggingHandler(LogLevel.INFO))\n\t \t.childHandler(new ChannelInitializer<SocketChannel>() {\n\t\t\t @Override\n\t\t \tpublic void initChannel(SocketChannel ch) throws Exception {\n\t\t\t \tChannelPipeline p = ch.pipeline();\n\t\t\t \tif (sslCtx != null) {\n\t\t\t\t \tp.addLast(sslCtx.newHandler(ch.alloc()));\n\t\t\t \t}\t\n\t\t\t \tp.addLast(new EchoServerHandler());\n\t\t \t}\n\t \t});\n\n\t// Start the server.\n\tChannelFuture f = b.bind(PORT).sync();\n\n\t// Wait until the server socket is closed.\n\tf.channel().closeFuture().sync();\n} finally {\n\t// Shut down all event loops to terminate all threads.\n\tbossGroup.shutdownGracefully();\n\tworkerGroup.shutdownGracefully();\n}\n```\n\n从示例可以看出 netty 服务端通过创建 ServerBootstrap 实例，并对其配置 EventLoopGroup, channel, handler 之后即完成服务端的启动。\n\n##### NioEventLoopGroup - selector的创建\n\n从示例中可以看出 ServerBootstrap 启动的过程中需要两个 EventLoopGroup 实例，从职责上可以将其分为两种 boss 和 worker;前者主要负责客户端链接的接收以及派发到 worker, 后者主要负责客户端链接的读写请求操作。\n\n\n###### NioEventLoopGroup 的创建\n\n```java\n\n\tpublic NioEventLoopGroup(int nThreads) {\n\t\tthis(nThreads, null);\n\t}\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n\t\tthis(nThreads, threadFactory, SelectorProvider.provider());\n\t}\t\t\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider) {\n\t\tthis(nThreads, threadFactory, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);\n\t}\t\n\n\tpublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) {\n\t\tsuper(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());\n\t}\n``` \n```java\nstatic {\n        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(\n                \"io.netty.eventLoopThreads\", NettyRuntime.availableProcessors() * 2));\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.eventLoopThreads: {}\", DEFAULT_EVENT_LOOP_THREADS);\n        }\n    }\n```\n```java\n\tprotected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {\n\t\tsuper(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);\n\t}\n```\n\n加载 MultithreadEventLoopGroup 类时，会先计算默认线程数其值为处理器个数的两倍。\n\n在看下父类MultithreadEventExecutorGroup的构造方法：\n\n```java\n\tprotected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) {\n        if (nThreads <= 0) {\n            throw new IllegalArgumentException(String.format(\"nThreads: %d (expected: > 0)\", nThreads));\n        }\n\n        if (threadFactory == null) {\n            threadFactory = newDefaultThreadFactory();\n        }\n\n        children = new SingleThreadEventExecutor[nThreads];\n\t\t// 创建 事件执行器的选择器\n        if (isPowerOfTwo(children.length)) {\n            chooser = new PowerOfTwoEventExecutorChooser();\n        } else {\n            chooser = new GenericEventExecutorChooser();\n        }\n\n        for (int i = 0; i < nThreads; i ++) {\n            boolean success = false;\n            try {\n\t\t\t// 创建 NioEventLoop\n                children[i] = newChild(threadFactory, args);\n                success = true;\n            } catch (Exception e) {\n                // TODO: Think about if this is a good exception type\n                throw new IllegalStateException(\"failed to create a child event loop\", e);\n            } finally {\n          \t\n\t\t\t}\t \n        }\n\t\t// 非核心代码省略\n    }\n```\n\nnewChild 是抽象方法由子类 NioEventLoopGroup 实现\n\n```java\n\tprotected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception {\n        return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0],\n            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);\n    }\n```\n\n从上述代码中可以看出 NioEventLoopGroup 构建过程中会按指定的线程数创建 NioEventLoop 实例并存储在 children 事件执行器数组中；同时创建了 chooser 实例，chooser 用于在新的客户端链接请求到达的时候从 children 数组中选取 eventLoop 的策略。\n\n###### NioEventLoop的创建\n\n先看下 NioEventLoop 的构造\n\n```java\nNioEventLoop(NioEventLoopGroup parent, ThreadFactory threadFactory, SelectorProvider selectorProvider,\n                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {\n        super(parent, threadFactory, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);\n        if (selectorProvider == null) {\n            throw new NullPointerException(\"selectorProvider\");\n        }\n        if (strategy == null) {\n            throw new NullPointerException(\"selectStrategy\");\n        }\n        provider = selectorProvider;\n        final SelectorTuple selectorTuple = openSelector();\n        // 创建 selector 选择器\n\t\tselector = selectorTuple.selector;\n        unwrappedSelector = selectorTuple.unwrappedSelector;\n        selectStrategy = strategy;\n    }\n```\n\n其父类构造如下：\n\n```java\n\tprotected SingleThreadEventExecutor(\n            EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks,\n            RejectedExecutionHandler rejectedHandler) {\n        if (threadFactory == null) {\n            throw new NullPointerException(\"threadFactory\");\n        }\n\n        this.parent = parent;\n        this.addTaskWakesUp = addTaskWakesUp;\n\t\t// 内部线程\n        thread = threadFactory.newThread(new Runnable() {\n            @Override\n            public void run() {\n               // 此处省略线程的具体执行 \n            }\n        });\n        threadProperties = new DefaultThreadProperties(thread);\n        this.maxPendingTasks = Math.max(16, maxPendingTasks);\n\t\t// 任务队列\n        taskQueue = newTaskQueue();\n        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n    }\n```\n\n```java\n\tprotected Queue<Runnable> newTaskQueue() {\n        return newTaskQueue(maxPendingTasks);\n    }\n\n\tprotected Queue<Runnable> newTaskQueue(int maxPendingTasks) {\n        return new LinkedBlockingQueue<Runnable>(maxPendingTasks);\n    }\n```\n\n从 NioEventLoop 的构造方法可以看出,　其内部包含了一个 thread 以及 taskQueue 并且绑定了一个 selector; taskQueue 用于存储内部执行的任务, thread 该线程主要用来执行 taskQueue 中的任务及处理客户端链接的请求。\n\n\t此时完成了 selector 选择器的创建,并将其绑定到 NioEventLoop 实例\n\n在完成了两个 NioEventLoopGroup 实例的创建之后　我们可以看出 Netty 内部线程模型大概如下：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnju1tz4auj30k106h3yg.jpg)\n\n##### NioServerSocketChannel 通道创建\n\nServerBootstrap 在完成 group, channel, handler 的配置之后调用 bind 完成服务端启动，让我们看下其实现:\n\n```java\n \tpublic ChannelFuture bind(int inetPort) {\n        return bind(new InetSocketAddress(inetPort));\n    }\n\n    public ChannelFuture bind(String inetHost, int inetPort) {\n        return bind(SocketUtils.socketAddress(inetHost, inetPort));\n    }\n\n    public ChannelFuture bind(InetAddress inetHost, int inetPort) {\n        return bind(new InetSocketAddress(inetHost, inetPort));\n    }\n\n    public ChannelFuture bind(SocketAddress localAddress) {\n        validate();\n        if (localAddress == null) {\n            throw new NullPointerException(\"localAddress\");\n        }\n        return doBind(localAddress);\n    }\n\n    private ChannelFuture doBind(final SocketAddress localAddress) {\n        final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel();\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n       \t// 暂时省略 \n    }\n```\n\n从上述代码中可以在 bind 过程中，先完成 channel 的注册及初始化其实现在 initAndRegister 方法中如下：\n\n```java\nfinal ChannelFuture initAndRegister() {\n        Channel channel = null;\n        try {\n\t\t\t// 创建 NioServerSocketChannel\n            channel = channelFactory().newChannel();\n\t\t\t// 初始化 channel\n            init(channel);\n        } catch (Throwable t) {\n            if (channel != null) {\n                // channel can be null if newChannel crashed (eg SocketException(\"too many open files\"))\n                channel.unsafe().closeForcibly();\n            }\n            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);\n        }\n\t\t// channel 注册\n        ChannelFuture regFuture = group().register(channel);\n        if (regFuture.cause() != null) {\n            if (channel.isRegistered()) {\n                channel.close();\n            } else {\n                channel.unsafe().closeForcibly();\n            }\n        }\n        return regFuture;\n    }\n```\n\n从 initAndRegister 方法中可以看出，该方法主要完成以下三件事:\n\n- NioServerSocketChannel 实例的创建\n- NioServerSocketChannel 的初始化\n- NioServerSocketChannel 的注册\n\n###### NioServerSocketChannel的创建\n\n先让我们回过头看下 ServerBootstrap 启动时配置 channel 方法：\n\n```java\n\tpublic B channel(Class<? extends C> channelClass) {\n        if (channelClass == null) {\n            throw new NullPointerException(\"channelClass\");\n        }\n        return channelFactory(new BootstrapChannelFactory<C>(channelClass));\n    }\n\n   \tpublic B channelFactory(ChannelFactory<? extends C> channelFactory) {\n        if (channelFactory == null) {\n            throw new NullPointerException(\"channelFactory\");\n        }\n        if (this.channelFactory != null) {\n            throw new IllegalStateException(\"channelFactory set already\");\n        }\n\n        this.channelFactory = channelFactory;\n        return self();\n    }\n```\n\n也就是说此时 channelFactory 实例为 BootstrapChannelFactory, 接下来我们看下其实现：\n\n```java\nprivate static final class BootstrapChannelFactory<T extends Channel> implements ChannelFactory<T> {\n        private final Class<? extends T> clazz;\n\n        BootstrapChannelFactory(Class<? extends T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T newChannel() {\n            try {\n                return clazz.getConstructor().newInstance();\n            } catch (Throwable t) {\n                throw new ChannelException(\"Unable to create Channel from class \" + clazz, t);\n            }\n        }\n    }\n```\n\n故 channelFactory.newChannel() 方法也就是创建指定了 channel class 的实例也就是 NioServerSocketChannel 实例，接下来看下其构造实现：\n\n```java\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) {\n        try {\n            return provider.openServerSocketChannel();\n        } catch (IOException e) {\n            throw new ChannelException(\n                    \"Failed to open a server socket.\", e);\n        }\n    }\n\n    private final ServerSocketChannelConfig config;\n\n    public NioServerSocketChannel() {\n        this(newSocket(DEFAULT_SELECTOR_PROVIDER));\n    }\n\n    public NioServerSocketChannel(SelectorProvider provider) {\n        this(newSocket(provider));\n    }\n\n    public NioServerSocketChannel(ServerSocketChannel channel) {\n        super(null, channel, SelectionKey.OP_ACCEPT);\n        config = new NioServerSocketChannelConfig(this, javaChannel().socket());\n    }\n```\n\n其父类 AbstractNioChannel AbstractChannel 构造方法如下：\n\n```java\nprotected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {\n        super(parent);\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false);\n        } catch (IOException e) {\n        }\n    }\n```\n\n```java\nprotected AbstractChannel(Channel parent) {\n        this.parent = parent;\n        unsafe = newUnsafe();\n        pipeline = newChannelPipeline();\n    }\n```\n\n从 NioServerSocketChannel 的构造方法看出其主要流程如下:\n\n- 通过 newSocket 方法创建了 ServerSocketChannel 实例并设置为非阻塞模式\n- 设置了待监听事件 OP_ACCEPT\n- 创建 unsafe 实例为 NioMessageUnsafe\n- 创建 pipeline 实例为 DefaultChannelPipeline\n\n\n\t此时完成了 nio 中的 ServerSocketChannel 的创建\n\n###### NioServerSocktChannel的初始化\n\ninit 为抽象方法由子类实现\n\n```java\nvoid init(Channel channel) throws Exception {\n        final Map<ChannelOption<?>, Object> options = options();\n        synchronized (options) {\n            setChannelOptions(channel, options, logger);\n        }\n\n        final Map<AttributeKey<?>, Object> attrs = attrs();\n        synchronized (attrs) {\n            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n                @SuppressWarnings(\"unchecked\")\n                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n                channel.attr(key).set(e.getValue());\n            }\n        }\n\n        ChannelPipeline p = channel.pipeline();\n\n        final EventLoopGroup currentChildGroup = childGroup;\n        final ChannelHandler currentChildHandler = childHandler;\n        final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n        synchronized (childOptions) {\n            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));\n        }\n        synchronized (childAttrs) {\n            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));\n        }\n\n        p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(final Channel ch) throws Exception {\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n\n                logger.info(\"ServerBootStrap init channel addLast ChannelInitializer init channel\");\n                ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n    }\n```\n\ninit 主要设置 channel 的 attr 和　options;并在 pipeline 中添加 ChannelInitializer handler\n\n###### NioServerSocketChannel的注册\n\n在完成 channel 的创建及初始化之后即调用 NioEventLoopGroup.register(channel) 方法完成 channel 的注册。\n\n```java\n\t@Override\n    public EventLoop next() {\n        return (EventLoop) super.next();\n    }\n\n    @Override\n    public ChannelFuture register(Channel channel) {\n        return next().register(channel);\n    }\n```\n\nnext() 方法是按照 chooser 选取策略从 NioEventLoopGroup 中获取一个 NioEventLoop 实例;跟踪 register 方法最终调用的是 unsafe.register 方法如下:\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n\t// ......\n\tAbstractChannel.this.eventLoop = eventLoop;\n\n\tif (eventLoop.inEventLoop()) {\n\t\tregister0(promise);\n\t} else {\n\t\ttry {\n\t\t\teventLoop.execute(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tregister0(promise);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (Throwable t) {\n\t   }\n\t}\n}\n\nprivate void register0(ChannelPromise promise) {\n\ttry {\n\t\t// ......\n\t\tboolean firstRegistration = neverRegistered;\n\t\tdoRegister();\n\n\t\tneverRegistered = false;\n\t\tregistered = true;\n\n\t\tpipeline.invokeHandlerAddedIfNeeded();\n\n\t\tsafeSetSuccess(promise);\n\t\tpipeline.fireChannelRegistered();\n\t\t\n\t\t// ......                \n\t} catch (Throwable t) {\n\t}\n}\n```\n\n调用了由子类实现的 doRegister() 方法如下：\n\n```java\n@Override\nprotected void doRegister() throws Exception {\n\tboolean selected = false;\n\tfor (;;) {\n\ttry {\n\t\t// ServerSocketChannel 注册到 selector\n\t\tselectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n\t\treturn;\n\t} catch (CancelledKeyException e) {\n\t\tif (!selected) {\n\t\t\t// Force the Selector to select now as the \"canceled\" SelectionKey may still be\n\t\t\t// cached and not removed because no Select.select(..) operation was called yet.\n\t\t\teventLoop().selectNow();\n\t\t\tselected = true;\n\t\t} else {\n\t\t\t// We forced a select operation on the selector before but the SelectionKey is still cached\n\t\t\t// for whatever reason. JDK bug ?\n\t\t\tthrow e;\n\t\t}\n\t}\n\t}\t\n}\n```\n\n其实现就是将 ServerSocketChannel 注册到 selector 上，并以自身NioServerSocketChannel 作为附件；\n\n\t注意：此时注册的时候　监听的事件　并不是 ACCEPT; 而是 0\n\n##### NioServerSocketChannel 端口绑定\n\n上文中在完成了 channel 的注册之后，我们在回头看 doBind 的实现:\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n        final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel();\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        promise.setFailure(cause);\n                    } else {\n                        promise.executor = channel.eventLoop();\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n    }\n```\n\n在 channel 注册完成后会执行 doBind0 \n\n```java\nprivate static void doBind0(\n            final ChannelFuture regFuture, final Channel channel,\n            final SocketAddress localAddress, final ChannelPromise promise) {\n        channel.eventLoop().execute(new Runnable() {\n            @Override\n            public void run() {\n                if (regFuture.isSuccess()) {\n                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n                } else {\n                    promise.setFailure(regFuture.cause());\n                }\n            }\n        });\n    }\n```\n\n会调用 channel.bind()　跟踪发现最终会调用 unsafe.bind() 方法如下：\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n            assertEventLoop();\n\t\t\t// ......\n            boolean wasActive = isActive();\n            try {\n\t\t\t// 绑定地址端口\n                doBind(localAddress);\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n\n            if (!wasActive && isActive()) {\n\t\t\t// 绑定端口成功之后　触发 pipeline handler 的 channel active 事件\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive();\n                    }\n                });\n            }\n\n            safeSetSuccess(promise);\n        }\n```\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n        if (PlatformDependent.javaVersion() >= 7) {\n            javaChannel().bind(localAddress, config.getBacklog());\n        } else {\n            javaChannel().socket().bind(localAddress, config.getBacklog());\n        }\n    }\n```\n\n\t此时完成了 ServerSocketChannel 的服务端地址绑定\n\n##### NioServerSocketChannel 注册 ACCEPT 事件\n\n上文中在完成 bind 操作之后，会触发 channelPipeline 的 channel active 事件　最终调用了 channel 的 doBeginRead 方法\n\n```java\nprotected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        if (inputShutdown) {\n            return;\n        }\n\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) {\n\t\t\t// 将 selectionKey 添加 ACCEPT 事件的监听\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n\t至此完成了 ServerSocketChannel 注册到 selector 并让其监听 ACCEPT　事件；服务端也启动完毕。\n\n##### 小结\n\n对Netty的服务端启动分析完之后，大概认识了其包含的一些组件以及各组件的作用\n\n- ServerBootstrap ：该类是服务端启动的引导类，其主要用于配置 Netty 的各个组件\n- NioEventLoopGroup : 该类用于管理 NioEventLoop , 并提供了 Selector 选择器创建的入口并将其绑定到 NioEventLoop 实例\n- NioEventLoop : 该类内部绑定了一个线程以及一个任务队列用于处理 register bind的相关任务及客户端处理（后续会详细分析）\n- NioServerSocketChannel : 该类是对 ServerSocketChannel 的一个包装其内部包含了 unsafe channelPipeline 实例\n- Unsafe : 该类提供了底层的 register bind write read 等操作\n- DefaultChannelPipeline : 该类是个双向链表结构，其主要作用是在通道注册链接　读写的操作之后会触发相应的事件\n\n\n\n\n","tags":["netty"]},{"title":"Jdk之CountDownLatch源码分析","url":"/2018/01/11/Jdk之CountDownLatch源码分析/","content":"##### 概述\n\n> CountdownLatch 是 JDK 并发包中提供的并发工具类，其允许一个或多个线程等待其他线程完成操作。常用作将一个任务拆分成多个子任务同时执行，只有子任务都执行完毕主线程才往下执行。\n\n<!-- more -->\n\n##### 用例\n\n```java\npublic class CountDownLatchTest {\n\n    static class Task implements Runnable {\n\n        private CountDownLatch countDownLatch;\n\n        public Task (CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread() + \" done.\");\n            countDownLatch.countDown();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n\n        for (int i = 0; i < 3; i++) {\n            new Thread(new Task(countDownLatch)).start();\n        }\n\n        countDownLatch.await();\n\n        System.out.println(\"main done.\");\n    }\n}\n```\n\n输出结果如下：\n\n```\nThread[Thread-0,5,main] done.\nThread[Thread-1,5,main] done.\nThread[Thread-2,5,main] done.\nmain done.\n```\n\n##### 实现\n\n###### Sync\n\n```java\n\tprivate static final class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = 4982264981922014374L;\n\n        Sync(int count) {\n\t\t\t// 设置计数值\n            setState(count);\n        }\n\n        int getCount() {\n            return getState();\n        }\n\n        protected int tryAcquireShared(int acquires) {\n\t\t\t// 只有同步状态值为0的情况下获取共享锁成功\n            return (getState() == 0) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int releases) {\n            // Decrement count; signal when transition to zero\n            for (;;) {\n                int c = getState();\n                if (c == 0)\n                    return false;\n\t\t\t\t// 每次释放锁的时候计数值减一 只有值为0的时候才表示释放成功\n                int nextc = c-1;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n    }\n```\n\n###### await\n\n```java\n\tpublic void await() throws InterruptedException {\n\t\t// 主线程调用 await 发生阻塞，是因为获取锁失败被添加到同步队列线程被挂起\n        sync.acquireSharedInterruptibly(1);\n    }\n```\n\n###### countDown\n\n```java\n\tpublic void countDown() {\n\t\t// 计数减一　等同于释放一次锁,只有计数为0时才会唤醒阻塞的主线程\n        sync.releaseShared(1);\n    }\n```\n\n###### QA\n\n- CountDownLatch 内部为什么采用共享锁机制?\n\n\t个人认为是从其提供的使用场景考虑，将任务拆分为多个子任务也就是让多个线程并发执行；所以采用共享锁实现。\n","tags":["jdk"]},{"title":"Jdk之ThreadPoolExecutor源码分析","url":"/2018/01/09/Jdk之ThreadPoolExecutor源码分析/","content":"##### 概述\n\n线程池在 JAVA 中是运用场景最多的并发框架，合理的运用线程池能够带来以下好处：\n\n- 降低资源消耗。\n- 提高响应速度。\n- 提高线程的可管理性。\n\n<!-- more -->\n\n##### 参数定义\n\n线程池在定义时需指定以下参数：\n\n- corePoolSize : 线程池的核心线程数。\n- maximumPoolSize : 线程池允许创建的最大线程数\n- keepAliveTIme : 线程池的工作线程空闲后，保持存活的时间\n- TimeUnit : 线程活动保持时间的单位\n- threadFactory : 用于创建工作线程的工厂\n- workQueue : 用于存储等待执行的任务的阻塞队列; 可以选择以下几个阻塞队列：\n\n> - ArrayBlockingQueue : 基于数组的有界队列\n> - LinkedBlockingQueue : 基于链表的无界队列，若采用此类型队列则 maximumPoolSize　没有意义\n> - SynchronousQueue : 不存储元素的阻塞队列\n\n- RejectedExecutionHandler : 饱和策略，当线程池达到最大线程数以及阻塞队列满了的情况下，说明线程池处于饱和状态，此时必须采取一种策略处理提交的新任务。有以下几种策略：\n\n> - AbortPolicy : 直接抛出异常\n> - CallerRunsPolicy : 采用调用者所在线程处理任务\n> - DiscardOldestPolicy : 丢弃队列最近的一个任务,并执行当前任务\n> - DiscardPolicy : 不处理丢弃\n\n##### 原理\n\n现以一张示意图说明线程池的运行原理(引用至网上的)\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fnblego97nj30fd0dkq3h.jpg)\n\n其运行流程如下：\n\n- 提交任务时，线程池判断当前运行的工作线程数小于 corePoolSize 时，将任务封装为 worker 对象来执行任务。\n- 当运行的工作线程数大于 corePoolSize 时，则将任务添加到 workerQueue 阻塞队列中；此时若添加队列失败（说明采用的是有界队列，队列已满)，线程池会创建 worker 对象来执行任务\n- 当运行的工作线程数大于 maximumPoolSize 时，任务将拒绝执行\n- 工作线程会已轮询的方式从阻塞队列中获取待执行的任务；若指定了 keepAliveTime 参数会以 poll() 的方式获取在指定的时间内若无可执行的任务，工作线程将会销毁\n\n##### 实现\n\n接下来看下具体如何实现的，首先让我们先看下线程池中如何计算当前运行线程数的以及线程池的运行状态\n\n```java\n\tprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING    = -1 << COUNT_BITS;\n    private static final int SHUTDOWN   =  0 << COUNT_BITS;\n    private static final int STOP       =  1 << COUNT_BITS;\n    private static final int TIDYING    =  2 << COUNT_BITS;\n    private static final int TERMINATED =  3 << COUNT_BITS;\n\n\t// 计算线程池的状态\n\tprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\n\t// 计算线程池中的工作线程数\n    private static int workerCountOf(int c)  { return c & CAPACITY; }\n    private static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n线程池通过 ctl 采用 int 的高３位表示线程池的运行状态，低29位表示当前线程池中的线程数；\n\n> 线程池的状态包括:\n> - RUNNING 运行中，该状态会接收新的任务并处理阻塞等待队列中的任务\n> - SHUTDOWN 关闭，通常时执行 shutdown 方法，该状态下线程池不再接收新的任务；等待线程池中和队列中的任务完成\n> - STOP 已停止，通常是执行过 shutdownNow 方法，此时线程池不接收新的任务队列中的任务也不再执行并尝试终止线程池中的线程\n> - TIDYING \n> - TERMINATED\n\n###### 执行任务(execute) \n\n```java\n\tpublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        /*\n         * Proceed in 3 steps:\n         *\n         * 1. If fewer than corePoolSize threads are running, try to\n         * start a new thread with the given command as its first\n         * task.  The call to addWorker atomically checks runState and\n         * workerCount, and so prevents false alarms that would add\n         * threads when it shouldn't, by returning false.\n         *\n         * 2. If a task can be successfully queued, then we still need\n         * to double-check whether we should have added a thread\n         * (because existing ones died since last checking) or that\n         * the pool shut down since entry into this method. So we\n         * recheck state and if necessary roll back the enqueuing if\n         * stopped, or start a new thread if there are none.\n         *\n         * 3. If we cannot queue task, then we try to add a new\n         * thread.  If it fails, we know we are shut down or saturated\n         * and so reject the task.\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n\t\t\t// 工作线程数小于 corePoolSize 创建线程执行任务\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n\t\t// 检查线程池状态是否为运行中；如果为运行中则插入队列中\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n\t\t\t// double check 再次检查线程池的状态; 此时若为非运行状态则将任务从队列中移除\n            if (! isRunning(recheck) && remove(command))\n\t\t\t\t// 拒绝执行任务\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n\t\t// 队列若满了 则创建新的线程执行任务\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n从源码方法的注释中可以看出 execute 方法主要包括３步：\n\n- 如果少于 corePoolSize 的线程正在运行，则尝试创建新的线程并将接收的任务作为其第一个任务启动\n- 如果任务成功插入队列中，仍然需要检查线程池状态因为这个时候有可能关闭了这个线程池\n- 如果任务不能入队，则创建新的线程执行，如果创建失败则拒绝处理\n\n```java\n\tprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n\t\t\t// 检查线程池状态　队列是否为空\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                int wc = workerCountOf(c);\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n\t\t\t\t\t// 检查是否超过核心线程数或最大线程数\n                    return false;\n\t\t\t\t// 新增工作线程数 成功则退出循环\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n\t\t\t\t// 若 workerCount 被其他线程修改 则继续循环\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            final ReentrantLock mainLock = this.mainLock;\n\t\t\t// 创建 worker　\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n                mainLock.lock();\n                try {\n\t\t\t\t\t// 再次检查线程池状态,操作前先获取锁防止线程池关闭\n                    int c = ctl.get();\n                    int rs = runStateOf(c);\n\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n\t\t\t\t\t\t// 添加到 workers 集合\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n\t\t\t\t\t\t// workr 添加成功\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n\t\t\t\t\t// worker 启动执行任务\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n```\n接下来看下关于 Worker 的定义\n\n```java\nprivate final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable\n    {\n        /** Thread this worker is running in.  Null if factory fails. */\n        final Thread thread;\n        /** Initial task to run.  Possibly null. */\n        Runnable firstTask;\n        /** Per-thread task counter */\n        volatile long completedTasks;\n\n        /**\n         * Creates with given first task and thread from ThreadFactory.\n         * @param firstTask the first task (null if none)\n         */\n        Worker(Runnable firstTask) {\n            setState(-1); // inhibit interrupts until runWorker\n            this.firstTask = firstTask;\n            this.thread = getThreadFactory().newThread(this);\n        }\n\n        /** Delegates main run loop to outer runWorker  */\n        public void run() {\n            runWorker(this);\n        }\n}\n```\n\n从代码中可以看出 Worker 实现了 Runnable,构建的时候通过线程工厂启动了一个线程并将自身作为任务传递到该线程，所以在 addWorker 方法中执行 t.start() 后会执行 runWorker(this) 方法。\n\n```java\n\tfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n\t\t\t// task 不为空或阻塞队列中还有任务的情况下循环执行\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // If pool is stopping, ensure thread is interrupted;\n                // if not, ensure thread is not interrupted.  This\n                // requires a recheck in second case to deal with\n                // shutdownNow race while clearing interrupt\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n\t\t\t\t\t\t// 执行任务\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n\t\t\t\t\t// 任务处理完后置为空　已处理完的任务数加１\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n```java\n\tprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n\t\t\t// 线程池已关闭或队列为空　则工作线程数减一 返回null 此时 worker 将会销毁\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n\n            boolean timed;      // Are workers subject to culling?\n\n            for (;;) {\n                int wc = workerCountOf(c);\n\t\t\t\t// worker 线程是否销毁\n\t\t\t\t// allowCoreThreadTimeOut 表示是否允许核心线程在空闲状态下自行销毁 默认为false\n\t\t\t\t// 此处判断默认情况下　若超过了核心线程数则允许自行销毁\n                timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n                if (wc <= maximumPoolSize && ! (timedOut && timed))\n                    break;\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n\n            try {\n\t\t\t\t// workQueue.take 若队列为空当前线程将会被挂起等待任务加入被唤醒\n\t\t\t\t// workQueue.poll 若在 keepALiveTime 时间内阻塞队列还是没有任务则返回null\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\nworker 在执行的过程中以自旋的方式从队列中获取任务并执行，在指定存活时间内若队列为空则获取任务为空说明无等待任务　此时跳出循环 执行 worker 的退出销毁\n\n###### 提交任务(submit)\n\n采用 submit() 方法提交的任务，可以通过其返回结果 Future 判断任务是否已完成以及获取任务的返回值。\n\n> submit 方法参数支持 Callable, Runnable 两种类型，当参数类型为 Runnable 时会包装成 RunnableAdapter 类，该类同样实现了 Callable 接口；所以下面我们主要分析下 submit(Callable task) 方法。\n\n```java\n\tpublic <T> Future<T> submit(Callable<T> task) {\n        if (task == null) throw new NullPointerException();\n        RunnableFuture<T> ftask = newTaskFor(task);\n        execute(ftask);\n        return ftask;\n    }\n```\n\nsubmit 方法通过将 Callable 封装成一个　FutureTask  对象后，调用了 execute 方法；也就是其处理逻辑与 execute 方法的不同之处在于 FutureTask 的 run 方法；　接下来我们看下 FutureTask 的定义与 run 方法处理逻辑:\n\n> FutureTask 的属性字段以及状态说明：\n\n```java\n \t* Possible state transitions:\n     * NEW -> COMPLETING -> NORMAL\n     * NEW -> COMPLETING -> EXCEPTIONAL\n     * NEW -> CANCELLED\n     * NEW -> INTERRUPTING -> INTERRUPTED\n     */\n    private volatile int state;\n\t// 初始状态\n    private static final int NEW          = 0;\n\t// 已完成\n    private static final int COMPLETING   = 1;\n\t// 完成后的状态\n    private static final int NORMAL       = 2;\n\t// 异常\n    private static final int EXCEPTIONAL  = 3;\n\t// 取消\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    // 待执行的任务\n    private Callable<V> callable;\n\t// 任务返回值\n    private Object outcome; // non-volatile, protected by state reads/writes\n\t// 当前执行线程\n    private volatile Thread runner;\n\t// 因执行 get 操作获取返回值时被挂起的调用方线程链表\n    private volatile WaitNode waiters;\n```\n\n> FutureTask 的构造：\n\n```java\n\tpublic FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n\t\t// 初始状态\n        this.state = NEW;       // ensure visibility of callable\n    }\n```\n\n> FutureTask run 方法：\n\n```java\n\tpublic void run() {\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n\t\t\t\t\t// 执行任务 获取返回值\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n\t\t\t\t\t// 任务执行成功 未出现异常设置返回结果\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\n```java\n\tprotected void set(V v) {\n\t\t// 将状态更新为 COMPLETING \n\t\tif (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n\t\t\t// 将返回结果赋值 outcome\n\t\t\toutcome = v;\n\t\t\t// 将状态更新为 NORMAL\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n\t\t\t// 将 waiters 链表上的阻塞线程唤醒\n            finishCompletion();\n        }\n    }\n```\n\n```java\n\tprivate void finishCompletion() {\n        // assert state > COMPLETING;\n        for (WaitNode q; (q = waiters) != null;) {\n            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n                for (;;) {\n\t\t\t\t\t// 获取 waiters 链表上节点的线程并唤醒\n                    Thread t = q.thread;\n                    if (t != null) {\n                        q.thread = null;\n                        LockSupport.unpark(t);\n                    }\n                    WaitNode next = q.next;\n                    if (next == null)\n                        break;\n                    q.next = null; // unlink to help gc\n                    q = next;\n                }\n                break;\n            }\n        }\n\n        done();\n\n        callable = null;        // to reduce footprint\n    }\n```\n\n从代码中可以看出 run 方法处理流程如下：\n\n- 执行任务存储返回结果\n- 更新状态为已完成\n- 唤醒被挂起的调用方\n\n> FutureTask get 方法\n\n```java\n\tpublic V get() throws InterruptedException, ExecutionException {\n        int s = state;\n        if (s <= COMPLETING)\n\t\t// 若任务还未执行完\n            s = awaitDone(false, 0L);\n        return report(s);\n    }\n```\n\n```java\n\tprivate int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        WaitNode q = null;\n        boolean queued = false;\n        for (;;) {\n            if (Thread.interrupted()) {\n                removeWaiter(q);\n                throw new InterruptedException();\n            }\n\n            int s = state;\n            if (s > COMPLETING) {\n                if (q != null)\n                    q.thread = null;\n\t\t\t\t// 任务已完成则返回\n                return s;\n            }\n            else if (s == COMPLETING) // cannot time out yet\n                Thread.yield();\n            else if (q == null)\n\t\t\t\t// 创建 waitNode\n                q = new WaitNode();\n            else if (!queued)\n\t\t\t\t// 加入等待队列中\n                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                     q.next = waiters, q);\n            else if (timed) {\n                nanos = deadline - System.nanoTime();\n                if (nanos <= 0L) {\n                    removeWaiter(q);\n                    return state;\n                }\n                LockSupport.parkNanos(this, nanos);\n            }\n            else\n\t\t\t\t// 挂起当前线程\n                LockSupport.park(this);\n        }\n    }\n```\n\n当调用方执行 future.get() 方法时，会先判断任务是否执行完毕，若在处理中的时候，先创建 waitNode 并将其加入到等待队列中，最后将当前调用方线程挂起，等待处理完后唤醒。\n\n###### 线程池关闭\n\n```java\n\tpublic void shutdown() {\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            checkShutdownAccess();\n\t\t\t// 将线程池状态修改为 SHUTDOWN\n            advanceRunState(SHUTDOWN);\n\t\t\t// 将空闲的工作线程终止\n            interruptIdleWorkers();\n            onShutdown(); // hook for ScheduledThreadPoolExecutor\n        } finally {\n            mainLock.unlock();\n        }\n        tryTerminate();\n    }\n```\n\n```java\nprivate void interruptIdleWorkers(boolean onlyOne) {\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            for (Worker w : workers) {\n                Thread t = w.thread;\n                if (!t.isInterrupted() && w.tryLock()) {\n                    try {\n\t\t\t\t\t\t// 空闲的线程执行中断\n                        t.interrupt();\n                    } catch (SecurityException ignore) {\n                    } finally {\n                        w.unlock();\n                    }\n                }\n                if (onlyOne)\n                    break;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n    }\n```\n\n##### 参考资料\n\n- JAVA 并发编程的艺术\n- [占小狼-深入分析java线程池的实现原理](https://www.jianshu.com/p/87bff5cc8d8c)\n- [线程池ThreadPoolExecutor、Executors参数详解与源代码分析](http://www.cnblogs.com/nullzx/p/5184164.html)(本文中对corePoolSize 线程在线程池中的比喻解释很形象详细可以看看) \n","tags":["jdk"]},{"title":"Jdk之ReentrantLock源码分析","url":"/2018/01/08/Jdk之ReentrantLock源码分析/","content":"\n##### 概述\n\nReentrantLock 是重入锁，也就是说支持重新进入的锁，也表示同一线程在获取锁之后可以再次获取锁。\n\n> synchronizer 关键字是隐式的支持重进入的，比如说采用 synchronizer 修饰的递归方法，在方法执行时，执行线程在获取锁之后依然可以连续多次获得锁。\n\nReentrantLock 支持获取锁时的公平和非公平性的选择，默认为非公平性锁。\n\n<!-- more -->\n\n##### 非公平锁\n\n\t非公平锁是指在获取锁的过程中，新进入的线程有机率比同步队列中线程优先获取锁。\n\n###### 锁的获取\n\n```java\nstatic final class NonfairSync extends Sync {\n        private static final long serialVersionUID = 7316153563782823691L;\n\t\t\n        final void lock() {\n\t\t\tif (compareAndSetState(0, 1))\n\t\t\t\t// 获取锁成功并绑定当前线程\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n\t\t\t\t// 再次获取锁\n                acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            return nonfairTryAcquire(acquires);\n        }\n    }\n```\n\n```java\n\tfinal boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (compareAndSetState(0, acquires)) {\n                    // 获取锁成功 绑定当前线程\n\t\t\t\t\tsetExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n\t\t\t\t// 当前线程为获取锁的线程 则累加同步状态值\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n```\n\n从代码中可以看出，重入锁新增了多次获取锁的处理逻辑：通过判断当前线程是否为获取锁的线程，如果时获取锁的线程则将同步状态值累加。\n\n###### 锁的释放\n\n```java\n\tprotected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) {\n\t\t\t\t// 只有同步状态值为0 才完成真正的释放\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n\n从 tryRelease 方法中可以看出，只有在同步状态值为0 才完成真正的释放返回 true;也就是说 若线程获取锁了 n 次，那么前 n-1 次均是释放失败也就是返回 false.\n\n##### 公平锁\n\n\t公平锁可以理解为在绝对时间上，先对锁进行获取的线程一定先被满足，也可以理解为等待时间最长的线程最优先获取锁。\n\n###### 锁的获取\n\n```java\n\tstatic final class FairSync extends Sync {\n        private static final long serialVersionUID = -3000897897090466540L;\n\n        final void lock() {\n            acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n从代码中可以看出公平锁在获取锁的过程多了一个判断条件 hasQueuedPredecessors(), 实现如下：\n\n```java\npublic final boolean hasQueuedPredecessors() {\n        // The correctness of this depends on head being initialized\n        // before tail and on head.next being accurate if the current\n        // thread is first in queue.\n        Node t = tail; // Read fields in reverse initialization order\n        Node h = head;\n        Node s;\n        return h != t &&\n            ((s = h.next) == null || s.thread != Thread.currentThread());\n    }\n```\n\nhasQueuedPredecessors 主要判断是否有其他线程等待获取锁的时间要比当前线程长，也即是当前同步队列的头节点的后驱节点所绑定的线程是否为当前线程；也可以理解为新进入的线程只有在同步队列上的等待线程均处理完毕才可以获取锁，否则会加入到同步队列中。\n\n###### 锁的释放\n\n与公平锁的释放一样。\n\n##### 公平锁与非公平锁对性能的影响\n\n- 公平锁保证了锁的获取按照 FIFO 原则，但会造成大量线程的切换\n- 非公平锁可能会造成线程\"饥饿\"的现象（也就是线程长时间获取不到锁　一直处于阻塞状态），但极少的线程切换会保证更大的吞吐量。\n","tags":["jdk"]},{"title":"Jdk之AbstractQueuedSynchronizer源码分析","url":"/2018/01/05/Jdk之AbstractQueuedSynchronizer源码分析/","content":"##### 概述\n\n> 队列同步器 (AbstractQueuedSynchronizer) 是用来构建锁或其他同步组件的基础框架，使用了一个 int 成员变量表示同步状态,　通过内置的 FIFO 队列来完成资源获取线程的排队工作。\n\n###### 定义\n\n```java\npublic abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {\n    \n    protected AbstractQueuedSynchronizer() { }\n    \n    /**\n     * 同步队列头结点\n     */\n    private transient volatile Node head;\n\n    /**\n     * 同步队列尾节点\n     */\n    private transient volatile Node tail;\n\n    /**\n     * 同步状态\n     */\n    private volatile int state;\n}\n```\n\n<!-- more -->\n\n> 内置队列节点定义如下:\n\n```java\nstatic final class Node {\n        /** waitStatus value to indicate thread has cancelled */\n        static final int CANCELLED =  1;\n        /** waitStatus value to indicate successor's thread needs unparking */\n        static final int SIGNAL    = -1;\n        /** waitStatus value to indicate thread is waiting on condition */\n        static final int CONDITION = -2;\n        /**\n         * waitStatus value to indicate the next acquireShared should\n         * unconditionally propagate\n         */\n        static final int PROPAGATE = -3;\n\n\t\t/**\n\t\t * 节点等待状态\n\t\t */\n        volatile int waitStatus;\n\n        /**\n\t\t * 节点的前置节点\n         */\n        volatile Node prev;\n\n        /**\n \t\t * 节点的后置节点\n         */\n        volatile Node next;\n\n        /**\n         * 绑定节点对应的线程 \n         */\n        volatile Thread thread;\n\n        /**\n\t\t *\n         */\n        Node nextWaiter;\n\n        /**\n         * Returns true if node is waiting in shared mode\n         */\n        final boolean isShared() {\n            return nextWaiter == SHARED;\n        }\n\n        /**\n         */\n        final Node predecessor() throws NullPointerException {\n            Node p = prev;\n            if (p == null)\n                throw new NullPointerException();\n            else\n                return p;\n        }\n    }\n```\n从 Node 的定义可以看出 AQS 内置的是一个双向队列，当线程获取锁失败的时候同步器会将当前线程及等待状态构造成一个节点加入到同步队列中。\n\n> 等待状态 waitStatus 取值范围如下：\n\n- CANCELLED = 1; 说明由于同步队列中等待的线程等待超时或被中断，需要取消等待\n- SIGNAL = -1; 等待触发状态，同时该节点的后继节点的线程处于等待状态，当前节点的线程如果释放了锁,将会唤醒后继节点\n- INITIAL = 0; 初始状态\n\n##### 独占模式\n\t\n\t独占模式下允许当前只有一个线程获取锁。\n\n###### 获取锁\n\n> 通过调用同步器的 acquire(int args) 方法获取锁, 该方法对中断不敏感，也就是当线程获取锁失败后加入同步队列中，后续对线程进行中断操作时，线程不会从队列中移除。\n\n```java\npublic final void acquire(int arg) {\n\tif (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    \tselfInterrupt();\n}\n```\n\n获取锁的主要逻辑如下：\n\n\n- 调用自定义实现 tryAcquire(arg) 方法, 尝试获取锁；如果获取锁失败则往下执行\n- addWaiter 以独占模式构造同步节点并将其添加到同步队列尾部\n- acquireQueued 让该节点以“死循环”的方式尝试再次获取锁，如果获取失败则将该节点对应的线程挂起，等待前置节点的唤醒\n\n\n```java\n\tprivate Node addWaiter(Node mode) {\n        // 将当前线程以独占模式创建同步节点\n\t\tNode node = new Node(Thread.currentThread(), mode);\n        // 当前队列的尾节点为新增节点的前置节点\n\t\tNode pred = tail;\n        if (pred != null) { // 前置节点不为空　说明同步队列已经初始化\n\t\t\t// 将新增节点的前置节点指向 pred\n            node.prev = pred;\n\t\t\t// 将同步队列的尾节点移动指向新增的节点\n            if (compareAndSetTail(pred, node)) {\n\t\t\t\t// 将 pred 的后置节点指向新增的节点 并返回\n                pred.next = node;\n                return node;\n            }\n        }\n\t\t// enq 完成同步队列的初始化 并将新增节点加入队列中\n        enq(node);\n        return node;\n    }\n```\n\n```java\n\tprivate Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n\t\t\t// 判断尾节点是否为空\n            if (t == null) { \n\t\t\t\t// 执行同步队列的初始化\n\t\t\t\t// 创建头节点\n\t\t\t\t// 将 head tail 分别指向队列头节点\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n\t\t\t\t// 将 node 的前置节点指向尾节点\n                node.prev = t;\n\t\t\t\t// 将 tail 移动指向 node, 并将 t 的后置节点指向 node\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n从 enq 方法可以看出, 同步器通过\"死循环\"来保证节点的正确添加，只有通过CAS将节点设置为尾节点，当前线程才能返回；否则不断尝试设置。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n\t\t\t\t// 获取节点的前置节点\n                final Node p = node.predecessor();\n\t\t\t\t// 如果前置节点为 head 节点，并且再次尝试获取锁成功\n                if (p == head && tryAcquire(arg)) {\n\t\t\t\t\t// 将 node 设为头节点\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n\t\t\t\t// 获取锁失败后 将当前线程挂起\n\t\t\t\t// shouldParkAfterFailedAcquire 判断当前线程是否支持挂起\n\t\t\t\t// parkAndCHeckInterrupt 将当前线程挂起,　并检测是否中断\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n\t\t\t// 只有当前置节点的等待状态为触发状态(-1)时返回　允许后置节点挂起\n        \treturn true;\n        if (ws > 0) {\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n           \t// 将前置节点的等待状态改为 -1 \n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n```java\nprivate final boolean parkAndCheckInterrupt() {\n\t\t// 将线程挂起\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n从 acquireQueued 方法中可以看出，节点进入同步队列之后以“自轮询”的方式再满足条件的情况下（前置节点为头节点）再次尝试获取锁，如果获取成功则将自己设置为头节点并退出“自轮询”的过程；如果获取失败则将自己当前线程挂起阻塞等待被唤醒以此类推执行“自轮询”的过程。\n\n###### 释放锁\n\n```java\npublic final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n```java\nprivate void unparkSuccessor(Node node) {\n        \n        int ws = node.waitStatus;\n        if (ws < 0)\n\t\t\t// 将头节点的等待状态改为 0\n            compareAndSetWaitStatus(node, ws, 0);\n\n\t\t// 获取后置节点\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n\t\t\t// 唤醒后置节点对应的线程\n            LockSupport.unpark(s.thread);\n    }\n```\n\n关于节点自轮询及节点释放锁后队列的变化如下图所示：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fn6w19xhekj30xj0oetal.jpg)\n\n##### 共享模式\n\t\n\t共享模式表示同一时刻允许多个线程获取锁\n\n###### 获取锁\n\n```java\n\tpublic final void acquireShared(int arg) {\n\t\tif (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\ntryAcquireShared(arg) 尝试获取共享锁，返回结果 >= 0 表示获取锁成功；反之获取锁失败,　调用 doAcquireShared(arg) \n\n```java\nprivate void doAcquireShared(int arg) {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        if (interrupted)\n                            selfInterrupt();\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n从 doAcquireShared 方法中可以看出共享模式下节点加入同步队列以及\"自轮询\"的过程与独占模式下基本类似，不同之处在于当节点尝试获取锁成功后的处理逻辑 setHeadAndPropagate\n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node);\n       \t \n        if (propagate > 0 || h == null || h.waitStatus < 0) {\n            Node s = node.next;\n            if (s == null || s.isShared())\n                doReleaseShared();\n        }\n    }\n```\n\n从代码中可以看出在节点获取锁成功后会判断后置节点是否为共享模式，如果为共享模式则对其进行唤醒操作，也就是同时激发多个线程并发的运行\n\n###### 释放锁\n\n\n","tags":["jdk"]},{"title":"zookeeper源码阅读之watch","url":"/2017/12/22/zookeeper源码阅读之watch/","content":"#### watcher 流程概述\n\n\twatcher 用来客户端监听某一节点的特性变化，执行对应的操作. 从下图可以看出 watcher 的流程主要包括:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmpmv1leuxj30tn0gjwff.jpg)\n\n> - watcher 注册, 包括客户端注册, 服务端的注册\n> - watcher 触发\n> - watcher 执行\n\n<!-- more -->\n\n#### watcher 注册\n\n\t本文我们以 zookeeper.getData 操作为例，对 watcher 的注册流程就行说明。\n\n##### watcher 客户端注册\n\t\n\tgetData api　如下:\n\n```java\npublic byte[] getData(final String path, Watcher watcher, Stat stat)\n\t\tthrows KeeperException, InterruptedException\n{\n\t\tfinal String clientPath = path;\n\t\tPathUtils.validatePath(clientPath);\n\n\t\t// the watch contains the un-chroot path\n\t\tWatchRegistration wcb = null;\n\t\tif (watcher != null) {\n\t\t\t\t// 定义 watcher 注册\n\t\t\t\twcb = new DataWatchRegistration(watcher, clientPath);\n\t\t}\n\n\t\tfinal String serverPath = prependChroot(clientPath);\n\n\t\tRequestHeader h = new RequestHeader();\n\t\th.setType(ZooDefs.OpCode.getData);\n\t\tGetDataRequest request = new GetDataRequest();\n\t\trequest.setPath(serverPath);\n\t\t// watcher 不为空的时候　设置为 true\n\t\trequest.setWatch(watcher != null);\n\t\tGetDataResponse response = new GetDataResponse();\n\t\tReplyHeader r = cnxn.submitRequest(h, request, response, wcb);\n\t\tif (r.getErr() != 0) {\n\t\t\t\tthrow KeeperException.create(KeeperException.Code.get(r.getErr()),\n\t\t\t\t\t\t\t\tclientPath);\n\t\t}\n\t\tif (stat != null) {\n\t\t\t\tDataTree.copyStat(response.getStat(), stat);\n\t\t}\n\t\treturn response.getData();\n}\n\n```\n\t在完成本次请求，处理返回 packet 的时候, 会调用 ClinetCnxn.finishPacket(packet) 方法\n\n```java\nprivate void finishPacket(Packet p) {\n\tint err = p.replyHeader.getErr();\n\tif (p.watchRegistration != null) {\n\t\t\t// 调用 wwatcher　register; 处理正常的时候 err 值为 0; 可参考类 FinalRequestProcessor\n\t\t\tp.watchRegistration.register(err);\n\t}\n\t// 省略\n}\n```\n\t以下为 watchRegistration.register 源码:\n\n```java\npublic void register(int rc) {\n\tif (shouldAddWatch(rc)) {\n\t\t// client　下允许对多个路径设置监听\n\t\tMap<String, Set<Watcher>> watches = getWatches(rc);\n\t\tsynchronized(watches) {\n\t\t\t\tSet<Watcher> watchers = watches.get(clientPath);\n\t\t\t\tif (watchers == null) {\n\t\t\t\t\t\t//　同一路径下允许有多个 watcher　\n\t\t\t\t\t\twatchers = new HashSet<Watcher>();\n\t\t\t\t\t\twatches.put(clientPath, watchers);\n\t\t\t\t}\n\t\t\t\twatchers.add(watcher);\n\t\t}\n\t}\n}\n\nprotected boolean shouldAddWatch(int rc) {\n\t\treturn rc == 0;\n}\n\nprotected Map<String, Set<Watcher>> getWatches(int rc) {\n\t\treturn watchManager.dataWatches;\n}\n```\n\n> 从以上代码中可以看出, 客户端在定义 watcher 之后会将其与 path 绑定添加到 ZKWatchManager.dataWatches; 从而完成 watcher 的注册。\n\n##### watcher 服务端注册\n\nserver 在接收到客户端请求执行 FinalRequestProcessor.processRequest 方法过程中，会执行对 watcher　的注册，这里同样以 getData 操作的代码进行分析:\n\n```java\n\tcase OpCode.getData: {\n\t \tlastOp = \"GETD\";\n\t \tGetDataRequest getDataRequest = new GetDataRequest();\n\t \tByteBufferInputStream.byteBuffer2Record(request.request,\n\t\t\t\t\t getDataRequest);\n\t \tDataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());\n\t\tif (n == null) {\n\t\t\t throw new KeeperException.NoNodeException();\n\t \t}\n\t \tPrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),\n\t\t\t\t\t ZooDefs.Perms.READ,\n\t\t\t\t\t request.authInfo);\n\t \tStat stat = new Stat();\n\t\t// 若 client 请求的时候 watch 为 true,　则将 cnxn　作为参数\n\t\t// cnxn 为每个客户端请求链接的时候　针对 selectorKey 绑定的 NIOServerCnxn 实例\n\t \tbyte b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,\n\t\t\t\t\t getDataRequest.getWatch() ? cnxn : null);\n\t \trsp = new GetDataResponse(b, stat);\n\t \tbreak;\n\t}\n\n```\n\n从上面代码中  zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDataRequest.getWatch() ? cnxn : null); 跟踪发现其最后调用了 WatchManager.addWatch(path, watcher) 方法.\n\n```java\n// 注意 : 此时传递的参数 watcher 并不是客户端定义的 watcher 实例，而是服务端存储的与客户端绑定的\n// NIOServerCnxn 实例；因为 NIOServerCnxn 实现了 watcher 接口;\n// watchTable 用来存储 path　与　watcher　的关系; 也可以表示为 多个客户端监听了同一节点\n// watch2Paths　用来存储 watcher 与 path 的关系; 也可以表示为 每个客户端下监听了哪些节点\nsynchronized void addWatch(String path, Watcher watcher) {\n\t\tHashSet<Watcher> list = watchTable.get(path);\n\t\tif (list == null) {\n\t\t\t\t// don't waste memory if there are few watches on a node\n\t\t\t\t// rehash when the 4th entry is added, doubling size thereafter\n\t\t\t\t// seems like a good compromise\n\t\t\t\tlist = new HashSet<Watcher>(4);\n\t\t\t\twatchTable.put(path, list);\n\t\t}\n\t\tlist.add(watcher);\n\n\t\tHashSet<String> paths = watch2Paths.get(watcher);\n\t\tif (paths == null) {\n\t\t\t\t// cnxns typically have many watches, so use default cap here\n\t\t\t\tpaths = new HashSet<String>();\n\t\t\t\twatch2Paths.put(watcher, paths);\n\t\t}\n\t\tpaths.add(path);\n}\n\n```\n> 从上面代码中可以看出,服务端在处理完客户端请求的时候　若客户端设置了 watcher 则会将其添加到 watchmanager 的 watchTable 中；至此服务端针对 watcher 的注册完毕.\n\n#### watcher 触发\n\n针对 watcher 触发的操作，这里以 setData api 为例说明。此时假设某个客户端执行了 setData 操作, 服务端在处理客户端请求的时候, 在调用 FinalRequestProcessor.processRequest　方法的时候会调用 \n```java\n\tzookeeperServer.processTxn(request);\n```\n\n最终会调用 DataTree.processTxn() 方法，此处摘取针对 setData 的操作如下　：\n```java\ncase OpCode.setData:\n\tSetDataTxn setDataTxn = (SetDataTxn) txn;\n\trc.path = setDataTxn.getPath();\n\trc.stat = setData(setDataTxn.getPath(), setDataTxn\n\t\t\t\t.getData(), setDataTxn.getVersion(), header\n\t\t\t\t.getZxid(), header.getTime());\n\tbreak;\n```\n\n```java\npublic Stat setData(String path, byte data[], int version, long zxid,\n\t\t\t\tlong time) throws KeeperException.NoNodeException {\n\t\tStat s = new Stat();\n\t\tDataNode n = nodes.get(path);\n\t\tif (n == null) {\n\t\t\t\tthrow new KeeperException.NoNodeException();\n\t\t}\n\t\tbyte lastdata[] = null;\n\t\tsynchronized (n) {\n\t\t\t\tlastdata = n.data;\n\t\t\t\tn.data = data;\n\t\t\t\tn.stat.setMtime(time);\n\t\t\t\tn.stat.setMzxid(zxid);\n\t\t\t\tn.stat.setVersion(version);\n\t\t\t\tn.copyStat(s);\n\t\t}\n\t\t// now update if the path is in a quota subtree.\n\t\tString lastPrefix = getMaxPrefixWithQuota(path);\n\t\tif(lastPrefix != null) {\n\t\t\t\t// 更新节点数据\n\t\t\t\tthis.updateBytes(lastPrefix, (data == null ? 0 : data.length)\n\t\t\t\t\t\t\t\t- (lastdata == null ? 0 : lastdata.length));\n\t\t}\n\t\t// 触发该节点下的 watcher\n\t\tdataWatches.triggerWatch(path, EventType.NodeDataChanged);\n\t\treturn s;\n}\n\n```\n\n从上述代码中可以看出, 服务端在完成对节点数据更新之后调用了 watcher.triggerWatch(); 该方法接收两个参数一个为节点path, 一个为事件类型\n\n```java\nSet<Watcher> triggerWatch(String path, EventType type, Set<Watcher> supress) {\n\t\tWatchedEvent e = new WatchedEvent(type,\n\t\t\t\t\t\tKeeperState.SyncConnected, path);\n\t\tHashSet<Watcher> watchers;\n\t\tsynchronized (this) {\n\t\t\t\twatchers = watchTable.remove(path);\n\t\t\t\tif (watchers == null || watchers.isEmpty()) {\n\t\t\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tZooTrace.logTraceMessage(LOG,\n\t\t\t\t\t\t\t\t\t\t\t\tZooTrace.EVENT_DELIVERY_TRACE_MASK,\n\t\t\t\t\t\t\t\t\t\t\t\t\"No watchers for \" + path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfor (Watcher w : watchers) {\n\t\t\t\t\t\tHashSet<String> paths = watch2Paths.get(w);\n\t\t\t\t\t\tif (paths != null) {\n\t\t\t\t\t\t\t\tpaths.remove(path);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tfor (Watcher w : watchers) {\n\t\t\t\tif (supress != null && supress.contains(w)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tw.process(e);\n\t\t}\n\t\treturn watchers;\n}\n\n```\n\n从以上代码中看出在触发 watcher 的时候，会先从 watchManager 中的 watchTable 获取指定 path 的 watcher 并将其从集合中移除（从此处我们可以看出客户端定义的 watcher　若未作处理的话　将只会监听一次）。在查找到 watcher 之后将会调用 watcher.process 即执行 watcher.\n\n#### watcher 执行\n\n在服务端触发 watcher　之后，会调用 watcher.process　方法，此时 watcher 的实例为 NIOServerCnxn;接下来我们看下 NIOSserverCnxn 的 process　方法:\n\n```java \npublic void process(WatchedEvent event) {\n\t\tReplyHeader h = new ReplyHeader(-1, -1L, 0);\n\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\tZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n\t\t\t\t\t\t\t\t\"Deliver event \" + event + \" to 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(this.sessionId)\n\t\t\t\t\t\t\t\t+ \" through \" + this);\n\t\t}\n\n\t\t// Convert WatchedEvent to a type that can be sent over the wire\n\t\tWatcherEvent e = event.getWrapper();\n\n\t\tsendResponse(h, e, \"notification\");\n}\n\n```\n\n从上面代码中可以看出服务端向客户端发出了 tag 为 \"notification\" 的响应；　接下来我们看下客户端如何处理该响应:\n在 ClientCnxn 下的 SendThread.readResponse 方法中我们可以看到针对 watcher　的处理如下：\n```java\nif (replyHdr.getXid() == -1) {\n\t\t// -1 means notification\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Got notification sessionid:0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId));\n\t\t}\n\t\t// 从 response 中反序列化\n\t\tWatcherEvent event = new WatcherEvent();\n\t\tevent.deserialize(bbia, \"response\");\n\n\t\t// convert from a server path to a client path\n\t\tif (chrootPath != null) {\n\t\t\t\tString serverPath = event.getPath();\n\t\t\t\tif(serverPath.compareTo(chrootPath)==0)\n\t\t\t\t\t\tevent.setPath(\"/\");\n\t\t\t\telse if (serverPath.length() > chrootPath.length())\n\t\t\t\t\t\tevent.setPath(serverPath.substring(chrootPath.length()));\n\t\t\t\telse {\n\t\t\t\t\t\tLOG.warn(\"Got server path \" + event.getPath()\n\t\t\t\t\t\t\t\t\t\t+ \" which is too short for chroot path \"\n\t\t\t\t\t\t\t\t\t\t+ chrootPath);\n\t\t\t\t}\n\t\t}\n\n\t\tWatchedEvent we = new WatchedEvent(event);\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Got \" + we + \" for sessionid 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId));\n\t\t}\n\t\t// 将 watchedEvent 交由 eventThread　处理\n\t\teventThread.queueEvent( we );\n\t\treturn;\n}\n\n```\n```java\nprivate void queueEvent(WatchedEvent event,\n\t\t\t\tSet<Watcher> materializedWatchers) {\n\t\tif (event.getType() == EventType.None\n\t\t\t\t\t\t&& sessionState == event.getState()) {\n\t\t\t\treturn;\n\t\t}\n\t\tsessionState = event.getState();\n\t\tfinal Set<Watcher> watchers;\n\t\tif (materializedWatchers == null) {\n\t\t\t\t// materialize the watchers based on the event\n\t\t\t\t// 从 ZKWatchManager 中获取 path　的 watcher\n\t\t\t\twatchers = watcher.materialize(event.getState(),\n\t\t\t\t\t\t\t\tevent.getType(), event.getPath());\n\t\t} else {\n\t\t\t\twatchers = new HashSet<Watcher>();\n\t\t\t\twatchers.addAll(materializedWatchers);\n\t\t}\n\t\tWatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);\n\t\t// queue the pair (watch set & event) for later processing\n\t\twaitingEvents.add(pair);\n}\n\n```\n\n从上面代码看出 客户端在处理 watcher　通知的时候会将其封装为 WatcherSetEventPair 对象并添加到 waitingEvents　队列中此时会唤醒阻塞在队列的操作，也即 eventThread 的 run 方法，如下：\n\n```java\npublic void run() {\n\t\ttry {\n\t\tisRunning = true;\n\t\twhile (true) {\n\t\t\t\tObject event = waitingEvents.take();\n\t\t\t\tif (event == eventOfDeath) {\n\t\t\t\t\t\twasKilled = true;\n\t\t\t\t} else {\n\t\t\t\t\t\tprocessEvent(event);\n\t\t\t\t}\n\t\t\t\tif (wasKilled)\n\t\t\t\t\t\tsynchronized (waitingEvents) {\n\t\t\t\t\t\t\t\tif (waitingEvents.isEmpty()) {\n\t\t\t\t\t\t\t\t\t\tisRunning = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\t\tLOG.error(\"Event thread exiting due to interruption\", e);\n\t\t}\n\n\t\tLOG.info(\"EventThread shut down for session: 0x{}\",\n\t\t\t\t\t\tLong.toHexString(getSessionId()));\n}\n\n```\n截取 processEvent 方法中针对 watcher 的处理\n```java \nf (event instanceof WatcherSetEventPair) {\n\t\t// each watcher will process the event\n\t\tWatcherSetEventPair pair = (WatcherSetEventPair) event;\n\t\tfor (Watcher watcher : pair.watchers) {\n\t\t\t\ttry {\n\t\t\t\t\t\t// 执行 watcher\n\t\t\t\t\t\twatcher.process(pair.event);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLOG.error(\"Error while calling watcher \", t);\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n从上面代码看出当 waitingEvents　队列中存在待处理的 watcher 时将会依次调用；至此完成 watcher的执行；到此完成对 zookeeper　watcher　的分析.\n\n","tags":["zookeeper"]},{"title":"NIO selector的wakeup","url":"/2017/12/21/NIO-selector的wakeup/","content":"\n###### wakeUp\n\n> 某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。\n如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。\n\n引用至 http://ifeve.com/selectors/\n<!-- more -->\n###### 测试\n\n```java\npublic class App \n{\n\t\tprivate Selector selector;\n\n\t\tpublic void start () throws IOException {\n\t\t\t\t// 开启选择器 selector\n\t\t\t\tselector = Selector.open();\n\n\t\t\t\t// 开启服务端 socket 通道\n\t\t\t\tServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\t\t\t\t// 设置为非阻塞\n\t\t\t\tserverSocketChannel.configureBlocking(false);\n\t\t\t\t// 绑定服务端端口\n\t\t\t\tserverSocketChannel.socket().bind(new InetSocketAddress(8888));\n\t\t\t\t// 通道注册到选择器上　并监听　接收客户端事件\n\t\t\t\tserverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\t\t\t\t// 因 selector.select 会阻塞当前线程　故异步处理\n\t\t\t\tnew Thread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tSystem.out.println(\"select 前执行\");\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tselector.select();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSystem.out.println(\"select 后执行\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}).start();\n\n\t\t}\n\n\t\tpublic void wakeup () {\n\t\t\t\tSystem.out.println(\"开始唤醒\");\n\t\t\t\tselector.wakeup();\n\t\t}\n\n\t\tpublic static void main( String[] args ) throws IOException, InterruptedException {\n\t\t\t\tfinal App app = new App();\n\t\t\t\tapp.start();\n\n\t\t\t\tThread thread = new Thread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tTimeUnit.SECONDS.sleep(1);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapp.wakeup();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthread.start();\n\n\t\t\t\tthread.join();\n\t\t}\n}\n\n```\n\n\n```java\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\nselect 前执行\n开始唤醒\nselect 后执行\n```\n\n从执行结果可以看出 在调用了 wakeup() 方法之后，即可唤醒阻塞在 select() 上的操作　也即 select() 方法会立马返回.\n\n","tags":["NIO"]},{"title":"zookeeper源码阅读之client","url":"/2017/12/15/zookeeper源码阅读之client/","content":"\n#### zookeeper client 启动流程\n> 先看下 zookeeper client 相关类图\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4gu34pbj30vp0g1t9p.jpg)\n\n##### 执行 zkCli.sh 脚本时, 会运行 org.apache.zookeeper.ZookeeperMain 类主方法.\n```java\npublic static void main(String args[])\n\t\tthrows KeeperException, IOException, InterruptedException\n{\n\tZooKeeperMain main = new ZooKeeperMain(args);\n\tmain.run();\n}\n\n```\n```java\npublic ZooKeeperMain(String args[]) throws IOException, InterruptedException {\n\t// 启动参数解析\n\tcl.parseOptions(args);\n\tSystem.out.println(\"Connecting to \" + cl.getOption(\"server\"));\n\t// 链接 zookeeper server\n\tconnectToZK(cl.getOption(\"server\"));\n}\n```\n\n> 从代码中可以看出 client 启动时首先构造 ZookeeperMain　对象实例,构造过程中会先解析 client 的启动参数（若未指定任何参数将会默认链接本机 2181 端口 zookeeper server）\n<!-- more -->\n##### 通过调用 connectToZK 链接 zookeeper server\n```java\nprotected void connectToZK(String newHost) throws InterruptedException, IOException {\n\tif (zk != null && zk.getState().isAlive()) {\n\t\t// 若已创建 zookeeper 对象并且状态为激活　则关闭重新创建\n\t\tzk.close();\n\t}\n\thost = newHost;\n\tboolean readOnly = cl.getOption(\"readonly\") != null;\n\tif (cl.getOption(\"secure\") != null) {\n\t\tSystem.setProperty(ZKClientConfig.SECURE_CLIENT, \"true\");\n\t\tSystem.out.println(\"Secure connection is enabled\");\n\t}\n\t// 构造 Zookeeper 对象实例\n\tzk = new ZooKeeper(host,Integer.parseInt(cl.getOption(\"timeout\")),\n\t\t\t\tnew MyWatcher(), readOnly);\n}\n\n```\n##### 创建 Zookeeper 对象实例\n```java\n// connectString 是形如 host:port,host:port 的字符串片段\npublic ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,\n\t\t\t\tboolean canBeReadOnly, HostProvider aHostProvider,\n\t\t\t\tZKClientConfig clientConfig) throws IOException {\n\n\tif (clientConfig == null) {\n\t\t// 创建 ZKClient Config 对象\n\t\tclientConfig = new ZKClientConfig();\n\t}\n\tthis.clientConfig = clientConfig;\n\twatchManager = defaultWatchManager();\n\twatchManager.defaultWatcher = watcher;\n\tConnectStringParser connectStringParser = new ConnectStringParser(\n\t\t\t\tconnectString);\n\thostProvider = aHostProvider;\n\t// 创建 ClientCnxn 对象\n\tcnxn = new ClientCnxn(connectStringParser.getChrootPath(),\n\t\t\t\thostProvider, sessionTimeout, this, watchManager,\n\t\t\t\tgetClientCnxnSocket(), canBeReadOnly);\n\tcnxn.start();\n}\n// 创建 ClientCnxnSocket对象 默认为 ClientCnxnSocketNIO 对象\nprivate ClientCnxnSocket getClientCnxnSocket() throws IOException {\n\t\tString clientCnxnSocketName = getClientConfig().getProperty(\n\t\t\t\t\t\tZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);\n\t\tif (clientCnxnSocketName == null) {\n\t\t\t\tclientCnxnSocketName = ClientCnxnSocketNIO.class.getName();\n\t\t}\n\t\ttry {\n\t\t\t\tConstructor<?> clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);\n\t\t\t\tClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());\n\t\t\t\treturn clientCxnSocket;\n\t\t} catch (Exception e) {\n\t\t\t\tIOException ioe = new IOException(\"Couldn't instantiate \"\n\t\t\t\t\t\t\t\t+ clientCnxnSocketName);\n\t\t\t\tioe.initCause(e);\n\t\t\t\tthrow ioe;\n\t\t}\n}\n```\n> 从代码中看出 Zookeeper 关联了 ClientCnxn 对象, 在创建了 ClientCnxn 对象实例之后调用了 cnxn.start() 方法。\n##### 创建 ClientCnxn 对象实例\n\n```java\npublic ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,\n\t\t\t\tClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,\n\t\t\t\tlong sessionId, byte[] sessionPasswd, boolean canBeReadOnly) {\n\t\tthis.zooKeeper = zooKeeper;\n\t\tthis.watcher = watcher;\n\t\tthis.sessionId = sessionId;\n\t\tthis.sessionPasswd = sessionPasswd;\n\t\tthis.sessionTimeout = sessionTimeout;\n\t\tthis.hostProvider = hostProvider;\n\t\tthis.chrootPath = chrootPath;\n\t\t// 计算连接超时时间　读数据超时时间\n\t\tconnectTimeout = sessionTimeout / hostProvider.size();\n\t\treadTimeout = sessionTimeout * 2 / 3;\n\t\treadOnly = canBeReadOnly;\n\t\t// 创建了 SendThread EventThread　线程实例\n\t\tsendThread = new SendThread(clientCnxnSocket);\n\t\teventThread = new EventThread();\n\t\tthis.clientConfig=zooKeeper.getClientConfig();\n}\n\npublic void start() {\n\t\tsendThread.start();\n\t\teventThread.start();\n}\n```\n> 从 start 方法中可以看出分别启动了 sendThread eventThread　两个线程。\n\n##### SendThread 线程的构造及启动\n```java\nSendThread(ClientCnxnSocket clientCnxnSocket) {\n\t\tsuper(makeThreadName(\"-SendThread()\"));\n\t\tstate = States.CONNECTING;\n\t\tthis.clientCnxnSocket = clientCnxnSocket;\n\t\tsetDaemon(true);\n}\n\n```\n> SendThread 是 ClientCnxn 的内部类, 创建该线程实例时会将 ClientCnxn 的状态由默认状态(未连接)改为连接中,并赋值 clientCnxnSocket。\n\n###### ClientCnxn 的主要成员变量说明\n> 在了解 sendThread 线程的启动过程有必要先了解一下关于 SendThread 和 ClientCnxn 的相关成员变量。\n\n| 变量名 | 描述 |\n|--------|------|\n| state  | 客户端连接状态 |\n| outgoingQueue | 存储需要被发送出去的报文的队列 |\n| pendingQueue | 存储已经发送等待响应结果的队列 |\n\n##### SendThread 线程启动\n```java\npublic void run() {\n\t// 将 sendThread sessionId outgoingQueue 绑定到的 clientCnxnSocketNIO\n\tclientCnxnSocket.introduce(this, sessionId, outgoingQueue);\n\tclientCnxnSocket.updateNow();\n\tclientCnxnSocket.updateLastSendAndHeard();\n\tint to;\n\tlong lastPingRwServer = Time.currentElapsedTime();\n\tfinal int MAX_SEND_PING_INTERVAL = 10000; //10 seconds\n\twhile (state.isAlive()) {\n\t\ttry {\n\t\t\tif (!clientCnxnSocket.isConnected()) {\n\t\t\t\t// don't re-establish connection if we are closing\n\t\t\t\tif (closing) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 如果 clientCnxnSocketNIO 未连接　则开始连接\n\t\t\t\tstartConnect();\n\t\t\t\tclientCnxnSocket.updateLastSendAndHeard();\n\t\t\t}\t\n\n\t\t\t\tif (state.isConnected()) {\n\t\t\t\t\t\t// determine whether we need to send an AuthFailed event.\n\t\t\t\t\t\tif (zooKeeperSaslClient != null) {\n\t\t\t\t\t\t\t// ssl client　的处理此处省略\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = readTimeout - clientCnxnSocket.getIdleRecv();\n\t\t\t\t} else {\n\t\t\t\t\t\tto = connectTimeout - clientCnxnSocket.getIdleRecv();\n\t\t\t\t}\n\n\t\t\t\tif (to <= 0) {\n\t\t\t\t\t\tString warnInfo;\n\t\t\t\t\t\twarnInfo = \"Client session timed out, have not heard from server in \"\n\t\t\t\t\t\t\t\t+ clientCnxnSocket.getIdleRecv()\n\t\t\t\t\t\t\t\t+ \"ms\"\n\t\t\t\t\t\t\t\t+ \" for sessionid 0x\"\n\t\t\t\t\t\t\t\t+ Long.toHexString(sessionId);\n\t\t\t\t\t\tLOG.warn(warnInfo);\n\t\t\t\t\t\tthrow new SessionTimeoutException(warnInfo);\n\t\t\t\t}\n\t\t\t\tif (state.isConnected()) {\n\t\t\t\t\t\t//1000(1 second) is to prevent race condition missing to send the second ping\n\t\t\t\t\t\t//also make sure not to send too many pings when readTimeout is small \n\t\t\t\t\t\tint timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - \n\t\t\t\t\t\t\t\t((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);\n\t\t\t\t\t\t//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL\n\t\t\t\t\t\tif (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {\n\t\t\t\t\t\t\t\t// 发送心跳\n\t\t\t\t\t\t\t\tsendPing();\n\t\t\t\t\t\t\t\tclientCnxnSocket.updateLastSend();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (timeToNextPing < to) {\n\t\t\t\t\t\t\t\t\t\tto = timeToNextPing;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we are in read-only mode, seek for read/write server\n\t\t\t\tif (state == States.CONNECTEDREADONLY) {\n\t\t\t\t\t\tlong now = Time.currentElapsedTime();\n\t\t\t\t\t\tint idlePingRwServer = (int) (now - lastPingRwServer);\n\t\t\t\t\t\tif (idlePingRwServer >= pingRwTimeout) {\n\t\t\t\t\t\t\t\tlastPingRwServer = now;\n\t\t\t\t\t\t\t\tidlePingRwServer = 0;\n\t\t\t\t\t\t\t\tpingRwTimeout =\n\t\t\t\t\t\t\t\t\t\tMath.min(2*pingRwTimeout, maxPingRwTimeout);\n\t\t\t\t\t\t\t\tpingRwServer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = Math.min(to, pingRwTimeout - idlePingRwServer);\n\t\t\t\t}\n\n\t\t\t\tclientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);\n\t\t} catch (Throwable e) {\n\t\t\t// 异常处理的部分省略...\t\n\t\t}\n\t\t}\n\t\tsynchronized (state) {\n\t\t\t\t// When it comes to this point, it guarantees that later queued\n\t\t\t\t// packet to outgoingQueue will be notified of death.\n\t\t\t\tcleanup();\n\t\t}\n\t\tclientCnxnSocket.close();\n\t\tif (state.isAlive()) {\n\t\t\t\teventThread.queueEvent(new WatchedEvent(Event.EventType.None,\n\t\t\t\t\t\t\t\t\t\tEvent.KeeperState.Disconnected, null));\n\t\t}\n\t\tZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),\n\t\t\t\t\t\t\"SendThread exited loop for session: 0x\"\n\t\t\t\t\t\t+ Long.toHexString(getSessionId()));\n}\n```\n>  从代码中可以看出 sendThread 主要做以下事情\n> - 创建客户端连接\n> - 发送心跳\n> - 发送消息 (终端输入的指令)\n\n> 下面将针对上面三种流程分析\n\n###### 客户端连接创建流程\n\n> 先大概看下此流程活动图　如下:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4i5lp6zj30yg0oa77g.jpg)\n\n> - sendThread 轮询过程中　先判断 clientCnxnSocket 是否已连接；若未连接则调用 sendThread.startConnect() 将 ClientCnxn.state 的状态改为 \"连接中\", 接下来同步调用 clientCnxnSocket.connect 完成客户端 socket 的创建及注册到 selector 并监听连接事件\n> - 上述操作完成后会调用 clientCnxnSocket.doTransport (), 该方法主要处理 selector 选择器上就绪的通道事件.\n> - 当客户端 socket 连接就绪的时候会调用 sendThread.primeConnection() 准备连接方法，该方法 ConnectionRequet　的 Packet　并将其添加到 outgoingQueue　对列中，接下来调用 clientCnxnSocket.connectionPrimed 该方法主要告知 socket　准备好连接了 此时客户端在 selector 上注册读写事件 (此时会触发通道的写就绪事件)\n> - 当客户端 socket 写就绪的时候会调用 clientCnxnSocket.findSendablePacket 该方法从 outgoingQueue 队列中获取待发送的 Packet , 最后执行 socket.write() 发送消息(此时会触发通道的读就绪事件)\n> - 当客户端 socket 读就绪的时候判断 initialized 是否为 true，若为 false 说明执行连接初始化会调用 sendThread.onConnected 更改客户端状态为 \"已连接\"，　继续注册监听客户端的读写事件\n\n###### 客户端心跳流程\n> 心跳流程如下：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4jaf9ooj30ro0l640z.jpg)\n\n> - sendThread 轮询过程中　判断 state 是否为 \"已连接\"; 若已连接判断是否满足心跳条件, 调用 sendPing 创建心跳 packet　header xid = -2; 接下来将 packet　添加到 outgoingQueue　队列中并调用 clientCnxnSocket.packetAddedd　最后唤醒阻塞在 selector.select 上的操作\n> - 当客户端 socket 写就绪的时候调用 findSendablePacket 获取待发送的 packet 最后调用 socket.write 执行发送\n> - 当客户端 socket 读就绪的时候调用 sendThread.readResponse 解析服务端的响应结果, 通过获取 response heaher xid 判断 xid == -2 ;　若为 -2 则打印心跳返回日志返回，　此时一次心跳结束\n\n###### 客户端终端发送指令流程\n\n> 发送指令流程图如下:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4k6ka0bj30ts0h8gn8.jpg)\n\n> - ZookeeperMain 构建完成后会调用 run　方法，等待用户输入\n> - 输入指令后会相应调用 executeLine, processCmd, processZKCmd 通过解析参数获取相应的 CliCommand\n> - 此处采用了命令模式 内置了各种 CliCommand 对应客户端相应的操作，包括(CreateCommand, GetCommand, SetCommand ....）; 获取对应的命令后，调用 parse, exec　方法执行命令\n> - 执行命令会调用 zookeeper 对应的操作(create, getData, setData)，在内部会调用 ClientCnxn.submitRequest 方法\n> - 在 clientCnxn.submitRequest　方法中会调用 queuePacket　创建 packet　并将其添加到队列中，接着唤醒 clientCnxnSocketNIO 的 selector.select 操作；后续操作就是读写就绪事件的处理与心跳流程类似。\n\n\n至此 zookeeper client 的相关流程介绍完毕　细节的地方后续在处理.\n\n\n"},{"title":"NIO之粘包拆包处理","url":"/2017/12/14/NIO之粘包拆包处理/","content":"\n#### 概述\n\n> 我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。\n\n#### 粘包拆包的原因\n\n> 关于 tcp 传输过程中，发生粘包拆包的原因及表现形式可参考网上的一篇[博客](https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/); 这里就不在说明.\n\n#### 粘包拆包的解决方法\n\n> 本文给出针对自定义消息报文格式，通过在消息头部添加消息载体长度来处理\n<!-- more -->\n##### 实现方式\n\n###### 消息内容包装\n\n```java\npublic class PacketWrapper {\n\n\t\t// 消息有效长度\n\t\tprivate int length;\n\t\t// 消息的有效载体\n\t\tprivate byte[] payload;\n\n\t\tpublic PacketWrapper(String payload) {\n\t\t\t\tthis.payload = payload.getBytes();\n\t\t\t\tthis.length = this.payload.length;\n\t\t}\n\n\t\tpublic PacketWrapper(byte[] payload) {\n\t\t\t\tthis.payload = payload;\n\t\t\t\tthis.length = this.payload.length;\n\t\t}\n\n\t\t// 返回包装后的字节数组\n\t\tpublic byte[] getBytes() {\n\t\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(this.length + 4);\n\t\t\t\tbyteBuffer.putInt(this.length);\n\t\t\t\tbyteBuffer.put(payload);\n\t\t\t\treturn byteBuffer.array();\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor (byte b : getBytes()) {\n\t\t\t\t\t\tsb.append(String.format(\"0x%02X \", b));\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t}\n}\n\n```\n\n###### 消息报文的解码\n\n```java\n\npublic class NioDecodeHandler {\n\n    private static Logger log = Logger.getLogger(NioDecodeHandler.class);\n\n    private final int HEAD_LENGTH = 4;\n\n    protected ByteBuffer lastReadBuffer = null;\n\n    public void decode (SocketChannel socketChannel) {\n        // 从通道中读取内容\n\t\tByteBuffer readByteBuffer = ByteBuffer.allocate(128);\n        try {\n            int read = socketChannel.read(readByteBuffer);\n            if (read < 0) {\n                throw new RuntimeException(\"\");\n            }\n        } catch (IOException e) {\n\n        }\n\n        ByteBuffer newByteBuffer = readByteBuffer;\n        if (newByteBuffer == null) {\n            return;\n        }\n        // 切换到读模式\n        newByteBuffer.flip();\n\n        if (lastReadBuffer != null) {\n            // 将上次遗留的数据与本次已读的数据合并\n            newByteBuffer = ByteBufferUtil.composite(lastReadBuffer, newByteBuffer);\n        }\n\n        decode : while (true) {\n            if (newByteBuffer.remaining() <= HEAD_LENGTH) {\n\t\t\t\t// 报文字节数达不到报文长度退出\n                lastReadBuffer = ByteBuffer.wrap(ByteBufferUtil.readBuffer(newByteBuffer, newByteBuffer.remaining()));\n                return;\n            }\n\n            // 获取报文头部, 即报文有效长度\n            int payloadLength = newByteBuffer.getInt();\n            if (newByteBuffer.remaining() < payloadLength) {\n                // 拆包 : 后续字节不够一个完整报文\n                // 因上一操作 getInt 读取了 4　字节, 故需将　position 退回移动 4　字节\n                newByteBuffer.position(newByteBuffer.position() - HEAD_LENGTH);\n                lastReadBuffer = ByteBuffer.wrap(ByteBufferUtil.readBuffer(newByteBuffer, newByteBuffer.remaining()));\n                return;\n            }\n\n            // 获取有效报文\n            handlerPacket(socketChannel, ByteBufferUtil.readBuffer(newByteBuffer, payloadLength));\n\n            if (newByteBuffer.remaining() > 0) {\n                // 剩下的报文 可能是有效报文,　继续解码\n                continue decode;\n            }\n\n            return;\n        }\n    }\n\n\n\n    private void handlerPacket (SocketChannel socketChannel, byte[] packet) {\n        ServiceLoader<PacketHandler> packetHandlers = ServiceLoader.load(PacketHandler.class);\n        Iterator<PacketHandler> packetHandlerIterator = packetHandlers.iterator();\n\n        while (packetHandlerIterator.hasNext()) {\n            packetHandlerIterator.next().handler(socketChannel, packet);\n        }\n    }\n\n}\n\n```\n\n依赖的工具方法如下：\n\n```java\n\npublic class ByteBufferUtil {\n\n    private ByteBufferUtil () {}\n\n    /**\n     * 将两个 bytebuffer 合并\n     *\n     * @param byteBuffer1\n     * @param byteBuffer2\n     * @return\n     */\n    public static ByteBuffer composite(ByteBuffer byteBuffer1, ByteBuffer byteBuffer2) {\n        int capacity = byteBuffer1.limit() - byteBuffer1.position() + byteBuffer2.limit() - byteBuffer2.position();\n        ByteBuffer ret = ByteBuffer.allocate(capacity);\n\n        ret.put(byteBuffer1);\n        ret.put(byteBuffer2);\n\n        ret.position(0);\n        ret.limit(ret.capacity());\n        return ret;\n    }\n\n    /**\n     * 获取 bytebuffer 中可读的内容\n     *\n     * @param byteBuffer\n     * @param size\n     * @return\n     */\n    public static byte[] readBuffer(ByteBuffer byteBuffer, int size) {\n        byte[] bytes = new byte[size];\n\n        byteBuffer.get(bytes);\n\n        return bytes;\n    }\n}\n\n```\n","tags":["NIO"]},{"title":"NIO之ByteBuffer","url":"/2017/12/13/NIO之ByteBuffer/","content":"\n### ByteBuffer\n\n###### 字段说明\n> * Capacity : Buffer 固定的容量大小\n* Position : 表示当前的位置， 初始值为0；当为写模式时，当写入一个字节的时候，position会向前移动到下一个可插入数据的buffer单元；当为读模式时，position会重置为0，每读取一个字节的时候，position会向前移动下一个可读取的位置。\n* Limit : 表示buffer最多可写或可读的数量。写模式下limit = capacity; 读模式下limit = position\n\n###### 初始化\n\n> 采用jvm堆内存初始\n\n```java\n  /**\n   * 定义初始容量10字节的缓冲区 capacity=10, limit=10, position=0\n   */\n  ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n```\n<!-- more -->\n> 采用堆外内存初始\n\n```java\n  /**\n   * 定义初始容量10字节的缓冲区 capacity=10, limit=10, position=0\n   */\n  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(10);\n\n```\n\n###### put(byte byte)\n\n> 写入数据时，每写入一个字节的时候 会检验 position >= limit, 之后执行position++ 自增操作；\n\n```java\n  public Bytebuffer put (byte x) {\n    hb[ix(nextPutIndex())] = x;\n    return this;\n  }\n\n  int nextPutIndex () {\n    if (position >= limit) {\n      throw new BufferOverflowException();\n    }\n    return position++;\n  }\n```\n\n![put](https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1505116488784&di=a0dd847eedd460ace788f23a94157178&imgtype=jpg&src=http%3A%2F%2Fh.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F4610b912c8fcc3ce6443e4179945d688d43f2016.jpg)\n\n###### flip()\n\n> buffer 由写模式切换到读模式; limit 值为position， position会重置为0\n\n```java\n\n  public final Buffer flip() {\n    limit = position;\n    position = 0;\n    mark = -1;\n    return this;\n  }\n\n```\n![flip](https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1505118021655&di=bb23319c2e5d519a3da9d2961127c26b&imgtype=jpg&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11df5590ab07682762d0f703c255.jpg)\n\n###### get()\n\n> buffer 读取数据的时候，检验position>=limit; 之后执行position++\n\n```java\n  public byte get() {\n    return hb[ix(nextGetIndex())];\n  }\n\n  int nextGetIndex () {\n    if (position >= limit){\n      throw new BufferUnderflowException();\n    }\n    return position++;\n  }\n```\n\n![](https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1505118511420&di=86d6d65d0d9d00faa5be956ddaa08ec7&imgtype=jpg&src=http%3A%2F%2Fg.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F77c6a7efce1b9d16a3e08a45f8deb48f8c5464ea.jpg)\n","tags":["NIO","bytebuffer"]},{"title":"zookeeper源码阅读之server","url":"/2017/12/12/zookeeper源码阅读之server/","content":"\n#### zookeeper server 启动流程概述\n\n> 此次只针对单机模式对 server 端的启动流程分析, 首先看下 zookeeper server 启动时序图，如下：\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm47wn25cj30ys0jlt9k.jpg)\n\n> 其启动流程如下：\n> - 执行 zkServer.sh start 脚本, 会调用 QuorumPeerMain.main(); 执行 initializeAndRun 方法\n> - 调用 QuorumPeerConfig.parse() 方法，该方法主要是对启动参数的解析并加载相应的配置文件\n> - 通过上文解析的配置, 判断当前启动模式是否为集群或单机模式\n> - 单机模式下调用 ZookeeperServerMain.main() 方法\n> - 执行 ZookeeperServerMain.initializeAndRun 方法\n> - 调用 ServerConfig.parse 再次解析启动参数加载配置文件\n> - 调用 runFromConfig , 在该方法中依次启动 JettyAdminServer.start(), NIOServerCnxnFactory.startup()\n\n> 至此 zookeeper server 完成单机模式下启动，接下来将详细看下 NIOServerCnxnFactory.startup 的启动过程。\n<!-- more -->\n#### zookeeper server 线程模型\n\n> 在 NIOServerCnxnFactory.startup() 启动前, 我们先看下针对 NIOServerCnxnFactory 的对象的创建及相关配置:\n\n###### NIOServerCnxnFactory 的创建\n\n> 通过 ServerCnxnFactory.createFactory 完成 ServerCnxnFactory 的创建\n```java\n\tstatic public ServerCnxnFactory createFactory() throws IOException {\n\t\t// 获取系统变量 zookeeper.serverCnxnFactory\n\t\tString serverCnxnFactoryName =\n\t\t\t\tSystem.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);\n\t\tif (serverCnxnFactoryName == null) {\n\t\t\t// 若未指定该变量值 则默认返回 NIOServerCnxnFactory; 同时支持 NettyServerCnxnFactory\n\t\t\t\tserverCnxnFactoryName = NIOServerCnxnFactory.class.getName();\n\t\t}\n\t\ttry {\n\t\t\t\treturn (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)\n\t\t\t\t\t\t.newInstance();\n\t\t} catch (Exception e) {\n\t\t\t\tIOException ioe = new IOException(\"Couldn't instantiate \"\n\t\t\t\t\t\t\t\t+ serverCnxnFactoryName);\n\t\t\t\tioe.initCause(e);\n\t\t\t\tthrow ioe;\n\t\t}\n\t}\n```\n\n###### NIOServerCnxnFactory 的配置\n\n> 在执行 startup 前会调用 configure 方法执行相关参数的初始化并绑定 serverSocket \n\n```java\npublic void configure(InetSocketAddress addr, int maxcc, boolean secure) throws IOException {\n\t\tif (secure) {\n\t\t\t\tthrow new UnsupportedOperationException(\"SSL isn't supported in NIOServerCnxn\");\n\t\t}\n\t\tconfigureSaslLogin();\n\n\t\tmaxClientCnxns = maxcc;\n\t\tsessionlessCnxnTimeout = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);\n\t\t\n\t\tcnxnExpiryQueue =\n\t\t\t\tnew ExpiryQueue<NIOServerCnxn>(sessionlessCnxnTimeout);\n\t\texpirerThread = new ConnectionExpirerThread();\n\t\t// 返回虚拟机的可用处理器数量　也可认为 cpu 核数\n\t\tint numCores = Runtime.getRuntime().availableProcessors();\n\t\t// 32 cores sweet spot seems to be 4 selector threads\n\t\t// 计算 selectorThread 线程个数\n\t\tnumSelectorThreads = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_NUM_SELECTOR_THREADS,\n\t\t\t\t\t\tMath.max((int) Math.sqrt((float) numCores/2), 1));\n\t\tif (numSelectorThreads < 1) {\n\t\t\t\tthrow new IOException(\"numSelectorThreads must be at least 1\");\n\t\t}\n\n\t\t// 工作线程　workerThread　数; 默认为　2*numCores\n\t\tnumWorkerThreads = Integer.getInteger(\n\t\t\t\t\t\tZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);\n\t\tworkerShutdownTimeoutMS = Long.getLong(\n\t\t\t\t\t\tZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);\n\t\t// 创建 selectorThread 线程集合\n\t\tfor(int i=0; i<numSelectorThreads; ++i) {\n\t\t\t\tselectorThreads.add(new SelectorThread(i));\n\t\t}\n\n\t\t// 开启服务端链接通道并绑定端口\n\t\tthis.ss = ServerSocketChannel.open();\n\t\tss.socket().setReuseAddress(true);\n\t\tLOG.info(\"binding to port \" + addr);\n\t\tss.socket().bind(addr);\n\t\tss.configureBlocking(false);\n\n\t\t// 创建 AcceptThread 并绑定 ServerSocketChannel selecorThreads　\n\t\tacceptThread = new AcceptThread(ss, addr, selectorThreads);\n}\n```\n\n###### NIOServerCnxnFactory 的启动\n> 启动过程包括 NIOServerCnxnFactory 的启动和 ZookeeperServer 的启动\n```java\n\t\t@Override\n\tpublic void startup(ZooKeeperServer zks, boolean startServer)\n\t\tthrows IOException, InterruptedException {\n\t\tstart();\n\t\tsetZooKeeperServer(zks);\n\t\tif (startServer) {\n\t\t\t\tzks.startdata();\n\t\t\t\tzks.startup();\n\t\t}\n\t}\n\n```\n\n```java\npublic void start() {\n\t\tstopped = false;\n\t\tif (workerPool == null) {\n\t\t\t\tworkerPool = new WorkerService(\n\t\t\t\t\t\t\t\t\"NIOWorker\", numWorkerThreads, false);\n\t\t}\n\t\tfor(SelectorThread thread : selectorThreads) {\n\t\t\t\tif (thread.getState() == Thread.State.NEW) {\n\t\t\t\t\t\tthread.start();\n\t\t\t\t}\n\t\t}\n\t\t// ensure thread is started once and only once\n\t\tif (acceptThread.getState() == Thread.State.NEW) {\n\t\t\t\tacceptThread.start();\n\t\t}\n\t\tif (expirerThread.getState() == Thread.State.NEW) {\n\t\t\t\texpirerThread.start();\n\t\t}\n}\n```\n> 从代码中可以看出 NIOServerCnxnFactory 启动的时候开启了 AcceptThread SelectorThread ExpirerThread workerPool\n\n###### AcceptThread \n\n```java\npublic void run() {\n\ttry {\n\t\t// 当 server 未停止　并且 serverSocket 未关闭的时候一直轮询执行select()\n\t\twhile (!stopped && !acceptSocket.socket().isClosed()) {\n\t\t\t\ttry {\n\t\t\t\t\t\tselect();\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected runtime exception\", e);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected exception\", e);\n\t\t\t\t}\n\t\t}\n\t} finally {\n\t\tcloseSelector();\n\t\t// This will wake up the selector threads, and tell the\n\t\t// worker thread pool to begin shutdown.\n\t\tif (!reconfiguring) {                    \n\t\t\t\tNIOServerCnxnFactory.this.stop();\n\t\t}\n\t\tLOG.info(\"accept thread exitted run method\");\n\t}\n}\n```\n\n```java\nprivate void select() {\n\ttry {\n\t\tselector.select();\n\n\t\tIterator<SelectionKey> selectedKeys =\n\t\t\t\tselector.selectedKeys().iterator();\n\t\twhile (!stopped && selectedKeys.hasNext()) {\n\t\t\t\tSelectionKey key = selectedKeys.next();\n\t\t\t\tselectedKeys.remove();\n\n\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (key.isAcceptable()) {\n\t\t\t\t\t\tif (!doAccept()) {\n\t\t\t\t\t\t\tpauseAccept(10);\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Unexpected ops in accept select \"\n\t\t\t\t\t\t\t\t\t\t+ key.readyOps());\n\t\t\t\t}\n\t\t}\n\t} catch (IOException e) {\n\t\tLOG.warn(\"Ignoring IOException while selecting\", e);\n\t}\n}\n```\n\n```java\nprivate boolean doAccept() {\n\t\tboolean accepted = false;\n\t\tSocketChannel sc = null;\n\t\ttry {\n\t\t\t\t// 获取客户端链接\n\t\t\t\tsc = acceptSocket.accept();\n\t\t\t\taccepted = true;\n\t\t\t\tInetAddress ia = sc.socket().getInetAddress();\n\t\t\t\tint cnxncount = getClientCnxnCount(ia);\n\t\t\t\t// 判断该客户端连接数是否超过最大值\n\t\t\t\tif (maxClientCnxns > 0 && cnxncount >= maxClientCnxns){\n\t\t\t\t\t\tthrow new IOException(\"Too many connections from \" + ia\n\t\t\t\t\t\t\t\t\t\t+ \" - max is \" + maxClientCnxns );\n\t\t\t\t}\n\n\t\t\t\tLOG.info(\"Accepted socket connection from \"\n\t\t\t\t\t\t\t\t+ sc.socket().getRemoteSocketAddress());\n\t\t\t\tsc.configureBlocking(false);\n\n\t\t\t\t// Round-robin assign this connection to a selector thread\n\t\t\t\t// 选取一个 selectorThread\n\t\t\t\tif (!selectorIterator.hasNext()) {\n\t\t\t\t\t\tselectorIterator = selectorThreads.iterator();\n\t\t\t\t}\n\t\t\t\tSelectorThread selectorThread = selectorIterator.next();\n\t\t\t\t// 将接收到的链接　添加到　selector thread 的接收队列中\n\t\t\t\tif (!selectorThread.addAcceptedConnection(sc)) {\n\t\t\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\t\t\t\t\"Unable to add connection to selector queue\"\n\t\t\t\t\t\t\t\t\t\t+ (stopped ? \" (shutdown in progress)\" : \"\"));\n\t\t\t\t}\n\t\t\t\tacceptErrorLogger.flush();\n\t\t} catch (IOException e) {\n\t\t\t\t// accept, maxClientCnxns, configureBlocking\n\t\t\t\tacceptErrorLogger.rateLimitLog(\n\t\t\t\t\t\t\t\t\"Error accepting new connection: \" + e.getMessage());\n\t\t\t\tfastCloseSock(sc);\n\t\t}\n\t\treturn accepted;\n}\n```\n>  从代码中可以看出 AcceptThread 主要用来接收客户端的链接，并将就绪的客户端链接添加到 selectorThread线程对象的 acceptQueue 中\n\n###### SelectorThread\n\n```java\npublic boolean addAcceptedConnection(SocketChannel accepted) {\n\t\tif (stopped || !acceptedQueue.offer(accepted)) {\n\t\t\t\treturn false;\n\t\t}\n\t\t// 当接收到一个链接的时候, 唤醒阻塞在 selector.select(）操作上的线程\n\t\twakeupSelector();\n\t\treturn true;\n}\n```\n> 当 AcceptThread 将就绪的客户端链接添加到 selectorThread 对象的 acceptQueue 队列中的时候，同时会唤醒阻塞在 acceptQueue.poll() , selector.select() 操作的实例\n\n```java\npublic void run() {\n\t\ttry {\n\t\t\t\twhile (!stopped) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tselect();\n\t\t\t\t\t\t\t\t// 处理 acceptedQueue 队列里面的客户端链接\n\t\t\t\t\t\t\t\tprocessAcceptedConnections();\n\t\t\t\t\t\t\t\tprocessInterestOpsUpdateRequests();\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected runtime exception\", e);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Ignoring unexpected exception\", e);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Close connections still pending on the selector. Any others\n\t\t\t\t// with in-flight work, let drain out of the work queue.\n\t\t\t\tfor (SelectionKey key : selector.keys()) {\n\t\t\t\t\t\tNIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\t\t\t\t\t\tif (cnxn.isSelectable()) {\n\t\t\t\t\t\t\t\tcnxn.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t}\n\t\t\t\tSocketChannel accepted;\n\t\t\t\twhile ((accepted = acceptedQueue.poll()) != null) {\n\t\t\t\t\t\tfastCloseSock(accepted);\n\t\t\t\t}\n\t\t\t\tupdateQueue.clear();\n\t\t} finally {\n\t\t\t\tcloseSelector();\n\t\t\t\t// This will wake up the accept thread and the other selector\n\t\t\t\t// threads, and tell the worker thread pool to begin shutdown.\n\t\t\t\tNIOServerCnxnFactory.this.stop();\n\t\t\t\tLOG.info(\"selector thread exitted run method\");\n\t\t}\n}\n```\n\n```java\nprivate void select() {\n\t\ttry {\n\t\t\t\tselector.select();\n\n\t\t\t\tSet<SelectionKey> selected = selector.selectedKeys();\n\t\t\t\tArrayList<SelectionKey> selectedList =\n\t\t\t\t\t\tnew ArrayList<SelectionKey>(selected);\n\t\t\t\tCollections.shuffle(selectedList);\n\t\t\t\tIterator<SelectionKey> selectedKeys = selectedList.iterator();\n\t\t\t\twhile(!stopped && selectedKeys.hasNext()) {\n\t\t\t\t\t\tSelectionKey key = selectedKeys.next();\n\t\t\t\t\t\tselected.remove(key);\n\n\t\t\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (key.isReadable() || key.isWritable()) {\n\t\t\t\t\t\t\t\thandleIO(key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOG.warn(\"Unexpected ops in select \" + key.readyOps());\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(\"Ignoring IOException while selecting\", e);\n\t\t}\n}\n\n```\n\n```java\nprivate void handleIO(SelectionKey key) {\n\t\tIOWorkRequest workRequest = new IOWorkRequest(this, key);\n\t\tNIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\n\t\t// Stop selecting this key while processing on its\n\t\t// connection\n\t\tcnxn.disableSelectable();\n\t\tkey.interestOps(0);\n\t\ttouchCnxn(cnxn);\n\n\t\tLOG.info(\"Selector THread 开始处理　io\");\n\t\tworkerPool.schedule(workRequest);\n}\n```\n\n```java\nprivate void processAcceptedConnections() {\n\t\tSocketChannel accepted;\n\t\twhile (!stopped && (accepted = acceptedQueue.poll()) != null) {\n\t\t\t\tSelectionKey key = null;\n\t\t\t\ttry {\n\t\t\t\t\t\t// 将　acceptQueue 中的　socketChannel 注册到 selector　并监听读事件\n\t\t\t\t\t\tkey = accepted.register(selector, SelectionKey.OP_READ);\n\t\t\t\t\t\t// 新建　nioServerCnxn 并以附加信息的方式绑定到 selectkey\n\t\t\t\t\t\tNIOServerCnxn cnxn = createConnection(accepted, key, this);\n\t\t\t\t\t\tkey.attach(cnxn);\n\t\t\t\t\t\taddCnxn(cnxn);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// register, createConnection\n\t\t\t\t\t\tcleanupSelectionKey(key);\n\t\t\t\t\t\tfastCloseSock(accepted);\n\t\t\t\t}\n\t\t}\n}\n```\n\n从以上代码可以看出 selectorThread 流程如下:\n> - 轮询 selector 选择器上是否有就绪的客户端通道\n> - 当有就绪 Read 事件的客户端通道时　将该客户端派发到 wokerPool 去执行\n> - 当 acceptQueue 队列中有新接收的到客户通道的时候 将其注册到 selector 上并监听 READ 事件；同时并创建一个 NIOServerCnxn 对象绑定到 key 上（待执行 handleIO 时用到）\n\n接下来看下 wokerPool 如何处理 workRequest\n\n```java\npublic void schedule(WorkRequest workRequest, long id) {\n\t\tif (stopped) {\n\t\t\t\tworkRequest.cleanup();\n\t\t\t\treturn;\n\t\t}\n\n\t\tScheduledWorkRequest scheduledWorkRequest =\n\t\t\t\tnew ScheduledWorkRequest(workRequest);\n\n\t\t// If we have a worker thread pool, use that; otherwise, do the work\n\t\t// directly.\n\t\t// 如果　workers 数量大于 0, 则通过　ExecutorService 执行　scheduledWorkRequest；　反之直接调用　ScheduledWorkRequest\n\t\tint size = workers.size();\n\t\tif (size > 0) {\n\t\t\t\ttry {\n\t\t\t\t\t\t// make sure to map negative ids as well to [0, size-1]\n\t\t\t\t\t\tint workerNum = ((int) (id % size) + size) % size;\n\t\t\t\t\t\tExecutorService worker = workers.get(workerNum);\n\t\t\t\t\t\tworker.execute(scheduledWorkRequest);\n\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\tLOG.warn(\"ExecutorService rejected execution\", e);\n\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t}\n\t\t} else {\n\t\t\t\t// When there is no worker thread pool, do the work directly\n\t\t\t\t// and wait for its completion\n\t\t\t\tscheduledWorkRequest.start();\n\t\t\t\ttry {\n\t\t\t\t\t\tscheduledWorkRequest.join();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tLOG.warn(\"Unexpected exception\", e);\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n```java\nprivate class ScheduledWorkRequest extends ZooKeeperThread {\n\t\tprivate final WorkRequest workRequest;\n\n\t\tScheduledWorkRequest(WorkRequest workRequest) {\n\t\t\t\tsuper(\"ScheduledWorkRequest\");\n\t\t\t\tthis.workRequest = workRequest;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\t\t// Check if stopped while request was on queue\n\t\t\t\t\t\tif (stopped) {\n\t\t\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tworkRequest.doWork();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLOG.warn(\"Unexpected exception\", e);\n\t\t\t\t\t\tworkRequest.cleanup();\n\t\t\t\t}\n\t\t}\n}\n\n```\n\n```java\nprivate class IOWorkRequest extends WorkerService.WorkRequest {\n\t\tprivate final SelectorThread selectorThread;\n\t\tprivate final SelectionKey key;\n\t\tprivate final NIOServerCnxn cnxn;\n\n\t\tIOWorkRequest(SelectorThread selectorThread, SelectionKey key) {\n\t\t\t\tthis.selectorThread = selectorThread;\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.cnxn = (NIOServerCnxn) key.attachment();\n\t\t}\n\n\t\tpublic void doWork() throws InterruptedException {\n\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\tselectorThread.cleanupSelectionKey(key);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key.isReadable() || key.isWritable()) {\n\n\t\t\t\t\t\tLOG.info(\"IOWorker Request do work \");\n\t\t\t\t\t\tcnxn.doIO(key);\n\n\t\t\t\t\t\t// Check if we shutdown or doIO() closed this connection\n\t\t\t\t\t\tif (stopped) {\n\t\t\t\t\t\t\t\tcnxn.close();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!key.isValid()) {\n\t\t\t\t\t\t\t\tselectorThread.cleanupSelectionKey(key);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttouchCnxn(cnxn);\n\t\t\t\t}\n\n\t\t\t\t// Mark this connection as once again ready for selection\n\t\t\t\tcnxn.enableSelectable();\n\t\t\t\t// Push an update request on the queue to resume selecting\n\t\t\t\t// on the current set of interest ops, which may have changed\n\t\t\t\t// as a result of the I/O operations we just performed.\n\t\t\t\tif (!selectorThread.addInterestOpsUpdateRequest(key)) {\n\t\t\t\t\t\tcnxn.close();\n\t\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t\t\tpublic void cleanup() {\n\t\t\t\t\t\tcnxn.close();\n\t\t\t\t}\n}\n```\n\n> 从上面代码可以看出在执行 IOWorkRequest 时会选择由线程池执行还是单线程执行；最终会由 NIOServerCnxn　处理客户端通道的读写事件\n\n> 综合 AcceptThread SelectorThread IOWorkRequest 可以看出 zookeeper server 的线程模型为单线程的 Reactor模型;如下图所示:\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm40t5nc2j30m90axdgd.jpg)\n> 后续相关的 IO 处理及　PrepRequestProcessor 相关的 Processor 流程会在下文分析\n","tags":["zookeeper"]},{"title":"VIM 支持 markdown 预览","url":"/2017/12/12/vim编写markdown实时预览/","content":"### 安装 vim 插件管理器 [vundle](https://github.com/VundleVim/Vundle.vim)\n\n##### 下载 vundle\n\n```\n\tgit clone https://github.com/VundleVim/Vundle.vim ~/.vim/bundle/Vundle.vim\n```\n\n##### 编辑 vim 配置文件 vimrc\n\n> 通过 apt-get install vim 安装的 vim 配置文件路径为 /etc/vim/vimrc\n\n```\n\tvim /etc/vim/vimrc\n```\n<!-- more -->\n> 将以下内容添加到 vimrc 文件中\n\n```xml\nset nocompatible    \" be iMproved, required\nfiletype off \" required\n\n\" 启用vundle来管理vim插件\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\n\" 安装插件写在这之后\n\n\" let Vundle manage Vundle, required\nPlugin 'VundleVim/Vundle.vim'\n\n\" 安装插件写在这之前\ncall vundle#end() \" required\nfiletype plugin on \n\n\" required\" 常用命令\n\" :PluginList - 查看已经安装的插件\n\" :PluginInstall - 安装插件\n\" :PluginUpdate - 更新插件\n\" :PluginSearch - 搜索插件，例如 :PluginSearch xml就能搜到xml相关的插件\n\" :PluginClean - 删除插件，把安装插件对应行删除，然后执行这个命令即可\n\n\" h: vundle - 获取帮助\n```\n\n> 进入 vim 执行 PluginInstall\n\n```\n\tsudo vim\n\n\t:PluginInstall\n```\n\n> 插件安装完成后,　左下角会出现 Done！ 至此 vundle 插件管理器安装完成.\n\n##### 安装 vim-instant-markdown 插件\n\n> 在 vim 配置文件 vimrc 文件中添加以下内容:\n\n```\n Plugin 'suan/vim-instant-markdown'\n```\n\n> 再次进入 vim 执行 PluginInstall; 当出现 Done！即表示插件安装完成.　此时 vim xx.md　即可实时预览 markdown 文件;效果如下图所示.\n\n![](https://ws1.sinaimg.cn/large/005YB8EKly1fmm4r0kb2sj31go0qijxk.jpg)\n","tags":["vim"]},{"title":"about","url":"/about/index.html"}]