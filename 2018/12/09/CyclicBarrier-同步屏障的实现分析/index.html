<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no" name="viewport">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content>
    <meta name="author" content="hxlzpnyist">
    <meta name="keywords" content>
    <title>CyclicBarrier 同步屏障的源码分析 ~ 断风雨</title>
    <link rel="stylesheet" href="/css/Material_Icons.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">
    
        <link rel="stylesheet" href="/css/post.css">
        
            <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
        
    
</head>

<body class=" sidebar-collapse">
<nav class="navbar navbar-transparent navbar-color-on-scroll fixed-top navbar-expand-lg" color-on-scroll="100" id="sectionsNav">
    <div class="container">
        <div class="navbar-translate">
            <a class="navbar-brand" href="/">
                断风雨</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" aria-expanded="false" aria-label="Toggle navigation">
                <span class="sr-only">Toggle navigation</span>
                <span class="navbar-toggler-icon"></span>
                <span class="navbar-toggler-icon"></span>
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav ml-auto">
                    
                        
                            <li class="nav-item">
                                <a class="nav-link" href="/archives/">
                                    归档
                                </a>
                            </li>
                        
                            <li class="nav-item">
                                <a class="nav-link" href="/about/">
                                    关于
                                </a>
                            </li>
                        
                    
                    
                        
                            <li class="nav-item">
                                <a class="nav-link" rel="tooltip" title data-placement="bottom" href="https://github.com/" target="_blank" data-original-title="See me here">
                                    <i class="fa fa-github"></i>
                                </a>
                            </li>
                        
                            <li class="nav-item">
                                <a class="nav-link" rel="tooltip" title data-placement="bottom" href="https://twitter.com/" target="_blank" data-original-title="See me here">
                                    <i class="fa fa-twitter"></i>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
    </div>
</nav>
    
  <div class="page-header header-filter" data-parallax="false" style="background-image: url('/img/post-banner.jpg'); height: 70vh;">
    
      <div class="container">
        <h1 class="title text-center post_title">CyclicBarrier 同步屏障的源码分析</h1>
        <p class="text-center"><b>星期日, 十二月 9日 2018, 12:09 中午</b></p>
      </div>
    
  </div>

  
  
  
    <div class="row" style="margin: 0 0 0; z-index: 999;">
  <div class="col-md-8 offset-md-1">
    <div class="main main-raised">
      <div class="container">
        <div class="section">
          <div class="post_content">
              <h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>CyclicBarrier 是可循环使用的屏障，主要功能是让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开；所有被屏障拦截的线程才会继续执行。</p>
</blockquote>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code class="java">public class CyclicBarrierTest {

    // 线程个数
    private int parties = 3;

    private AtomicInteger atomicInteger = new AtomicInteger(parties);

    private CyclicBarrier cyclicBarrier;

    class Protector implements Runnable {

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + &quot; - 到达屏障前&quot;);

                TimeUnit.SECONDS.sleep(2);

                cyclicBarrier.await();

                atomicInteger.decrementAndGet();

                System.out.println(Thread.currentThread().getName() + &quot; - 到达屏障后&quot;);

            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + &quot; - 等待中断&quot;);
            } catch (BrokenBarrierException e) {
                System.out.println(Thread.currentThread().getName() + &quot; - 屏障被破坏&quot;);
            }
        }
    }


    @Before
    public void init() {
        cyclicBarrier = new CyclicBarrier(parties);
    }

    @Test
    public void allAwait() {
        for (int i = 0; i &lt; parties; i++) {
            new Thread(new Protector(), &quot;Thread-&quot; + i).start();
        }

        while (true) {
            if (atomicInteger.get() == 0) {
                // 所有线程到达屏障后退出结束
                System.out.println(&quot;test over&quot;);
                break;
            }
        }
    }

    @Test
    public void oneAwaitInterrupted() throws InterruptedException {
        Thread threadA = new Thread(new Protector(), &quot;Thread-A&quot;);
        Thread threadB = new Thread(new Protector(), &quot;Thread-B&quot;);

        threadA.start();
        threadB.start();
        // 等待 3 秒，避免是 time sleep 触发中断异常
        TimeUnit.SECONDS.sleep(3);

        threadA.interrupt();

        while (true) {
            if (atomicInteger.get() == 0) {
                System.out.println(&quot;test over&quot;);
                break;
            }
            if (cyclicBarrier.isBroken()) {
                System.out.println(&quot;屏障中断退出&quot;);
                break;
            }
        }
    }
}
</code></pre>
<pre><code class="java">Thread-A - 到达屏障前
Thread-B - 到达屏障前
屏障中断退出
Thread-A - 等待中断
Thread-B - 屏障被破坏

Thread-0 - 到达屏障前
Thread-1 - 到达屏障前
Thread-2 - 到达屏障前
Thread-2 - 到达屏障后
Thread-0 - 到达屏障后
Thread-1 - 到达屏障后
test over
</code></pre>
<p>从 oneAwaitInterrupted 方法执行结果可以看出，当一个线程 A 执行中断时，另外一个线程 B 会抛出 BrokenBarrierException</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><pre><code class="java">// 可以指定拦截线程个数
public CyclicBarrier(int parties) {
    this(parties, null);
}

// 指定拦截线程个数和所有线程到达屏障处后执行的动作
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}
</code></pre>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul>
<li>barrier : 屏障</li>
<li>parties : 为屏障拦截的线程数</li>
<li>tripped : 跳闸，可以理解为打开屏障</li>
<li>generation.broken : 屏障是否破损，当屏障被打开或被重置的时候会改变值</li>
</ul>
<blockquote>
<p>简单的理解就是，当线程都到达屏障的时候，会打开屏障。</p>
</blockquote>
<h5 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h5><blockquote>
<p>await 说明线程到达屏障</p>
</blockquote>
<pre><code class="java">public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}
</code></pre>
<pre><code class="java">private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
    final ReentrantLock lock = this.lock;
    // 获取排他锁
    lock.lock();
    try {
        final Generation g = generation;
        // 屏障被破坏则抛异常
        if (g.broken)
            throw new BrokenBarrierException();

        if (Thread.interrupted()) {
            // 线程中断 则退出屏障
            breakBarrier();
            throw new InterruptedException();
        }

        // 到达屏障的计数减一
        int index = --count;      
        if (index == 0) {  // tripped
            // index == 0, 说明指定 count 的线程均到达屏障
            // 此时可以打开屏障
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    // 若指定了 barrierCommand 则执行
                    command.run();
                ranAction = true;
                // 唤醒阻塞在屏障的线程并重置 generation
                nextGeneration();
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        // loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                if (!timed)
                    // 若未指定阻塞在屏障处的等待时间，则一直等待；直至最后一个线程到达屏障处的时候被唤醒
                    trip.await();
                else if (nanos &gt; 0L)
                    // 若指定了阻塞在屏障处的等待时间，则在指定时间到达时会返回
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation &amp;&amp; ! g.broken) {
                    // 若等待过程中，线程发生了中断，则退出屏障
                    breakBarrier();
                    throw ie;
                } else {
                    // We&#39;re about to finish waiting even if we had not
                    // been interrupted, so this interrupt is deemed to
                    // &quot;belong&quot; to subsequent execution.
                    Thread.currentThread().interrupt();
                }
            }

            // 屏障被破坏 则抛出异常
            if (g.broken)
                throw new BrokenBarrierException();

            if (g != generation)
                // g != generation 说明所有线程均到达屏障处 可直接返回
                // 因为所有线程到达屏障处的时候，会重置 generation
                // 参考 nextGeneration
                return index;

            if (timed &amp;&amp; nanos &lt;= 0L) {
                // 说明指定时间内，还有线程未到达屏障处，也就是等待超时
                // 退出屏障
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
</code></pre>
<pre><code class="java">private void nextGeneration() {
    // signal completion of last generation
    // 唤醒阻塞在等待队列的线程
    trip.signalAll();
    // set up next generation
    // 重置 count
    count = parties;
    // 重置 generation
    generation = new Generation();
}
</code></pre>
<pre><code class="java">private void breakBarrier() {
    // broken 设置为 true
    generation.broken = true;
    // 重置 count
    count = parties;
    // 唤醒等待队列的线程
    trip.signalAll();
}
</code></pre>
<p>如下图为 CyclicBarrier 实现效果图：</p>
<p><img src="https://i.loli.net/2019/06/21/5d0c7d7db330d70388.gif" alt></p>
<h5 id="isBroken"><a href="#isBroken" class="headerlink" title="isBroken()"></a>isBroken()</h5><blockquote>
<p>返回屏障是否被破坏，也是是否被中断</p>
</blockquote>
<pre><code class="java">public boolean isBroken() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return generation.broken;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h5><pre><code class="java">public void reset() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        // 唤醒阻塞的线程
        breakBarrier();   // break the current generation
        // 重新设置 generation
        nextGeneration(); // start a new generation
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h5 id="getNumberWaiting"><a href="#getNumberWaiting" class="headerlink" title="getNumberWaiting"></a>getNumberWaiting</h5><blockquote>
<p>获取阻塞在屏障处的线程数</p>
</blockquote>
<pre><code class="java">public int getNumberWaiting() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        // 拦截线程数 - 未到达屏障数
        return parties - count;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>CyclicBarrier 和 CountDownLatch 功能类似，不同之处在于 CyclicBarrier 支持重复利用，而 CountDownLatch 计数只能使用一次。</p>

          </div>
          <br><br>
          <div>
              <p>
                       
                      <span class="badge badge-default">#&nbsp;jdk</span>
                      &nbsp;
                       
                      <span class="badge badge-default">#&nbsp;多线程</span>
                      &nbsp;
                      
              </p>
          </div>
        </div>
      </div>  
    </div>
  </div>
  <!-- TOC -->
  
  <div id="toc">
    <p class="toc-title"><i class="material-icons" style="vertical-align:middle">toc</i>Toc:</p> 
    <div id="tocbot"></div>
  </div>

</div>


<br>
<!-- Comments -->
<div class="comments" id="comments">

    
    
<div id="vcomments" style="width: 80%;margin: 0 auto;"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'false' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '#vcomments',
            notify: notify,
            verify: verify,
            app_id: "eMGsR0oYyKCWntUWOvPI30ul-gzGzoHsz",
            app_key: "Foweb4btd057FvDg9X3M3r83",
            placeholder: "说点什么",
            avatar:"retro",
            meta: ['nick','mail','link'],
            pageSize: "10",
            visitor: "false"
        });
    };
</script>
<noscript>Please enable JavaScript to view the <a href="https://valine.js.org">comments powered by Valine.</a></noscript>


</div>
  

<footer class="footer footer-default">
        <div class="container">
          <div class="float-left" style="padding: 15px 0;">
              <b>多喝热水</b>
          </div>
          <div class="copyright float-right">
            &copy;
            <script>
              document.write(new Date().getFullYear())
            </script>&nbsp;<a href="https://hexo.io/zh-cn/" target="_blank">HEXO</a>&nbsp;<i class="material-icons">favorite_border</i>
            <a href="https://github.com/invom/Material-T" target="_blank">Material-T</a>
          </div>
        </div>
</footer>
      <!--   Core JS Files   -->
      <script src="/js/core/jquery.min.js?v=3.2.1"></script>
      <script src="/js/main.js"></script>
      <script src="/js/core/popper.min.js"></script>
      <script src="/js/core/bootstrap-material-design.min.js"></script>
      <script src="/js/plugins/moment.min.js"></script>
      <!-- Control Center for Material Kit: parallax effects, scripts for the example pages etc -->
      <script src="/js/material-kit.min.js?v=2.0.5"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
        <script src="/js/post.js"></script>
        <script src="/js/plugins/prettify.js"></script>
        <script>
            $(document).ready(function(){
                $('pre').addClass('prettyprint linenums');
                prettyPrint();
            })
        </script>
      
</body>
</html>