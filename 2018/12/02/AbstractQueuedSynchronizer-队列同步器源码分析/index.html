<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no" name="viewport">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content>
    <meta name="author" content="hxlzpnyist">
    <meta name="keywords" content>
    <title>AbstractQueuedSynchronizer 队列同步器源码分析 ~ 断风雨</title>
    <link rel="stylesheet" href="/css/Material_Icons.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">
    
        <link rel="stylesheet" href="/css/post.css">
        
            <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
        
    
</head>

<body class=" sidebar-collapse">
<nav class="navbar navbar-transparent navbar-color-on-scroll fixed-top navbar-expand-lg" color-on-scroll="100" id="sectionsNav">
    <div class="container">
        <div class="navbar-translate">
            <a class="navbar-brand" href="/">
                断风雨</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" aria-expanded="false" aria-label="Toggle navigation">
                <span class="sr-only">Toggle navigation</span>
                <span class="navbar-toggler-icon"></span>
                <span class="navbar-toggler-icon"></span>
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav ml-auto">
                    
                        
                            <li class="nav-item">
                                <a class="nav-link" href="/archives/">
                                    archives
                                </a>
                            </li>
                        
                            <li class="nav-item">
                                <a class="nav-link" href="/about/">
                                    about
                                </a>
                            </li>
                        
                    
                    
                        
                            <li class="nav-item">
                                <a class="nav-link" rel="tooltip" title data-placement="bottom" href="https://github.com/" target="_blank" data-original-title="See me here">
                                    <i class="fa fa-github"></i>
                                </a>
                            </li>
                        
                            <li class="nav-item">
                                <a class="nav-link" rel="tooltip" title data-placement="bottom" href="https://twitter.com/" target="_blank" data-original-title="See me here">
                                    <i class="fa fa-twitter"></i>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
    </div>
</nav>
    
  <div class="page-header header-filter" data-parallax="false" style="background-image: url('/img/post-banner.jpg'); height: 70vh;">
    
      <div class="container">
        <h1 class="title text-center post_title">AbstractQueuedSynchronizer 队列同步器源码分析</h1>
        <p class="text-center"><b>星期日, 十二月 2日 2018, 4:09 下午</b></p>
      </div>
    
  </div>

  
  
  
    <div class="row" style="margin: 0 0 0; z-index: 999;">
  <div class="col-md-8 offset-md-1">
    <div class="main main-raised">
      <div class="container">
        <div class="section">
          <div class="post_content">
              <h3 id="AbstractQueuedSynchronizer-队列同步器（AQS）"><a href="#AbstractQueuedSynchronizer-队列同步器（AQS）" class="headerlink" title="AbstractQueuedSynchronizer 队列同步器（AQS）"></a>AbstractQueuedSynchronizer 队列同步器（AQS）</h3><blockquote>
<p>队列同步器 (AQS), 是用来构建锁或其他同步组件的基础框架，它通过使用 int 变量表示同步状态，通过内置的 FIFO 的队列完成资源获取的排队工作。（摘自《Java并发编程的艺术》）</p>
</blockquote>
<p>我们知道获取同步状态有独占和共享两种模式，本文先针对独占模式进行分析。</p>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><pre><code class="java">private transient volatile Node head;
</code></pre>
<p>head 同步队列头节点</p>
<pre><code class="java">private transient volatile Node tail;
</code></pre>
<p>tail 同步队列尾节点</p>
<pre><code class="java">private volatile int state;
</code></pre>
<p>state 同步状态值</p>
<h4 id="Node-同步队列节点定义"><a href="#Node-同步队列节点定义" class="headerlink" title="Node - 同步队列节点定义"></a>Node - 同步队列节点定义</h4><pre><code class="java">volatile int waitStatus;
</code></pre>
<p>waitStatus 节点的等待状态，可取值如下 :</p>
<ul>
<li>0 : 初始状态</li>
<li>-1 : SIGNAL 处于该状态的节点，说明其后置节点处于等待状态； 若当前节点释放了锁可唤醒后置节点</li>
<li>-2 : CONDITION 该状态与 Condition 操作有关后续在说明</li>
<li>-3 : PROPAGATE 该状态与共享式获取同步状态操作有关后续在说明</li>
<li>1 : CANCELLED 处于该状态的节点会取消等待，从队列中移除</li>
</ul>
<pre><code class="java">volatile Node prev;
</code></pre>
<p>prev 指向当前节点的前置节点</p>
<pre><code class="java">volatile Node next;
</code></pre>
<p>next 指向当前节点的后置节点</p>
<pre><code class="java">volatile Thread thread;
</code></pre>
<p>thread 节点对应的线程也是指当前获取锁失败的线程</p>
<pre><code class="java">Node nextWaiter;
</code></pre>
<h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><blockquote>
<p>独占模式下获取同步状态， 既是当前只允许一个线程获取到同步状态</p>
</blockquote>
<pre><code class="java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<p>从 acquire 方法中我们可以大概猜测下，获取锁的过程如下：</p>
<ul>
<li>tryAcquire 尝试获取同步状态， 具体如何判定获取到同步状态由子类实现</li>
<li>当获取同步状态失败时，执行 addWaiter 创建独占模式下的 Node 并将其添加到同步队列尾部</li>
<li>加入同步队列之后，再次尝试获取同步状态，当达到某种条件的时候将当前线程挂起等待唤醒</li>
</ul>
<p>下面具体看下各个阶段如何实现：</p>
<pre><code class="java">private Node addWaiter(Node mode) {
    // 绑定当前线程 创建 Node 节点
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    // 判断同步队列尾节点是否为空
    if (pred != null) {
        // node 的前置节点指向队列尾部
        node.prev = pred;
        // 将同步队列的 tail 移动指向 node
        if (compareAndSetTail(pred, node)) {
            // 将原同步队列的尾部后置节点指向 node
            pred.next = node;
            return node;
        }
    }
    // tail 为空说明同步队列还未初始化
    // 此时调用 enq 完成队列的初始化及 node 入队
    enq(node);
    return node;
}
</code></pre>
<pre><code class="java">private Node enq(final Node node) {
    // 轮询的方式执行
    // 成功入队后退出
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            // 创建 Node, 并将 head 指向该节点
            // 同时将 tail 指向该节点
            // 完成队列的初始化
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // node 的前置节点指向队列尾部
            node.prev = t;
            // 将同步队列的 tail 移动指向 node
            if (compareAndSetTail(t, node)) {
                // 将原同步队列的尾部后置节点指向 node
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<p>从代码中可以看出通过 CAS 操作保证节点入队的有序安全，其入队过程中如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/27/1675413481b66ce2?w=1137&amp;h=256&amp;f=png&amp;s=11932" alt="AQS节点入队过程"></p>
<pre><code class="java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        // 
        for (;;) {
            // 获取当前节点的前置节点
            final Node p = node.predecessor();
            // 判断前置节点是否为 head 头节点
            // 若前置节点为 head 节点，则再次尝试获取同步状态
            if (p == head &amp;&amp; tryAcquire(arg)) {
                // 若获取同步状态成功
                // 则将队列的 head 移动指向当前节点
                setHead(node);
                // 将原头部节点的 next 指向为空，便于对象回收
                p.next = null; // help GC
                failed = false;
                // 退出轮询过程
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<pre><code class="java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        // 若前置节点状态为 -1 ，则说明后置节点 node 可以安全挂起了
        return true;
    if (ws &gt; 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            // ws &gt; 0 说明前置节点状态为 CANCELLED , 也就是说前置节点为无效节点
            // 此时从前置节点开始向队列头节点方向寻找有效的前置节点
            // 此操作也即是将 CANCELLED 节点从队列中移除
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don&#39;t park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        // 若前置节点状态为初始状态 则将其状态设为 -1
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<pre><code class="java">private final boolean parkAndCheckInterrupt() {
    // 将当前线程挂起
    LockSupport.park(this);
    // 被唤醒后检查当前线程是否被挂起
    return Thread.interrupted();
}
</code></pre>
<p>从 acquireQueued 的实现可以看出，节点在入队后会采用轮询的方式（自旋）重复执行以下过程：</p>
<ul>
<li>判断前置节点是否为 head， 若为 head 节点则尝试获取同步状态； 若获取同步状态成功则移动 head 指向当前节点并退出循环</li>
<li>若前置节点非 head 节点或者获取同步状态失败，则将前置节点状态修改为 -1， 并挂起当前线程，等待被唤醒重复执行以上过程</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167543bc86ada28d?w=420&amp;h=543&amp;f=png&amp;s=17640" alt="AQS-节点自旋活动图"></p>
<p>接下来我们看看同步状态释放的实现。</p>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><blockquote>
<p>释放同步状态</p>
</blockquote>
<pre><code class="java">public final boolean release(int arg) {
    // 尝试释放同步状态
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            // 唤醒后置节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>
<pre><code class="java">private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws &lt; 0)
        // 将 head 节点状态改为 0
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    // 获取后置节点
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        // 唤醒后置节点上所阻塞的线程
        LockSupport.unpark(s.thread);
}
</code></pre>
<p>从上述代码，我们可以明白释放同步状态的过程如下：</p>
<ul>
<li>调用 tryRelease 尝试释放同步状态，同样其具体的实现由子类控制</li>
<li>成功释放同步状态后，将 head 节点状态改为 0</li>
<li>唤醒后置节点上阻塞的线程</li>
</ul>
<p>如下图所示（红色曲线表示节点自旋过程） :</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167544ef85661bdf?w=645&amp;h=652&amp;f=png&amp;s=29604" alt="AQS-释放锁"></p>
<h4 id="acquireInterruptibly"><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly()"></a>acquireInterruptibly()</h4><blockquote>
<p>独占模式下获取同步状态，不同于 acquire 方法，该方法对中断操作敏感； 也就是说当前线程在获取同步状态的过程中，若被中断则会抛出中断异常</p>
</blockquote>
<pre><code class="java">public final void acquireInterruptibly(int arg)
            throws InterruptedException {
    if (Thread.interrupted())
        // 检查线程是否被中断
        // 中断则抛出中断异常由调用方处理
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
</code></pre>
<pre><code class="java">private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                // 不同于 acquire 的操作，此处在唤醒后检查是否中断，若被中断直接抛出中断异常
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            // 抛出中断异常后最终执行 cancelAcquire
            cancelAcquire(node);
    }
}
</code></pre>
<pre><code class="java">private void cancelAcquire(Node node) {
        // Ignore if node doesn&#39;t exist
    if (node == null)
        return;

    node.thread = null;

    // Skip cancelled predecessors
    Node pred = node.prev;
    while (pred.waitStatus &gt; 0)
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary.
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    // 若当前节点为 tail 节点，则将 tail 移动指向 node 的前置节点
    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {
        // 同时将node 前置节点的 next 指向 null
        compareAndSetNext(pred, predNext, null);
    } else {
        // If successor needs signal, try to set pred&#39;s next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &amp;&amp;
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;
            pred.thread != null) {
            // 当前节点位于队列中部    
            Node next = node.next;
            if (next != null &amp;&amp; next.waitStatus &lt;= 0)
                // 将前置节点的 next 指向 node 的后置节点
                compareAndSetNext(pred, predNext, next);
        } else {
            // 若 node 的前置节点为 head 节点则唤醒 node 节点的后置节点
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
</code></pre>
<p>从 acquireInterruptibly 的实现可以看出，若线程在获取同步状态的过程中出现中断操作，则会将当前线程对应的同步队列等待节点从队列中移除并唤醒可获取同步状态的线程。</p>
<h4 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos()"></a>tryAcquireNanos()</h4><blockquote>
<p>独占模式超时获取同步状态，该操作与acquireInterruptibly一样对中断操作敏感，不同在于超过等待时间若未获取到同步状态将会返回</p>
</blockquote>
<pre><code class="java">public final boolean tryAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquire(arg) ||
        doAcquireNanos(arg, nanosTimeout);
}
</code></pre>
<pre><code class="java">private boolean doAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
    if (nanosTimeout &lt;= 0L)
        return false;
    // 计算等待到期时间
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return true;
            }
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout &lt;= 0L)
                // 超时时间到期直接返回
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                nanosTimeout &gt; spinForTimeoutThreshold)
                // 按指定时间挂起s
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<h4 id="节点的状态"><a href="#节点的状态" class="headerlink" title="节点的状态"></a>节点的状态</h4><p>同步队列中的节点在自旋获取同步状态的过程中，会将前置节点的状态由 0 初始状态改为 -1 SIGNAL, 若是中断敏感的操作则会将状态由 0 改为 1</p>
<p>同步队列中的节点在释放同步状态的过程中会将同步队列的 head 节点的状态改为 0， 也即是由 -1 变为 0；</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本文主要分析了独占模式获取同步状态的操作，其大概流程如下：</p>
<ul>
<li>在获取同步状态时，AQS 内部维护了一个同步队列，获取状态失败的线程会被构造一个节点加入到队列中并进行一系列自旋操作</li>
<li>在释放同步状态时，唤醒 head 的后置节点去获取同步状态</li>
</ul>

          </div>
          <br><br>
          <div>
              <p>
                       
                      <span class="badge badge-default">#&nbsp;jdk</span>
                      &nbsp;
                       
                      <span class="badge badge-default">#&nbsp;多线程</span>
                      &nbsp;
                      
              </p>
          </div>
        </div>
      </div>  
    </div>
  </div>
  <!-- TOC -->
  
  <div id="toc">
    <p class="toc-title"><i class="material-icons" style="vertical-align:middle">toc</i>Toc:</p> 
    <div id="tocbot"></div>
  </div>

</div>


<br>
<!-- Comments -->
<div class="comments" id="comments">

    
    <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script>               
        var disqus_shortname = '';
        var disqus_config = function () {
            this.page.url = 'https://hxlzpnyist.github.io/2018/12/02/AbstractQueuedSynchronizer-队列同步器源码分析/'; 
            this.page.identifier = '/2018/12/02/AbstractQueuedSynchronizer-队列同步器源码分析/';
        };
        (function() { 
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript';
            s.src = '//'+disqus_shortname+'.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>                                
</div>

</div>
  

<footer class="footer footer-default">
        <div class="container">
          <div class="float-left" style="padding: 15px 0;">
              <b>多喝热水</b>
          </div>
          <div class="copyright float-right">
            &copy;
            <script>
              document.write(new Date().getFullYear())
            </script>&nbsp;<a href="https://hexo.io/zh-cn/" target="_blank">HEXO</a>&nbsp;<i class="material-icons">favorite_border</i>
            <a href="https://github.com/invom/Material-T" target="_blank">Material-T</a>
          </div>
        </div>
</footer>
      <!--   Core JS Files   -->
      <script src="/js/core/jquery.min.js?v=3.2.1"></script>
      <script src="/js/main.js"></script>
      <script src="/js/core/popper.min.js"></script>
      <script src="/js/core/bootstrap-material-design.min.js"></script>
      <script src="/js/plugins/moment.min.js"></script>
      <!-- Control Center for Material Kit: parallax effects, scripts for the example pages etc -->
      <script src="/js/material-kit.min.js?v=2.0.5"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
        <script src="/js/post.js"></script>
        <script src="/js/plugins/prettify.js"></script>
        <script>
            $(document).ready(function(){
                $('pre').addClass('prettyprint linenums');
                prettyPrint();
            })
        </script>
      
</body>
</html>