<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no" name="viewport">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content>
    <meta name="author" content="hxlzpnyist">
    <meta name="keywords" content>
    <title>zookeeper源码阅读之client ~ 断风雨</title>
    <link rel="stylesheet" href="/css/Material_Icons.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/main.css">
    
        <link rel="stylesheet" href="/css/post.css">
        
            <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
        
    
</head>

<body class=" sidebar-collapse">
<nav class="navbar navbar-transparent navbar-color-on-scroll fixed-top navbar-expand-lg" color-on-scroll="100" id="sectionsNav">
    <div class="container">
        <div class="navbar-translate">
            <a class="navbar-brand" href="/">
                断风雨</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" aria-expanded="false" aria-label="Toggle navigation">
                <span class="sr-only">Toggle navigation</span>
                <span class="navbar-toggler-icon"></span>
                <span class="navbar-toggler-icon"></span>
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav ml-auto">
                    
                        
                            <li class="nav-item">
                                <a class="nav-link" href="/archives/">
                                    归档
                                </a>
                            </li>
                        
                            <li class="nav-item">
                                <a class="nav-link" href="/about/">
                                    关于
                                </a>
                            </li>
                        
                    
                    
                        
                            <li class="nav-item">
                                <a class="nav-link" rel="tooltip" title data-placement="bottom" href="https://github.com/" target="_blank" data-original-title="See me here">
                                    <i class="fa fa-github"></i>
                                </a>
                            </li>
                        
                            <li class="nav-item">
                                <a class="nav-link" rel="tooltip" title data-placement="bottom" href="https://twitter.com/" target="_blank" data-original-title="See me here">
                                    <i class="fa fa-twitter"></i>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
    </div>
</nav>
    
  <div class="page-header header-filter" data-parallax="false" style="background-image: url('/img/post-banner.jpg'); height: 70vh;">
    
      <div class="container">
        <h1 class="title text-center post_title">zookeeper源码阅读之client</h1>
        <p class="text-center"><b>星期五, 十二月 15日 2017, 1:46 下午</b></p>
      </div>
    
  </div>

  
  
  
    <div class="row" style="margin: 0 0 0; z-index: 999;">
  <div class="col-md-8 offset-md-1">
    <div class="main main-raised">
      <div class="container">
        <div class="section">
          <div class="post_content">
              <h4 id="zookeeper-client-启动流程"><a href="#zookeeper-client-启动流程" class="headerlink" title="zookeeper client 启动流程"></a>zookeeper client 启动流程</h4><blockquote>
<p>先看下 zookeeper client 相关类图<br><img src="https://ws1.sinaimg.cn/large/005YB8EKly1fmm4gu34pbj30vp0g1t9p.jpg" alt></p>
</blockquote>
<h5 id="执行-zkCli-sh-脚本时-会运行-org-apache-zookeeper-ZookeeperMain-类主方法"><a href="#执行-zkCli-sh-脚本时-会运行-org-apache-zookeeper-ZookeeperMain-类主方法" class="headerlink" title="执行 zkCli.sh 脚本时, 会运行 org.apache.zookeeper.ZookeeperMain 类主方法."></a>执行 zkCli.sh 脚本时, 会运行 org.apache.zookeeper.ZookeeperMain 类主方法.</h5><pre><code class="java">public static void main(String args[])
        throws KeeperException, IOException, InterruptedException
{
    ZooKeeperMain main = new ZooKeeperMain(args);
    main.run();
}

</code></pre>
<pre><code class="java">public ZooKeeperMain(String args[]) throws IOException, InterruptedException {
    // 启动参数解析
    cl.parseOptions(args);
    System.out.println(&quot;Connecting to &quot; + cl.getOption(&quot;server&quot;));
    // 链接 zookeeper server
    connectToZK(cl.getOption(&quot;server&quot;));
}
</code></pre>
<blockquote>
<p>从代码中可以看出 client 启动时首先构造 ZookeeperMain　对象实例,构造过程中会先解析 client 的启动参数（若未指定任何参数将会默认链接本机 2181 端口 zookeeper server）<br><a id="more"></a></p>
</blockquote>
<h5 id="通过调用-connectToZK-链接-zookeeper-server"><a href="#通过调用-connectToZK-链接-zookeeper-server" class="headerlink" title="通过调用 connectToZK 链接 zookeeper server"></a>通过调用 connectToZK 链接 zookeeper server</h5><pre><code class="java">protected void connectToZK(String newHost) throws InterruptedException, IOException {
    if (zk != null &amp;&amp; zk.getState().isAlive()) {
        // 若已创建 zookeeper 对象并且状态为激活　则关闭重新创建
        zk.close();
    }
    host = newHost;
    boolean readOnly = cl.getOption(&quot;readonly&quot;) != null;
    if (cl.getOption(&quot;secure&quot;) != null) {
        System.setProperty(ZKClientConfig.SECURE_CLIENT, &quot;true&quot;);
        System.out.println(&quot;Secure connection is enabled&quot;);
    }
    // 构造 Zookeeper 对象实例
    zk = new ZooKeeper(host,Integer.parseInt(cl.getOption(&quot;timeout&quot;)),
                new MyWatcher(), readOnly);
}

</code></pre>
<h5 id="创建-Zookeeper-对象实例"><a href="#创建-Zookeeper-对象实例" class="headerlink" title="创建 Zookeeper 对象实例"></a>创建 Zookeeper 对象实例</h5><pre><code class="java">// connectString 是形如 host:port,host:port 的字符串片段
public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
                boolean canBeReadOnly, HostProvider aHostProvider,
                ZKClientConfig clientConfig) throws IOException {

    if (clientConfig == null) {
        // 创建 ZKClient Config 对象
        clientConfig = new ZKClientConfig();
    }
    this.clientConfig = clientConfig;
    watchManager = defaultWatchManager();
    watchManager.defaultWatcher = watcher;
    ConnectStringParser connectStringParser = new ConnectStringParser(
                connectString);
    hostProvider = aHostProvider;
    // 创建 ClientCnxn 对象
    cnxn = new ClientCnxn(connectStringParser.getChrootPath(),
                hostProvider, sessionTimeout, this, watchManager,
                getClientCnxnSocket(), canBeReadOnly);
    cnxn.start();
}
// 创建 ClientCnxnSocket对象 默认为 ClientCnxnSocketNIO 对象
private ClientCnxnSocket getClientCnxnSocket() throws IOException {
        String clientCnxnSocketName = getClientConfig().getProperty(
                        ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);
        if (clientCnxnSocketName == null) {
                clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();
        }
        try {
                Constructor&lt;?&gt; clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);
                ClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());
                return clientCxnSocket;
        } catch (Exception e) {
                IOException ioe = new IOException(&quot;Couldn&#39;t instantiate &quot;
                                + clientCnxnSocketName);
                ioe.initCause(e);
                throw ioe;
        }
}
</code></pre>
<blockquote>
<p>从代码中看出 Zookeeper 关联了 ClientCnxn 对象, 在创建了 ClientCnxn 对象实例之后调用了 cnxn.start() 方法。</p>
</blockquote>
<h5 id="创建-ClientCnxn-对象实例"><a href="#创建-ClientCnxn-对象实例" class="headerlink" title="创建 ClientCnxn 对象实例"></a>创建 ClientCnxn 对象实例</h5><pre><code class="java">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,
                ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,
                long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) {
        this.zooKeeper = zooKeeper;
        this.watcher = watcher;
        this.sessionId = sessionId;
        this.sessionPasswd = sessionPasswd;
        this.sessionTimeout = sessionTimeout;
        this.hostProvider = hostProvider;
        this.chrootPath = chrootPath;
        // 计算连接超时时间　读数据超时时间
        connectTimeout = sessionTimeout / hostProvider.size();
        readTimeout = sessionTimeout * 2 / 3;
        readOnly = canBeReadOnly;
        // 创建了 SendThread EventThread　线程实例
        sendThread = new SendThread(clientCnxnSocket);
        eventThread = new EventThread();
        this.clientConfig=zooKeeper.getClientConfig();
}

public void start() {
        sendThread.start();
        eventThread.start();
}
</code></pre>
<blockquote>
<p>从 start 方法中可以看出分别启动了 sendThread eventThread　两个线程。</p>
</blockquote>
<h5 id="SendThread-线程的构造及启动"><a href="#SendThread-线程的构造及启动" class="headerlink" title="SendThread 线程的构造及启动"></a>SendThread 线程的构造及启动</h5><pre><code class="java">SendThread(ClientCnxnSocket clientCnxnSocket) {
        super(makeThreadName(&quot;-SendThread()&quot;));
        state = States.CONNECTING;
        this.clientCnxnSocket = clientCnxnSocket;
        setDaemon(true);
}

</code></pre>
<blockquote>
<p>SendThread 是 ClientCnxn 的内部类, 创建该线程实例时会将 ClientCnxn 的状态由默认状态(未连接)改为连接中,并赋值 clientCnxnSocket。</p>
</blockquote>
<h6 id="ClientCnxn-的主要成员变量说明"><a href="#ClientCnxn-的主要成员变量说明" class="headerlink" title="ClientCnxn 的主要成员变量说明"></a>ClientCnxn 的主要成员变量说明</h6><blockquote>
<p>在了解 sendThread 线程的启动过程有必要先了解一下关于 SendThread 和 ClientCnxn 的相关成员变量。</p>
</blockquote>
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>state</td>
<td>客户端连接状态</td>
</tr>
<tr>
<td>outgoingQueue</td>
<td>存储需要被发送出去的报文的队列</td>
</tr>
<tr>
<td>pendingQueue</td>
<td>存储已经发送等待响应结果的队列</td>
</tr>
</tbody>
</table>
<h5 id="SendThread-线程启动"><a href="#SendThread-线程启动" class="headerlink" title="SendThread 线程启动"></a>SendThread 线程启动</h5><pre><code class="java">public void run() {
    // 将 sendThread sessionId outgoingQueue 绑定到的 clientCnxnSocketNIO
    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);
    clientCnxnSocket.updateNow();
    clientCnxnSocket.updateLastSendAndHeard();
    int to;
    long lastPingRwServer = Time.currentElapsedTime();
    final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds
    while (state.isAlive()) {
        try {
            if (!clientCnxnSocket.isConnected()) {
                // don&#39;t re-establish connection if we are closing
                if (closing) {
                    break;
                }
                // 如果 clientCnxnSocketNIO 未连接　则开始连接
                startConnect();
                clientCnxnSocket.updateLastSendAndHeard();
            }    

                if (state.isConnected()) {
                        // determine whether we need to send an AuthFailed event.
                        if (zooKeeperSaslClient != null) {
                            // ssl client　的处理此处省略    
                        }
                        to = readTimeout - clientCnxnSocket.getIdleRecv();
                } else {
                        to = connectTimeout - clientCnxnSocket.getIdleRecv();
                }

                if (to &lt;= 0) {
                        String warnInfo;
                        warnInfo = &quot;Client session timed out, have not heard from server in &quot;
                                + clientCnxnSocket.getIdleRecv()
                                + &quot;ms&quot;
                                + &quot; for sessionid 0x&quot;
                                + Long.toHexString(sessionId);
                        LOG.warn(warnInfo);
                        throw new SessionTimeoutException(warnInfo);
                }
                if (state.isConnected()) {
                        //1000(1 second) is to prevent race condition missing to send the second ping
                        //also make sure not to send too many pings when readTimeout is small 
                        int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - 
                                ((clientCnxnSocket.getIdleSend() &gt; 1000) ? 1000 : 0);
                        //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL
                        if (timeToNextPing &lt;= 0 || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) {
                                // 发送心跳
                                sendPing();
                                clientCnxnSocket.updateLastSend();
                        } else {
                                if (timeToNextPing &lt; to) {
                                        to = timeToNextPing;
                                }
                        }
                }

                // If we are in read-only mode, seek for read/write server
                if (state == States.CONNECTEDREADONLY) {
                        long now = Time.currentElapsedTime();
                        int idlePingRwServer = (int) (now - lastPingRwServer);
                        if (idlePingRwServer &gt;= pingRwTimeout) {
                                lastPingRwServer = now;
                                idlePingRwServer = 0;
                                pingRwTimeout =
                                        Math.min(2*pingRwTimeout, maxPingRwTimeout);
                                pingRwServer();
                        }
                        to = Math.min(to, pingRwTimeout - idlePingRwServer);
                }

                clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);
        } catch (Throwable e) {
            // 异常处理的部分省略...    
        }
        }
        synchronized (state) {
                // When it comes to this point, it guarantees that later queued
                // packet to outgoingQueue will be notified of death.
                cleanup();
        }
        clientCnxnSocket.close();
        if (state.isAlive()) {
                eventThread.queueEvent(new WatchedEvent(Event.EventType.None,
                                        Event.KeeperState.Disconnected, null));
        }
        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
                        &quot;SendThread exited loop for session: 0x&quot;
                        + Long.toHexString(getSessionId()));
}
</code></pre>
<blockquote>
<p> 从代码中可以看出 sendThread 主要做以下事情</p>
<ul>
<li>创建客户端连接</li>
<li>发送心跳</li>
<li>发送消息 (终端输入的指令)</li>
</ul>
</blockquote>
<blockquote>
<p>下面将针对上面三种流程分析</p>
</blockquote>
<h6 id="客户端连接创建流程"><a href="#客户端连接创建流程" class="headerlink" title="客户端连接创建流程"></a>客户端连接创建流程</h6><blockquote>
<p>先大概看下此流程活动图　如下:</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/005YB8EKly1fmm4i5lp6zj30yg0oa77g.jpg" alt></p>
<blockquote>
<ul>
<li>sendThread 轮询过程中　先判断 clientCnxnSocket 是否已连接；若未连接则调用 sendThread.startConnect() 将 ClientCnxn.state 的状态改为 “连接中”, 接下来同步调用 clientCnxnSocket.connect 完成客户端 socket 的创建及注册到 selector 并监听连接事件</li>
<li>上述操作完成后会调用 clientCnxnSocket.doTransport (), 该方法主要处理 selector 选择器上就绪的通道事件.</li>
<li>当客户端 socket 连接就绪的时候会调用 sendThread.primeConnection() 准备连接方法，该方法 ConnectionRequet　的 Packet　并将其添加到 outgoingQueue　对列中，接下来调用 clientCnxnSocket.connectionPrimed 该方法主要告知 socket　准备好连接了 此时客户端在 selector 上注册读写事件 (此时会触发通道的写就绪事件)</li>
<li>当客户端 socket 写就绪的时候会调用 clientCnxnSocket.findSendablePacket 该方法从 outgoingQueue 队列中获取待发送的 Packet , 最后执行 socket.write() 发送消息(此时会触发通道的读就绪事件)</li>
<li>当客户端 socket 读就绪的时候判断 initialized 是否为 true，若为 false 说明执行连接初始化会调用 sendThread.onConnected 更改客户端状态为 “已连接”，　继续注册监听客户端的读写事件</li>
</ul>
</blockquote>
<h6 id="客户端心跳流程"><a href="#客户端心跳流程" class="headerlink" title="客户端心跳流程"></a>客户端心跳流程</h6><blockquote>
<p>心跳流程如下：</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/005YB8EKly1fmm4jaf9ooj30ro0l640z.jpg" alt></p>
<blockquote>
<ul>
<li>sendThread 轮询过程中　判断 state 是否为 “已连接”; 若已连接判断是否满足心跳条件, 调用 sendPing 创建心跳 packet　header xid = -2; 接下来将 packet　添加到 outgoingQueue　队列中并调用 clientCnxnSocket.packetAddedd　最后唤醒阻塞在 selector.select 上的操作</li>
<li>当客户端 socket 写就绪的时候调用 findSendablePacket 获取待发送的 packet 最后调用 socket.write 执行发送</li>
<li>当客户端 socket 读就绪的时候调用 sendThread.readResponse 解析服务端的响应结果, 通过获取 response heaher xid 判断 xid == -2 ;　若为 -2 则打印心跳返回日志返回，　此时一次心跳结束</li>
</ul>
</blockquote>
<h6 id="客户端终端发送指令流程"><a href="#客户端终端发送指令流程" class="headerlink" title="客户端终端发送指令流程"></a>客户端终端发送指令流程</h6><blockquote>
<p>发送指令流程图如下:</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/005YB8EKly1fmm4k6ka0bj30ts0h8gn8.jpg" alt></p>
<blockquote>
<ul>
<li>ZookeeperMain 构建完成后会调用 run　方法，等待用户输入</li>
<li>输入指令后会相应调用 executeLine, processCmd, processZKCmd 通过解析参数获取相应的 CliCommand</li>
<li>此处采用了命令模式 内置了各种 CliCommand 对应客户端相应的操作，包括(CreateCommand, GetCommand, SetCommand ….）; 获取对应的命令后，调用 parse, exec　方法执行命令</li>
<li>执行命令会调用 zookeeper 对应的操作(create, getData, setData)，在内部会调用 ClientCnxn.submitRequest 方法</li>
<li>在 clientCnxn.submitRequest　方法中会调用 queuePacket　创建 packet　并将其添加到队列中，接着唤醒 clientCnxnSocketNIO 的 selector.select 操作；后续操作就是读写就绪事件的处理与心跳流程类似。</li>
</ul>
</blockquote>
<p>至此 zookeeper client 的相关流程介绍完毕　细节的地方后续在处理.</p>

          </div>
          <br><br>
          <div>
              <p>
                      
              </p>
          </div>
        </div>
      </div>  
    </div>
  </div>
  <!-- TOC -->
  
  <div id="toc">
    <p class="toc-title"><i class="material-icons" style="vertical-align:middle">toc</i>Toc:</p> 
    <div id="tocbot"></div>
  </div>

</div>


<br>
<!-- Comments -->
<div class="comments" id="comments">

    
    
<div id="vcomments" style="width: 80%;margin: 0 auto;"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'false' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '#vcomments',
            notify: notify,
            verify: verify,
            app_id: "eMGsR0oYyKCWntUWOvPI30ul-gzGzoHsz",
            app_key: "Foweb4btd057FvDg9X3M3r83",
            placeholder: "说点什么",
            avatar:"retro",
            meta: ['nick','mail','link'],
            pageSize: "10",
            visitor: "false"
        });
    };
</script>
<noscript>Please enable JavaScript to view the <a href="https://valine.js.org">comments powered by Valine.</a></noscript>


</div>
  

<footer class="footer footer-default">
        <div class="container">
          <div class="float-left" style="padding: 15px 0;">
              <b>多喝热水</b>
          </div>
          <div class="copyright float-right">
            &copy;
            <script>
              document.write(new Date().getFullYear())
            </script>&nbsp;<a href="https://hexo.io/zh-cn/" target="_blank">HEXO</a>&nbsp;<i class="material-icons">favorite_border</i>
            <a href="https://github.com/invom/Material-T" target="_blank">Material-T</a>
          </div>
        </div>
</footer>
      <!--   Core JS Files   -->
      <script src="/js/core/jquery.min.js?v=3.2.1"></script>
      <script src="/js/main.js"></script>
      <script src="/js/core/popper.min.js"></script>
      <script src="/js/core/bootstrap-material-design.min.js"></script>
      <script src="/js/plugins/moment.min.js"></script>
      <!-- Control Center for Material Kit: parallax effects, scripts for the example pages etc -->
      <script src="/js/material-kit.min.js?v=2.0.5"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
        <script src="/js/post.js"></script>
        <script src="/js/plugins/prettify.js"></script>
        <script>
            $(document).ready(function(){
                $('pre').addClass('prettyprint linenums');
                prettyPrint();
            })
        </script>
      
</body>
</html>